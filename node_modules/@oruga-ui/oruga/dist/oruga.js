/*! Oruga v0.7.0 | MIT License | github.com/oruga-ui/oruga */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.Oruga = {}));
}(this, (function (exports) { 'use strict';

    /**
     * +/- function to native math sign
     */
    function signPoly(value) {
      if (value < 0) return -1;
      return value > 0 ? 1 : 0;
    }

    const sign = Math.sign || signPoly;
    /**
     * Checks if the flag is set
     * @param val
     * @param flag
     * @returns {boolean}
     */

    function hasFlag(val, flag) {
      return (val & flag) === flag;
    }
    /**
     * Native modulo bug with negative numbers
     * @param n
     * @param mod
     * @returns {number}
     */


    function mod(n, mod) {
      return (n % mod + mod) % mod;
    }
    /**
     * Asserts a value is beetween min and max
     * @param val
     * @param min
     * @param max
     * @returns {number}
     */


    function bound(val, min, max) {
      return Math.max(min, Math.min(max, val));
    }
    /**
     * Get value of an object property/path even if it's nested
     */

    function getValueByPath(obj, path, defaultValue = undefined) {
      const value = path.split('.').reduce((o, i) => typeof o !== 'undefined' ? o[i] : undefined, obj);
      return typeof value !== 'undefined' ? value : defaultValue;
    }
    /**
     * Extension of indexOf method by equality function if specified
     */

    function indexOf(array, obj, fn) {
      if (!array) return -1;
      if (!fn || typeof fn !== 'function') return array.indexOf(obj);

      for (let i = 0; i < array.length; i++) {
        if (fn(array[i], obj)) {
          return i;
        }
      }

      return -1;
    }
    /**
     * Merge function to replace Object.assign with deep merging possibility
     */

    const isObject = item => typeof item === 'object' && !Array.isArray(item);

    const mergeFn = (target, source, deep = false) => {
      if (deep || !Object.assign) {
        const isDeep = prop => isObject(source[prop]) && target !== null && Object.prototype.hasOwnProperty.call(target, prop) && isObject(target[prop]);

        let replaced;

        if (source === null || typeof source === 'undefined') {
          replaced = false;
        } else {
          replaced = Object.getOwnPropertyNames(source).map(prop => ({
            [prop]: isDeep(prop) ? mergeFn(target[prop], source[prop], deep) : source[prop]
          })).reduce((a, b) => ({ ...a,
            ...b
          }), {});
        }

        return { ...target,
          ...replaced
        };
      } else {
        return Object.assign(target, source);
      }
    };

    const merge = mergeFn;
    /**
     * Mobile detection
     * https://www.abeautifulsite.net/detecting-mobile-devices-with-javascript
     */

    const isMobile = {
      Android: function () {
        return typeof window !== 'undefined' && window.navigator.userAgent.match(/Android/i);
      },
      BlackBerry: function () {
        return typeof window !== 'undefined' && window.navigator.userAgent.match(/BlackBerry/i);
      },
      iOS: function () {
        return typeof window !== 'undefined' && window.navigator.userAgent.match(/iPhone|iPad|iPod/i);
      },
      Opera: function () {
        return typeof window !== 'undefined' && window.navigator.userAgent.match(/Opera Mini/i);
      },
      Windows: function () {
        return typeof window !== 'undefined' && window.navigator.userAgent.match(/IEMobile/i);
      },
      any: function () {
        return isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows();
      }
    }; // Microsoft Edge "pretends" to be all other major browsers, so we need to filter it out.
    // It doesn't use a very consistent string to represent its own name ("Edge", "Edg", "EdgA", etc.),
    // but it looks like WebKit never pretends to be Chrome, Edge does, and Chrome doesn't have the bug
    // that this flag is used to work around.

    function isWebKit() {
      return typeof window !== 'undefined' && window.navigator.userAgent.indexOf('AppleWebKit/') !== -1 && window.navigator.userAgent.indexOf('Chrome/') === -1;
    }
    function removeElement(el) {
      if (typeof el.remove !== 'undefined') {
        el.remove();
      } else if (typeof el.parentNode !== 'undefined' && el.parentNode !== null) {
        el.parentNode.removeChild(el);
      }
    }
    function createAbsoluteElement(el) {
      const root = document.createElement('div');
      root.style.position = 'absolute';
      root.style.left = '0px';
      root.style.top = '0px';
      const wrapper = document.createElement('div');
      root.appendChild(wrapper);
      wrapper.appendChild(el);
      document.body.appendChild(root);
      return root;
    }
    /**
     * Escape regex characters
     * http://stackoverflow.com/a/6969486
     */

    function escapeRegExpChars(value) {
      if (!value) return value; // eslint-disable-next-line

      return value.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
    }
    function toCssDimension(width) {
      return width === undefined ? null : isNaN(width) ? width : width + 'px';
    }
    function blankIfUndefined(value) {
      return typeof value !== 'undefined' && value !== null ? value : '';
    }
    function defaultIfUndefined(value, defaultValue) {
      return typeof value !== 'undefined' && value !== null ? value : defaultValue;
    }
    /**
     * Return month names according to a specified locale
     * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale
     * @param  {String} format long (ex. March), short (ex. Mar) or narrow (M)
     * @return {Array<String>} An array of month names
     */

    function getMonthNames(locale = undefined, format = 'long') {
      const dates = [];

      for (let i = 0; i < 12; i++) {
        dates.push(new Date(2000, i, 15));
      }

      const dtf = new Intl.DateTimeFormat(locale, {
        month: format // timeZone: 'UTC'

      });
      return dates.map(d => dtf.format(d));
    }
    /**
     * Return weekday names according to a specified locale
     * @param  {String} locale A bcp47 localerouter. undefined will use the user browser locale
     * @param  {Number} first day of week index
     * @param  {String} format long (ex. Thursday), short (ex. Thu) or narrow (T)
     * @return {Array<String>} An array of weekday names
     */

    function getWeekdayNames(locale = undefined, firstDayOfWeek = 0, format = 'narrow') {
      const dates = [];

      for (let i = 1, j = 0; j < 7; i++) {
        const d = new Date(2000, 0, i);
        const day = d.getDay();

        if (day === firstDayOfWeek || j > 0) {
          dates.push(d);
          j++;
        }
      }

      const dtf = new Intl.DateTimeFormat(locale, {
        weekday: format // timeZone: 'UTC'

      });
      return dates.map(d => dtf.format(d));
    }
    /**
     * Accept a regex with group names and return an object
     * ex. matchWithGroups(/((?!=<year>)\d+)\/((?!=<month>)\d+)\/((?!=<day>)\d+)/, '2000/12/25')
     * will return { year: 2000, month: 12, day: 25 }
     * @param  {String} includes injections of (?!={groupname}) for each group
     * @param  {String} the string to run regex
     * @return {Object} an object with a property for each group having the group's match as the value
     */

    function matchWithGroups(pattern, str) {
      const matches = str.match(pattern);
      return pattern // get the pattern as a string
      .toString() // suss out the groups
      .match(/<(.+?)>/g) // remove the braces
      .map(group => {
        const groupMatches = group.match(/<(.+)>/);

        if (!groupMatches || groupMatches.length <= 0) {
          return null;
        }

        return group.match(/<(.+)>/)[1];
      }) // create an object with a property for each group having the group's match as the value
      .reduce((acc, curr, index) => {
        if (matches && matches.length > index) {
          acc[curr] = matches[index + 1];
        } else {
          acc[curr] = null;
        }

        return acc;
      }, {});
    }
    function debounce(func, wait, immediate) {
      let timeout;
      return function () {
        const context = this;
        const args = arguments;

        const later = function () {
          timeout = null;
          if (!immediate) func.apply(context, args);
        };

        const callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) func.apply(context, args);
      };
    }
    function endsWith(str, suffix) {
      return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }
    /**
     * Returns the "promise" object.
     *
     * This is to handle browsers that do not have Promise support (IE 11) which are still supported
     * by Vue 2
     */

    function promiseObject() {
      // the typedef window is to that vuepress won't break when it tries to run this method
      return typeof window !== "undefined" && window.Promise ? window.Promise : Object;
    }
    const isDefined = d => d !== undefined;
    /**
     * Remove accents/diacritics in a string in JavaScript
     * https://stackoverflow.com/a/37511463
     */

    function removeDiacriticsFromString(value) {
      if (!value) return value;
      return value.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    }

    let config = {
      iconPack: 'mdi',
      useHtml5Validation: true,
      statusIcon: true
    };
    const setOptions = options => {
      config = options;
    };
    const getOptions = () => {
      return config;
    };
    let VueInstance;
    const setVueInstance = Vue => {
      VueInstance = Vue;
    };
    const Programmatic = {
      getOptions,

      setOptions(options) {
        setOptions(merge(getOptions(), options, true));
      }

    };
    const Plugin = {
      install(Vue, options = {}) {
        setVueInstance(Vue); // Options

        setOptions(merge(getOptions(), options, true));
      }

    };

    const _defaultSuffixProcessor = (input, suffix) => {
      return blankIfUndefined(input).split(' ').filter(cls => cls.length > 0).map(cls => cls + suffix).join(' ');
    };

    const _getContext = vm => {
      const computedNames = vm.$options.computed ? Object.keys(vm.$options.computed) : [];
      const computed = computedNames.filter(e => !endsWith(e, 'Classes')).reduce((o, key) => {
        o[key] = vm[key];
        return o;
      }, {});
      return {
        props: vm.$props,
        data: vm.$data,
        computed
      };
    };

    var BaseComponentMixin = {
      isOruga: true,
      props: {
        /**
         * Override classes
         */
        override: {
          type: Boolean,
          default: false
        }
      },
      methods: {
        computedClass(field, defaultValue, suffix = '') {
          const config = this.$props.override === true ? {} : getOptions();
          const override = this.$props.override || getValueByPath(config, `${this.$options.configField}.override`, false);
          const overrideClass = getValueByPath(config, `${this.$options.configField}.${field}.override`, override);
          const globalTransformClasses = getValueByPath(config, `transformClasses`, undefined);
          const localTransformClasses = getValueByPath(config, `${this.$options.configField}.transformClasses`, undefined);
          let globalClass = getValueByPath(config, `${this.$options.configField}.${field}.class`, '') || getValueByPath(config, `${this.$options.configField}.${field}`, '');
          let currentClass = getValueByPath(this.$props, field);

          if (Array.isArray(currentClass)) {
            currentClass = currentClass.join(' ');
          }

          if (defaultValue.search("{*}") !== -1) {
            defaultValue = defaultValue.replace(/\{\*\}/g, suffix);
          } else {
            defaultValue = defaultValue + suffix;
          }

          let context = null;

          if (typeof currentClass === "function") {
            context = _getContext(this);
            currentClass = currentClass(suffix, context);
          } else {
            currentClass = _defaultSuffixProcessor(currentClass, suffix);
          }

          if (typeof globalClass === "function") {
            globalClass = globalClass(suffix, context || _getContext(this));
          } else {
            globalClass = _defaultSuffixProcessor(globalClass, suffix);
          }

          let appliedClasses = (`${override && !overrideClass || !override && !overrideClass ? defaultValue : ''} ` + `${blankIfUndefined(globalClass)} ` + `${blankIfUndefined(currentClass)}`).trim().replace(/\s\s+/g, ' ');

          if (localTransformClasses) {
            appliedClasses = localTransformClasses(appliedClasses);
          }

          if (globalTransformClasses) {
            appliedClasses = globalTransformClasses(appliedClasses);
          }

          return appliedClasses;
        }

      }
    };

    const mdiIcons = {
      sizes: {
        'default': 'mdi-24px',
        'small': null,
        'medium': 'mdi-36px',
        'large': 'mdi-48px'
      },
      iconPrefix: 'mdi-'
    };

    const faIcons = () => {
      const iconComponent = getValueByPath(getOptions(), 'iconComponent');
      const faIconPrefix = iconComponent ? '' : 'fa-';
      return {
        sizes: {
          'default': null,
          'small': null,
          'medium': faIconPrefix + 'lg',
          'large': faIconPrefix + '2x'
        },
        iconPrefix: faIconPrefix,
        internalIcons: {
          'check': 'check',
          'information': 'info-circle',
          'alert': 'exclamation-triangle',
          'alert-circle': 'exclamation-circle',
          'arrow-up': 'arrow-up',
          'chevron-right': 'angle-right',
          'chevron-left': 'angle-left',
          'chevron-down': 'angle-down',
          'chevron-up': 'angle-up',
          'eye': 'eye',
          'eye-off': 'eye-slash',
          'caret-down': 'caret-down',
          'caret-up': 'caret-up',
          'close-circle': 'times-circle',
          'close': 'times',
          'loading': 'circle-notch'
        }
      };
    };

    const getIcons = () => {
      let icons = {
        mdi: mdiIcons,
        fa: faIcons(),
        fas: faIcons(),
        far: faIcons(),
        fad: faIcons(),
        fab: faIcons(),
        fal: faIcons()
      };
      const customIconPacks = getValueByPath(getOptions(), 'customIconPacks');

      if (customIconPacks) {
        icons = merge(icons, customIconPacks, true);
      }

      return icons;
    };

    //
    /**
     * Icons take an important role of any application
     * @displayName Icon
     * @example ./examples/Icon.md
     * @style _icon.scss
     */

    var script = {
      name: 'OIcon',
      mixins: [BaseComponentMixin],
      configField: 'icon',
      props: {
        /**
         * 	Color of the icon, optional
         *  @values primary, info, success, warning, danger, and any other custom color
         */
        variant: [String, Object],

        /**
         * Icon component name
         */
        component: String,

        /**
         * Icon pack to use
         * @values mdi, fa, fas and any other custom icon pack
         */
        pack: String,

        /**
         * Icon name
         */
        icon: String,

        /**
         * Icon size, optional
         * @values small, medium, large
         */
        size: String,

        /**
         * Overrides icon font size, optional
         * @values Depends on library: null (smallest), fa-lg, fa-2x, fa-3x, fa-4x, fa-5x, mdi-18px, mdi-24px, mdi-36px, mdi-48px
         */
        customSize: String,

        /**
         * Add class to icon font, optional. See here for MDI, here for FontAwesome 4 and here for FontAwesome 5 custom classes
         */
        customClass: String,

        /**
         * When true makes icon clickable
         */
        clickable: Boolean,

        /** Enable spin effect on icon */
        spin: Boolean,

        /** Rotation 0-360 */
        rotation: [Number, String],

        /** @ignore */
        both: Boolean,
        // This is used internally
        rootClass: [String, Function, Array],
        clickableClass: [String, Function, Array],
        spinClass: [String, Function, Array],
        sizeClass: [String, Function, Array],
        variantClass: [String, Function, Array]
      },
      computed: {
        rootClasses() {
          return [this.computedClass('rootClass', 'o-icon'), {
            [this.computedClass('clickableClass', 'o-icon--clickable')]: this.clickable
          }, {
            [this.computedClass('spinClass', 'o-icon--spin')]: this.spin
          }, {
            [this.computedClass('sizeClass', 'o-icon--', this.size)]: this.size
          }, {
            [this.computedClass('variantClass', 'o-icon--', this.newVariant)]: this.newVariant
          }];
        },

        rootStyle() {
          const style = {};

          if (this.rotation) {
            style['transform'] = `rotate(${this.rotation}deg)`;
          }

          return style;
        },

        iconConfig() {
          return getIcons()[this.newPack];
        },

        iconPrefix() {
          if (this.iconConfig && this.iconConfig.iconPrefix) {
            return this.iconConfig.iconPrefix;
          }

          return '';
        },

        /**
        * Internal icon name based on the pack.
        * If pack is 'fa', gets the equivalent FA icon name of the MDI,
        * internal icons are always MDI.
        */
        newIcon() {
          return `${this.iconPrefix}${this.getEquivalentIconOf(this.icon)}`;
        },

        newPack() {
          return this.pack || getValueByPath(getOptions(), 'iconPack', 'mdi');
        },

        newVariant() {
          if (!this.variant) return;
          let newVariant = '';

          if (typeof this.variant === 'string') {
            newVariant = this.variant;
          } else {
            newVariant = Object.keys(this.variant).filter(key => this.variant[key])[0];
          }

          return newVariant;
        },

        newCustomSize() {
          return this.customSize || this.customSizeByPack;
        },

        customSizeByPack() {
          if (this.iconConfig && this.iconConfig.sizes) {
            if (this.size && this.iconConfig.sizes[this.size] !== undefined) {
              return this.iconConfig.sizes[this.size];
            } else if (this.iconConfig.sizes.default) {
              return this.iconConfig.sizes.default;
            }
          }

          return null;
        },

        useIconComponent() {
          if (this.component) return this.component;
          const component = getValueByPath(getOptions(), 'iconComponent');
          if (component) return component;
          return null;
        }

      },
      methods: {
        /**
        * Equivalent icon name of the MDI.
        */
        getEquivalentIconOf(value) {
          // Only transform the class if the both prop is set to true
          if (!this.both) {
            return value;
          }

          if (this.iconConfig && this.iconConfig.internalIcons && this.iconConfig.internalIcons[value]) {
            return this.iconConfig.internalIcons[value];
          }

          return value;
        }

      }
    };

    function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
    /* server only */
    , shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
      if (typeof shadowMode !== 'boolean') {
        createInjectorSSR = createInjector;
        createInjector = shadowMode;
        shadowMode = false;
      } // Vue.extend constructor export interop.


      const options = typeof script === 'function' ? script.options : script; // render functions

      if (template && template.render) {
        options.render = template.render;
        options.staticRenderFns = template.staticRenderFns;
        options._compiled = true; // functional template

        if (isFunctionalTemplate) {
          options.functional = true;
        }
      } // scopedId


      if (scopeId) {
        options._scopeId = scopeId;
      }

      let hook;

      if (moduleIdentifier) {
        // server build
        hook = function (context) {
          // 2.3 injection
          context = context || this.$vnode && this.$vnode.ssrContext || this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
          // 2.2 with runInNewContext: true

          if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
            context = __VUE_SSR_CONTEXT__;
          } // inject component styles


          if (style) {
            style.call(this, createInjectorSSR(context));
          } // register component module identifier for async chunk inference


          if (context && context._registeredComponents) {
            context._registeredComponents.add(moduleIdentifier);
          }
        }; // used by ssr in case component is cached and beforeCreate
        // never gets called


        options._ssrRegister = hook;
      } else if (style) {
        hook = shadowMode ? function (context) {
          style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
        } : function (context) {
          style.call(this, createInjector(context));
        };
      }

      if (hook) {
        if (options.functional) {
          // register for functional component in vue file
          const originalRender = options.render;

          options.render = function renderWithStyleInjection(h, context) {
            hook.call(context);
            return originalRender(h, context);
          };
        } else {
          // inject component registration as beforeCreate hook
          const existing = options.beforeCreate;
          options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
      }

      return script;
    }

    /* script */
    const __vue_script__ = script;

    /* template */
    var __vue_render__ = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('span',{class:_vm.rootClasses,style:(_vm.rootStyle)},[(!_vm.useIconComponent)?_c('i',{class:[_vm.newPack, _vm.newIcon, _vm.newCustomSize, _vm.customClass]}):_c(_vm.useIconComponent,{tag:"component",class:[_vm.customClass],attrs:{"icon":[_vm.newPack, _vm.newIcon],"size":_vm.newCustomSize}})],1)};
    var __vue_staticRenderFns__ = [];

      /* style */
      const __vue_inject_styles__ = undefined;
      /* scoped */
      const __vue_scope_id__ = undefined;
      /* module identifier */
      const __vue_module_identifier__ = undefined;
      /* functional template */
      const __vue_is_functional_template__ = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__ = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
        __vue_inject_styles__,
        __vue_script__,
        __vue_scope_id__,
        __vue_is_functional_template__,
        __vue_module_identifier__,
        false,
        undefined,
        undefined,
        undefined
      );

    // HTML constraint validation, e.g. .form and .validity.

    const validatableFormElementTypes = typeof window === 'undefined' ? [] : [HTMLButtonElement, HTMLFieldSetElement, HTMLInputElement, HTMLObjectElement, HTMLOutputElement, HTMLSelectElement, HTMLTextAreaElement];

    function asValidatableFormElement(el) {
      if (validatableFormElementTypes.some(t => el instanceof t)) {
        return el;
      } else {
        return null;
      }
    }

    var FormElementMixin = {
      inject: {
        $field: {
          from: "$field",
          default: false
        }
      },
      props: {
        /**
         * Makes input full width when inside a grouped or addon field
         */
        expanded: Boolean,

        /**
         * Makes the element rounded
         */
        rounded: Boolean,

        /**
         * Icon name to be added
         */
        icon: String,

        /**
         * Icon pack to use
         * @values mdi, fa, fas and any other custom icon pack
         */
        iconPack: String,

        /** Native options to use in HTML5 validation */
        autocomplete: String,

        /** Same as native maxlength, plus character counter */
        maxlength: [Number, String],

        /** Enable html 5 native validation */
        useHtml5Validation: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), "useHtml5Validation", true);
          }
        },

        /** Show status icon using field and variant prop */
        statusIcon: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), "statusIcon", true);
          }
        },

        /**
         * The message which is shown when a validation error occurs
         */
        validationMessage: String
      },

      data() {
        return {
          isValid: true,
          isFocused: false,
          newIconPack: this.iconPack
        };
      },

      computed: {
        parentField() {
          return this.$field;
        },

        /**
         * Get the type prop from parent if it's a Field.
         */
        statusVariant() {
          if (!this.parentField) return;
          if (!this.parentField.newVariant) return;

          if (typeof this.parentField.newVariant === "string") {
            return this.parentField.newVariant;
          } else {
            for (const key in this.parentField.newVariant) {
              if (this.parentField.newVariant[key]) {
                return key;
              }
            }
          }
        },

        /**
         * Get the message prop from parent if it's a Field.
         */
        statusMessage() {
          if (!this.parentField) return;
          return this.parentField.newMessage || this.parentField.hasMessageSlot;
        },

        /**
        * Icon name based on the variant.
        */
        statusVariantIcon() {
          const statusVariantIcon = getValueByPath(getOptions(), "statusVariantIcon", {
            'success': 'check',
            'danger': 'alert-circle',
            'info': 'information',
            'warning': 'alert'
          });
          return statusVariantIcon[this.statusVariant] || '';
        }

      },
      methods: {
        /**
         * Focus method that work dynamically depending on the component.
         */
        focus() {
          const el = this.getElement();
          if (el === undefined) return;
          this.$nextTick(() => {
            if (el) el.focus();
          });
        },

        onBlur(event) {
          this.isFocused = false;

          if (this.parentField) {
            this.parentField.isFocused = false;
          }

          this.$emit("blur", event);
          this.checkHtml5Validity();
        },

        onFocus(event) {
          this.isFocused = true;

          if (this.parentField) {
            this.parentField.isFocused = true;
          }

          this.$emit("focus", event);
        },

        onInvalid(event) {
          this.checkHtml5Validity();
          const validatable = asValidatableFormElement(event.target);

          if (validatable && this.parentField && this.useHtml5Validation) {
            // We provide our own error message on the field, so we should suppress the browser's default tooltip.
            // We still want to focus the form's first invalid input, though.
            event.preventDefault();
            let isFirstInvalid = false;

            if (validatable.form != null) {
              const formElements = validatable.form.elements;

              for (let i = 0; i < formElements.length; ++i) {
                const element = asValidatableFormElement(formElements.item(i));

                if (element && element.willValidate && !element.validity.valid) {
                  isFirstInvalid = validatable === element;
                  break;
                }
              }
            }

            if (isFirstInvalid) {
              const fieldElement = this.parentField.$el;
              const invalidHandler = getValueByPath(getOptions(), 'reportInvalidInput');

              if (invalidHandler instanceof Function) {
                invalidHandler(validatable, fieldElement);
              } else {
                // We'll scroll to put the whole field in view, not just the element that triggered the event,
                // which should mean that the message will be visible onscreen.
                // scrollIntoViewIfNeeded() is a non-standard method (but a very common extension).
                // If we can't use it, we'll just fall back to focusing the field.
                const canScrollToField = fieldElement ? fieldElement.scrollIntoViewIfNeeded != undefined : false;
                validatable.focus({
                  preventScroll: canScrollToField
                });

                if (canScrollToField) {
                  fieldElement.scrollIntoViewIfNeeded();
                }
              }
            }
          }

          this.$emit("invalid", event);
        },

        getElement() {
          let el = this.$refs[this.$elementRef];

          while (el && el.$elementRef) {
            el = el.$refs[el.$elementRef];
          }

          return el;
        },

        setInvalid() {
          const variant = "danger";
          const message = this.validationMessage || this.getElement().validationMessage;
          this.setValidity(variant, message);
        },

        setValidity(variant, message) {
          this.$nextTick(() => {
            if (this.parentField) {
              // Set type only if not defined
              if (!this.parentField.variant) {
                this.parentField.newVariant = variant;
              } // Set message only if not defined


              if (!this.parentField.message) {
                this.parentField.newMessage = message;
              }
            }
          });
        },

        /**
         * Check HTML5 validation, set isValid property.
         * If validation fail, send 'danger' type,
         * and error message to parent if it's a Field.
         */
        checkHtml5Validity() {
          if (!this.useHtml5Validation) return;
          const el = this.getElement();
          if (el === undefined) return;

          if (!el.validity.valid) {
            this.setInvalid();
            this.isValid = false;
          } else {
            this.setValidity(null, null);
            this.isValid = true;
          }

          return this.isValid;
        },

        syncFilled(value) {
          if (this.parentField) {
            this.parentField.isFilled = !!value;
          }
        }

      }
    };

    //
    /**
     * Get user Input. Use with Field to access all functionalities
     * @displayName Input
     * @example ./examples/Input.md
     * @style _input.scss
     */

    var script$1 = {
      name: 'OInput',
      components: {
        [__vue_component__.name]: __vue_component__
      },
      mixins: [BaseComponentMixin, FormElementMixin],
      configField: 'input',
      inheritAttrs: false,
      props: {
        /** @model */
        value: [Number, String],

        /**
         * Input type, like native
         * @values Any native input type, and textarea
         */
        type: {
          type: String,
          default: 'text'
        },

        /**
         * Vertical size of input, optional
         * @values small, medium, large
         */
        size: String,

        /**
        * Color of the control, optional
        * @values primary, info, success, warning, danger, and any other custom color
        */
        variant: String,

        /**
         * 	Adds the reveal password functionality
         */
        passwordReveal: Boolean,

        /**
         * Makes the icon clickable
         */
        iconClickable: Boolean,

        /**
         * Show character counter when maxlength prop is passed
         */
        hasCounter: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'input.counter', false);
          }
        },

        /**
         * Automatically adjust height in textarea
         */
        autosize: {
          type: Boolean,
          default: false
        },

        /**
         * 	Icon name to be added on the right side
         */
        iconRight: String,

        /**
         * Make the icon right clickable
         */
        iconRightClickable: Boolean,

        /** Variant of right icon */
        iconRightVariant: String,

        /** Add a button/icon to clear the inputed text */
        clearable: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'input.clearable', false);
          }
        },

        /**
         * Icon name to be added on the clear button
         */
        clearIcon: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'input.clearIcon', 'close-circle');
          }
        },
        rootClass: [String, Function, Array],
        expandedClass: [String, Function, Array],
        iconLeftSpaceClass: [String, Function, Array],
        iconRightSpaceClass: [String, Function, Array],
        inputClass: [String, Function, Array],
        roundedClass: [String, Function, Array],
        iconLeftClass: [String, Function, Array],
        iconRightClass: [String, Function, Array],
        counterClass: [String, Function, Array],
        sizeClass: [String, Function, Array],
        variantClass: [String, Function, Array]
      },

      data() {
        return {
          newValue: this.value,
          newType: this.type,
          newAutocomplete: this.autocomplete || getValueByPath(getOptions(), 'input.autocompletete', 'off'),
          isPasswordVisible: false,
          height: 'auto'
        };
      },

      computed: {
        rootClasses() {
          return [this.computedClass('rootClass', 'o-ctrl-input'), {
            [this.computedClass('expandedClass', 'o-ctrl-input--expanded')]: this.expanded
          }];
        },

        inputClasses() {
          return [this.computedClass('inputClass', 'o-input'), {
            [this.computedClass('roundedClass', 'o-input--rounded')]: this.rounded
          }, {
            [this.computedClass('sizeClass', 'o-input--', this.size)]: this.size
          }, {
            [this.computedClass('variantClass', 'o-input--', this.statusVariant || this.variant)]: this.statusVariant || this.variant
          }, {
            [this.computedClass('textareaClass', 'o-input__textarea')]: this.type === 'textarea'
          }, {
            [this.computedClass('iconLeftSpaceClass', 'o-input-iconspace-left')]: this.icon
          }, {
            [this.computedClass('iconRightSpaceClass', 'o-input-iconspace-right')]: this.hasIconRight
          }];
        },

        iconLeftClasses() {
          return [this.computedClass('iconLeftClass', 'o-input__icon-left')];
        },

        iconRightClasses() {
          return [this.computedClass('iconRightClass', 'o-input__icon-right')];
        },

        counterClasses() {
          return [this.computedClass('counterClass', 'o-input__counter')];
        },

        computedValue: {
          get() {
            return this.newValue;
          },

          set(value) {
            this.newValue = value;
            this.$emit('input', this.newValue);
            this.syncFilled(this.newValue);
            !this.isValid && this.checkHtml5Validity();
          }

        },

        hasIconRight() {
          return this.passwordReveal || this.statusIcon && this.statusVariantIcon || this.clearable && this.newValue && this.clearIcon || this.iconRight;
        },

        rightIcon() {
          if (this.passwordReveal) {
            return this.passwordVisibleIcon;
          } else if (this.clearable && this.newValue && this.clearIcon) {
            return this.clearIcon;
          } else if (this.iconRight) {
            return this.iconRight;
          }

          return this.statusVariantIcon;
        },

        rightIconVariant() {
          if (this.passwordReveal || this.iconRight) {
            return this.iconRightVariant || this.variant || null;
          }

          return this.statusVariant;
        },

        /**
        * Check if have any message prop from parent if it's a Field.
        */
        hasMessage() {
          return !!this.statusMessage;
        },

        /**
        * Current password-reveal icon name.
        */
        passwordVisibleIcon() {
          return !this.isPasswordVisible ? 'eye' : 'eye-off';
        },

        /**
        * Get value length
        */
        valueLength() {
          if (typeof this.computedValue === 'string') {
            return this.computedValue.length;
          } else if (typeof this.computedValue === 'number') {
            return this.computedValue.toString().length;
          }

          return 0;
        },

        /**
        * Computed inline styles for autoresize
        */
        computedStyles() {
          if (!this.autosize) return {};
          return {
            resize: 'none',
            height: this.height,
            overflow: 'hidden'
          };
        },

        $elementRef() {
          return this.type === 'textarea' ? 'textarea' : 'input';
        }

      },
      watch: {
        /**
        * When v-model is changed:
        *   1. Set internal value.
        */
        value: {
          immediate: true,

          handler(value) {
            this.newValue = value;
            this.syncFilled(this.newValue);

            if (this.autosize) {
              this.resize();
            }
          }

        },

        type(type) {
          this.newType = type;
        }

      },
      methods: {
        /**
        * Toggle the visibility of a password-reveal input
        * by changing the type and focus the input right away.
        */
        togglePasswordVisibility() {
          this.isPasswordVisible = !this.isPasswordVisible;
          this.newType = this.isPasswordVisible ? 'text' : 'password';
          this.$nextTick(() => {
            this.focus();
          });
        },

        iconClick(emit, event) {
          this.$emit(emit, event);
          this.$nextTick(() => {
            this.focus();
          });
        },

        rightIconClick(event) {
          if (this.passwordReveal) {
            this.togglePasswordVisibility();
          } else if (this.clearable) {
            this.computedValue = '';
          } else if (this.iconRightClickable) {
            this.iconClick('icon-right-click', event);
          }
        },

        resize() {
          this.height = 'auto';
          this.$nextTick(() => {
            const scrollHeight = this.$refs.textarea.scrollHeight;
            this.height = scrollHeight + 'px';
          });
        }

      }
    };

    /* script */
    const __vue_script__$1 = script$1;

    /* template */
    var __vue_render__$1 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.rootClasses},[(_vm.type !== 'textarea')?_c('input',_vm._b({ref:"input",class:_vm.inputClasses,attrs:{"type":_vm.newType,"autocomplete":_vm.newAutocomplete,"maxlength":_vm.maxlength},domProps:{"value":_vm.computedValue},on:{"input":function($event){_vm.computedValue = $event.target.value;},"blur":_vm.onBlur,"focus":_vm.onFocus,"invalid":_vm.onInvalid}},'input',_vm.$attrs,false)):_c('textarea',_vm._b({ref:"textarea",class:_vm.inputClasses,style:(_vm.computedStyles),attrs:{"maxlength":_vm.maxlength},domProps:{"value":_vm.computedValue},on:{"input":function($event){_vm.computedValue = $event.target.value;},"blur":_vm.onBlur,"focus":_vm.onFocus,"invalid":_vm.onInvalid}},'textarea',_vm.$attrs,false)),(_vm.icon)?_c('o-icon',{class:_vm.iconLeftClasses,attrs:{"clickable":_vm.iconClickable,"icon":_vm.icon,"pack":_vm.iconPack,"size":_vm.size},nativeOn:{"click":function($event){return _vm.iconClick('icon-click', $event)}}}):_vm._e(),(_vm.hasIconRight)?_c('o-icon',{class:_vm.iconRightClasses,attrs:{"clickable":_vm.passwordReveal || _vm.clearable || _vm.iconRightClickable,"icon":_vm.rightIcon,"pack":_vm.iconPack,"size":_vm.size,"variant":_vm.rightIconVariant,"both":""},nativeOn:{"click":function($event){return _vm.rightIconClick($event)}}}):_vm._e(),(_vm.maxlength && _vm.hasCounter && _vm.isFocused && _vm.type !== 'number')?_c('small',{class:_vm.counterClasses},[_vm._v(" "+_vm._s(_vm.valueLength)+" / "+_vm._s(_vm.maxlength)+" ")]):_vm._e()],1)};
    var __vue_staticRenderFns__$1 = [];

      /* style */
      const __vue_inject_styles__$1 = undefined;
      /* scoped */
      const __vue_scope_id__$1 = undefined;
      /* module identifier */
      const __vue_module_identifier__$1 = undefined;
      /* functional template */
      const __vue_is_functional_template__$1 = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$1 = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
        __vue_inject_styles__$1,
        __vue_script__$1,
        __vue_scope_id__$1,
        __vue_is_functional_template__$1,
        __vue_module_identifier__$1,
        false,
        undefined,
        undefined,
        undefined
      );

    //
    /**
     * Extended input that provide suggestions while the user types
     * @displayName Autocomplete
     * @example ./examples/Autocomplete.md
     * @style _autocomplete.scss
     */

    var script$2 = {
      name: 'OAutocomplete',
      configField: 'autocomplete',
      components: {
        [__vue_component__$1.name]: __vue_component__$1
      },
      mixins: [BaseComponentMixin, FormElementMixin],
      inheritAttrs: false,
      props: {
        /** @model */
        value: [Number, String],

        /** Options / suggestions */
        data: {
          type: Array,
          default: () => []
        },

        /**
         * Vertical size of input, optional
         * @values small, medium, large
         */
        size: String,

        /** Property of the object (if data is array of objects) to use as display text, and to keep track of selected option */
        field: {
          type: String,
          default: 'value'
        },

        /** The first option will always be pre-selected (easier to just hit enter or tab) */
        keepFirst: Boolean,

        /** Clear input text on select */
        clearOnSelect: Boolean,

        /** Open dropdown list on focus */
        openOnFocus: Boolean,

        /** Function to format an option to a string for display in the input as alternative to field prop) */
        customFormatter: Function,

        /** Makes the component check if list reached scroll end and emit infinite-scroll event. */
        checkInfiniteScroll: Boolean,

        /** Keep open dropdown list after select */
        keepOpen: Boolean,

        /** Add a button/icon to clear the inputed text */
        clearable: Boolean,

        /**
         * Icon name to be added on the clear button
         */
        clearIcon: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'autocomplete.clearIcon', 'close-circle');
          }
        },

        /** Max height of dropdown content */
        maxHeight: [String, Number],

        /**
         * Position of dropdown
         * @values auto, top, bottom
         */
        menuPosition: {
          type: String,
          default: 'auto'
        },

        /** Transition name to apply on dropdown list */
        animation: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'autocomplete.animation', 'fade');
          }
        },

        /** Property of the object (if <code>data</code> is array of objects) to use as display text of group */
        groupField: String,

        /** Property of the object (if <code>data</code> is array of objects) to use as key to get items array of each group, optional */
        groupOptions: String,

        /** Number of milliseconds to delay before to emit typing event */
        debounceTyping: Number,

        /** Icon name to be added on the right side */
        iconRight: String,

        /** Clickable icon right if exists */
        iconRightClickable: Boolean,

        /** Append autocomplete content to body */
        appendToBody: Boolean,

        /** Array of keys (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values) which will add a tag when typing (default tab and enter) */
        confirmKeys: {
          type: Array,
          default: () => ['Tab', 'Enter']
        },

        /** Input type */
        type: {
          type: String,
          default: 'text'
        },

        /**
         * Menu tag name
         */
        menuTag: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'autocomplete.menuTag', 'div');
          }
        },

        /**
         * Menu item tag name
         */
        itemTag: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'autocomplete.itemTag', 'div');
          }
        },

        /** Trigger the select event for the first pre-selected option when clicking outside and <code>keep-first</code> is enabled */
        selectOnClickOutside: Boolean,

        /** Allows the header in the autocomplete to be selectable */
        selectableHeader: Boolean,

        /** Allows the footer in the autocomplete to be selectable */
        selectableFooter: Boolean,
        rootClass: [String, Function, Array],
        menuClass: [String, Function, Array],
        expandedClass: [String, Function, Array],
        menuPositionClass: [String, Function, Array],
        itemClass: [String, Function, Array],
        itemHoverClass: [String, Function, Array],
        itemGroupTitleClass: [String, Function, Array],
        itemEmptyClass: [String, Function, Array],
        itemHeaderClass: [String, Function, Array],
        itemFooterClass: [String, Function, Array],
        inputClasses: {
          type: Object,
          default: () => {
            return getValueByPath(getOptions(), 'autocomplete.inputClasses', {});
          }
        }
      },

      data() {
        return {
          selected: null,
          hovered: null,
          headerHovered: null,
          footerHovered: null,
          isActive: false,
          newValue: this.value,
          ariaAutocomplete: this.keepFirst ? 'both' : 'list',
          newAutocomplete: this.autocomplete || 'off',
          isListInViewportVertically: true,
          hasFocus: false,
          width: undefined,
          bodyEl: undefined // Used to append to body

        };
      },

      computed: {
        rootClasses() {
          return [this.computedClass('rootClass', 'o-acp'), {
            [this.computedClass('expandedClass', 'o-acp--expanded')]: this.expanded
          }];
        },

        menuClasses() {
          return [this.computedClass('menuClass', 'o-acp__menu'), {
            [this.computedClass('menuPositionClass', 'o-acp__menu--', this.newDropdownPosition)]: !this.appendToBody
          }];
        },

        itemClasses() {
          return [this.computedClass('itemClass', 'o-acp__item')];
        },

        itemEmptyClasses() {
          return [...this.itemClasses, this.computedClass('itemEmptyClass', 'o-acp__item--empty')];
        },

        itemGroupClasses() {
          return [...this.itemClasses, this.computedClass('itemGroupTitleClass', 'o-acp__item-group-title')];
        },

        itemHeaderClasses() {
          return [...this.itemClasses, this.computedClass('itemHeaderClass', 'o-acp__item-header'), {
            [this.computedClass('itemHoverClass', 'o-acp__item--hover')]: this.headerHovered
          }];
        },

        itemFooterClasses() {
          return [...this.itemClasses, this.computedClass('itemFooterClass', 'o-acp__item-footer'), {
            [this.computedClass('itemHoverClass', 'o-acp__item--hover')]: this.footerHovered
          }];
        },

        inputBind() {
          return { ...this.$attrs,
            ...this.inputClasses
          };
        },

        computedData() {
          if (this.groupField) {
            if (this.groupOptions) {
              const newData = [];
              this.data.forEach(option => {
                const group = getValueByPath(option, this.groupField);
                const items = getValueByPath(option, this.groupOptions);
                newData.push({
                  group,
                  items
                });
              });
              return newData;
            } else {
              const tmp = {};
              this.data.forEach(option => {
                const group = getValueByPath(option, this.groupField);
                if (!tmp[group]) tmp[group] = [];
                tmp[group].push(option);
              });
              const newData = [];
              Object.keys(this.data).forEach(group => {
                newData.push({
                  group,
                  items: this.data[group]
                });
              });
              return newData;
            }
          }

          return [{
            items: this.data
          }];
        },

        isEmpty() {
          if (!this.computedData) return true;
          return !this.computedData.some(element => element.items && element.items.length);
        },

        /**
         * White-listed items to not close when clicked.
         * Add input, dropdown and all children.
         */
        whiteList() {
          const whiteList = [];
          whiteList.push(this.$refs.input.$el.querySelector('input'));
          whiteList.push(this.$refs.dropdown); // Add all children from dropdown

          if (this.$refs.dropdown !== undefined) {
            const children = this.$refs.dropdown.querySelectorAll('*');

            for (const child of children) {
              whiteList.push(child);
            }
          }

          return whiteList;
        },

        newDropdownPosition() {
          if (this.menuPosition === 'top' || this.menuPosition === 'auto' && !this.isListInViewportVertically) {
            return 'top';
          }

          return 'bottom';
        },

        newIconRight() {
          if (this.clearable && this.newValue && this.clearIcon) {
            return this.clearIcon;
          }

          return this.iconRight;
        },

        newIconRightClickable() {
          if (this.clearable) {
            return true;
          }

          return this.iconRightClickable;
        },

        menuStyle() {
          return {
            maxHeight: toCssDimension(this.maxHeight),
            width: toCssDimension(this.width)
          };
        },

        $elementRef() {
          return 'input';
        }

      },
      watch: {
        /**
         * When v-model is changed:
         *   1. Update internal value.
         *   2. If it's invalid, validate again.
         */
        value(value) {
          this.newValue = value;
        },

        /**
         * When dropdown is toggled, check the visibility to know when
         * to open upwards.
         */
        isActive(active) {
          if (this.menuPosition === 'auto') {
            if (active) {
              this.calcDropdownInViewportVertical();
            } else {
              // Timeout to wait for the animation to finish before recalculating
              setTimeout(() => {
                this.calcDropdownInViewportVertical();
              }, 100);
            }
          }
        },

        /**
         * When updating input's value
         *   1. Emit changes
         *   2. If value isn't the same as selected, set null
         *   3. Close dropdown if value is clear or else open it
         */
        newValue(value) {
          this.$emit('input', value); // Check if selected is invalid

          const currentValue = this.getValue(this.selected);

          if (currentValue && currentValue !== value) {
            this.setSelected(null, false);
          } // Close dropdown if input is clear or else open it


          if (this.hasFocus && (!this.openOnFocus || value)) {
            this.isActive = !!value;
          }
        },

        /**
         * Select first option if "keep-first
         */
        data() {
          // Keep first option always pre-selected
          if (this.keepFirst) {
            this.$nextTick(() => {
              if (this.isActive) {
                this.selectFirstOption(this.computedData);
              } else {
                this.setHovered(null);
              }
            });
          } else {
            if (this.hovered) {
              // reset hovered if list doesn't contain it
              const hoveredValue = this.getValue(this.hovered);
              const data = this.computedData.map(d => d.items).reduce((a, b) => [...a, ...b], []);

              if (!data.some(d => this.getValue(d) === hoveredValue)) {
                this.setHovered(null);
              }
            }
          }
        },

        debounceTyping: {
          handler(value) {
            this.debouncedEmitTyping = debounce(this.emitTyping, value);
          },

          immediate: true
        }
      },
      methods: {
        itemOptionClasses(option) {
          return [...this.itemClasses, {
            [this.computedClass('itemHoverClass', 'o-acp__item--hover')]: option === this.hovered
          }];
        },

        /**
         * Set which option is currently hovered.
         */
        setHovered(option) {
          if (option === undefined) return;
          this.hovered = option;
        },

        /**
         * Set which option is currently selected, update v-model,
         * update input value and close dropdown.
         */
        setSelected(option, closeDropdown = true, event = undefined) {
          if (option === undefined) return;
          this.selected = option;
          /**
           * @property {Object} selected selected option
           * @property {Event} event native event
           */

          this.$emit('select', this.selected, event);

          if (this.selected !== null) {
            if (this.clearOnSelect) {
              const input = this.$refs.input;
              input.newValue = '';
              input.$refs.input.value = '';
            } else {
              this.newValue = this.getValue(this.selected);
            }

            this.setHovered(null);
          }

          closeDropdown && this.$nextTick(() => {
            this.isActive = false;
          });
          this.checkValidity();
        },

        /**
         * Select first option
         */
        selectFirstOption(computedData) {
          this.$nextTick(() => {
            const nonEmptyElements = computedData.filter(element => element.items && element.items.length);

            if (nonEmptyElements.length) {
              const option = nonEmptyElements[0].items[0];
              this.setHovered(option);
            } else {
              this.setHovered(null);
            }
          });
        },

        /**
         * Key listener.
         * Select the hovered option.
         */
        keydown(event) {
          const {
            key
          } = event; // cannot destructure preventDefault (https://stackoverflow.com/a/49616808/2774496)
          // prevent emit submit event

          if (key === 'Enter') event.preventDefault(); // Close dropdown on Tab & no hovered

          if (key === 'Escape' || key === 'Tab') {
            this.isActive = false;
          }

          if (this.confirmKeys.indexOf(key) >= 0) {
            // If adding by comma, don't add the comma to the input
            if (key === ',') event.preventDefault(); // Close dropdown on select by Tab

            const closeDropdown = !this.keepOpen || key === 'Tab';

            if (this.hovered === null) {
              // header and footer uses headerHovered && footerHovered. If header or footer
              // was selected then fire event otherwise just return so a value isn't selected
              this.checkIfHeaderOrFooterSelected(event, null, closeDropdown);
              return;
            }

            this.setSelected(this.hovered, closeDropdown, event);
          }
        },

        selectHeaderOrFoterByClick(event, origin) {
          this.checkIfHeaderOrFooterSelected(event, {
            origin: origin
          });
        },

        /**
         * Check if header or footer was selected.
         */
        checkIfHeaderOrFooterSelected(event, triggerClick, closeDropdown = true) {
          if (this.selectableHeader && (this.headerHovered || triggerClick && triggerClick.origin === 'header')) {
            this.$emit('select-header', event);
            this.headerHovered = false;
            if (triggerClick) this.setHovered(null);
            if (closeDropdown) this.isActive = false;
          }

          if (this.selectableFooter && (this.footerHovered || triggerClick && triggerClick.origin === 'footer')) {
            this.$emit('select-footer', event);
            this.footerHovered = false;
            if (triggerClick) this.setHovered(null);
            if (closeDropdown) this.isActive = false;
          }
        },

        /**
         * Close dropdown if clicked outside.
         */
        clickedOutside(event) {
          if (!this.hasFocus && this.whiteList.indexOf(event.target) < 0) {
            if (this.keepFirst && this.hovered && this.selectOnClickOutside) {
              this.setSelected(this.hovered, true);
            } else {
              this.isActive = false;
            }
          }
        },

        /**
         * Return display text for the input.
         * If object, get value from path, or else just the value.
         */
        getValue(option) {
          if (option === null) return;

          if (typeof this.customFormatter !== 'undefined') {
            return this.customFormatter(option);
          }

          return typeof option === 'object' ? getValueByPath(option, this.field) : option;
        },

        /**
         * Check if the scroll list inside the dropdown
         * reached it's end.
         */
        checkIfReachedTheEndOfScroll() {
          const list = this.$refs.dropdown;
          const footerHeight = this.$slots.footer ? this.$refs.footer.clientHeight : 0;

          if (list.clientHeight !== list.scrollHeight && list.scrollTop + list.clientHeight + footerHeight >= list.scrollHeight) {
            this.$emit('infinite-scroll');
          }
        },

        /**
         * Calculate if the dropdown is vertically visible when activated,
         * otherwise it is openened upwards.
         */
        calcDropdownInViewportVertical() {
          this.$nextTick(() => {
            /**
            * this.$refs.dropdown may be undefined
            * when Autocomplete is conditional rendered
            */
            if (this.$refs.dropdown === undefined) return;
            const rect = this.$refs.dropdown.getBoundingClientRect();
            this.isListInViewportVertically = rect.top >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight);

            if (this.appendToBody) {
              this.updateAppendToBody();
            }
          });
        },

        /**
         * Arrows keys listener.
         * If dropdown is active, set hovered option, or else just open.
         */
        keyArrows(direction) {
          const sum = direction === 'down' ? 1 : -1;

          if (this.isActive) {
            const data = this.computedData.map(d => d.items).reduce((a, b) => [...a, ...b], []);

            if (this.$slots.header && this.selectableHeader) {
              data.unshift(undefined);
            }

            if (this.$slots.footer && this.selectableFooter) {
              data.push(undefined);
            }

            let index;

            if (this.headerHovered) {
              index = 0 + sum;
            } else if (this.footerHovered) {
              index = data.length - 1 + sum;
            } else {
              index = data.indexOf(this.hovered) + sum;
            }

            index = index > data.length - 1 ? data.length - 1 : index;
            index = index < 0 ? 0 : index;
            this.footerHovered = false;
            this.headerHovered = false;
            this.setHovered(data[index] !== undefined ? data[index] : null);

            if (this.$slots.footer && this.selectableFooter && index === data.length - 1) {
              this.footerHovered = true;
            }

            if (this.$slots.header && this.selectableHeader && index === 0) {
              this.headerHovered = true;
            }

            const list = this.$refs.dropdown;
            let items = this.$refs.items || [];

            if (this.$slots.header && this.selectableHeader) {
              items = [this.$refs.header, ...items];
            }

            if (this.$slots.footer && this.selectableFooter) {
              items = [...items, this.$refs.footer];
            }

            const element = items[index];
            if (!element) return;
            const visMin = list.scrollTop;
            const visMax = list.scrollTop + list.clientHeight - element.clientHeight;

            if (element.offsetTop < visMin) {
              list.scrollTop = element.offsetTop;
            } else if (element.offsetTop >= visMax) {
              list.scrollTop = element.offsetTop - list.clientHeight + element.clientHeight;
            }
          } else {
            this.isActive = true;
          }
        },

        /**
         * Focus listener.
         * If value is the same as selected, select all text.
         */
        focused(event) {
          if (this.getValue(this.selected) === this.newValue) {
            this.$el.querySelector('input').select();
          }

          if (this.openOnFocus) {
            this.isActive = true;

            if (this.keepFirst) {
              // If open on focus, update the hovered
              this.selectFirstOption(this.computedData);
            }
          }

          this.hasFocus = true;
          this.$emit('focus', event);
        },

        /**
        * Blur listener.
        */
        onBlur(event) {
          this.hasFocus = false;
          this.$emit('blur', event);
        },

        onInput() {
          const currentValue = this.getValue(this.selected);
          if (currentValue && currentValue === this.newValue) return;

          if (this.debounceTyping) {
            this.debouncedEmitTyping();
          } else {
            this.emitTyping();
          }
        },

        emitTyping() {
          this.$emit('typing', this.newValue);
          this.checkValidity();
        },

        rightIconClick(event) {
          if (this.clearable) {
            this.newValue = '';
            this.setSelected(null, false);

            if (this.openOnFocus) {
              this.$refs.input.$el.focus();
            }
          } else {
            this.$emit('icon-right-click', event);
          }
        },

        checkValidity() {
          if (this.useHtml5Validation) {
            this.$nextTick(() => {
              this.checkHtml5Validity();
            });
          }
        },

        updateAppendToBody() {
          const dropdownMenu = this.$refs.dropdown;
          const trigger = this.$refs.input.$el;

          if (dropdownMenu && trigger) {
            // update wrapper dropdown
            const root = this.$data.bodyEl;
            root.classList.forEach(item => root.classList.remove(...item.split(' ')));
            this.rootClasses.forEach(item => {
              if (item) {
                if (typeof item === 'object') {
                  Object.keys(item).filter(key => key && item[key]).forEach(key => root.classList.add(key));
                } else {
                  root.classList.add(...item.split(' '));
                }
              }
            });
            const rect = trigger.getBoundingClientRect();
            let top = rect.top + window.scrollY;
            const left = rect.left + window.scrollX;

            if (this.newDropdownPosition !== 'top') {
              top += trigger.clientHeight;
            } else {
              top -= dropdownMenu.clientHeight;
            }

            dropdownMenu.style.position = 'absolute';
            dropdownMenu.style.top = `${top}px`;
            dropdownMenu.style.left = `${left}px`;
            dropdownMenu.style.width = `${trigger.clientWidth}px`;
            dropdownMenu.style.maxWidth = `${trigger.clientWidth}px`;
            dropdownMenu.style.zIndex = '9999';
          }
        }

      },

      created() {
        if (typeof window !== 'undefined') {
          document.addEventListener('click', this.clickedOutside);
          if (this.menuPosition === 'auto') window.addEventListener('resize', this.calcDropdownInViewportVertical);
        }
      },

      mounted() {
        const list = this.$refs.dropdown;

        if (this.checkInfiniteScroll && list) {
          list.addEventListener('scroll', this.checkIfReachedTheEndOfScroll);
        }

        if (this.appendToBody) {
          this.$data.bodyEl = createAbsoluteElement(list);
          this.updateAppendToBody();
        }
      },

      beforeUpdate() {
        this.width = this.$refs.input ? this.$refs.input.$el.clientWidth : undefined;
      },

      beforeDestroy() {
        if (typeof window !== 'undefined') {
          document.removeEventListener('click', this.clickedOutside);
          if (this.menuPosition === 'auto') window.removeEventListener('resize', this.calcDropdownInViewportVertical);
        }

        if (this.checkInfiniteScroll && this.$refs.dropdown) {
          const list = this.$refs.dropdown;
          list.removeEventListener('scroll', this.checkIfReachedTheEndOfScroll);
        }

        if (this.appendToBody) {
          removeElement(this.$data.bodyEl);
        }
      }

    };

    /* script */
    const __vue_script__$2 = script$2;

    /* template */
    var __vue_render__$2 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.rootClasses},[_c('o-input',_vm._b({ref:"input",attrs:{"type":_vm.type,"size":_vm.size,"rounded":_vm.rounded,"icon":_vm.icon,"icon-right":_vm.newIconRight,"icon-right-clickable":_vm.newIconRightClickable,"icon-pack":_vm.iconPack,"maxlength":_vm.maxlength,"autocomplete":_vm.newAutocomplete,"use-html5-validation":false,"aria-autocomplete":_vm.ariaAutocomplete,"expanded":_vm.expanded},on:{"input":_vm.onInput,"focus":_vm.focused,"blur":_vm.onBlur,"invalid":_vm.onInvalid,"icon-right-click":_vm.rightIconClick,"icon-click":function (event) { return _vm.$emit('icon-click', event); }},nativeOn:{"keydown":[function($event){return _vm.keydown($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"up",38,$event.key,["Up","ArrowUp"])){ return null; }$event.preventDefault();return _vm.keyArrows('up')},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"down",40,$event.key,["Down","ArrowDown"])){ return null; }$event.preventDefault();return _vm.keyArrows('down')}]},model:{value:(_vm.newValue),callback:function ($$v) {_vm.newValue=$$v;},expression:"newValue"}},'o-input',_vm.inputBind,false)),_c('transition',{attrs:{"name":_vm.animation}},[_c(_vm.menuTag,{directives:[{name:"show",rawName:"v-show",value:(_vm.isActive && (!_vm.isEmpty || _vm.$slots.empty || _vm.$slots.header || _vm.$slots.footer)),expression:"isActive && (!isEmpty || $slots.empty || $slots.header || $slots.footer)"}],ref:"dropdown",tag:"div",class:_vm.menuClasses,style:(_vm.menuStyle)},[(_vm.$slots.header)?_c(_vm.itemTag,{ref:"header",tag:"div",class:_vm.itemHeaderClasses,attrs:{"role":"button","tabindex":"0"},on:{"click":function($event){return _vm.selectHeaderOrFoterByClick($event, 'header')}}},[_vm._t("header")],2):_vm._e(),_vm._l((_vm.computedData),function(element,groupindex){return [(element.group)?_c(_vm.itemTag,{key:groupindex + 'group',tag:"div",class:_vm.itemGroupClasses},[(_vm.$scopedSlots.group)?_vm._t("group",null,{"group":element.group,"index":groupindex}):_c('span',[_vm._v(" "+_vm._s(element.group)+" ")])],2):_vm._e(),_vm._l((element.items),function(option,index){return _c(_vm.itemTag,{key:groupindex + ':' + index,ref:"items",refInFor:true,tag:"div",class:_vm.itemOptionClasses(option),on:{"click":function($event){$event.stopPropagation();return _vm.setSelected(option, !_vm.keepOpen, $event)}}},[(_vm.$scopedSlots.default)?_vm._t("default",null,{"option":option,"index":index}):_c('span',[_vm._v(" "+_vm._s(_vm.getValue(option))+" ")])],2)})]}),(_vm.isEmpty && _vm.$slots.empty)?_c(_vm.itemTag,{tag:"div",class:_vm.itemEmptyClasses},[_vm._t("empty")],2):_vm._e(),(_vm.$slots.footer)?_c(_vm.itemTag,{ref:"footer",tag:"div",class:_vm.itemFooterClasses,attrs:{"role":"button","tabindex":"0"},on:{"click":function($event){return _vm.selectHeaderOrFoterByClick($event, 'footer')}}},[_vm._t("footer")],2):_vm._e()],2)],1)],1)};
    var __vue_staticRenderFns__$2 = [];

      /* style */
      const __vue_inject_styles__$2 = undefined;
      /* scoped */
      const __vue_scope_id__$2 = undefined;
      /* module identifier */
      const __vue_module_identifier__$2 = undefined;
      /* functional template */
      const __vue_is_functional_template__$2 = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$2 = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },
        __vue_inject_styles__$2,
        __vue_script__$2,
        __vue_scope_id__$2,
        __vue_is_functional_template__$2,
        __vue_module_identifier__$2,
        false,
        undefined,
        undefined,
        undefined
      );

    const use = plugin => {
      if (typeof window !== 'undefined' && window.Vue) {
        window.Vue.use(plugin);
      }
    };
    const registerPlugin = (vm, plugin) => {
      vm.use(plugin);
    };
    const registerComponent = (vm, component) => {
      vm.component(component.name, component);
    };
    const registerComponentProgrammatic = (vm, property, component) => {
      if (!vm.prototype.$oruga) vm.prototype.$oruga = {};
      vm.prototype.$oruga[property] = component;
    };

    const Plugin$1 = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$2);
      }

    };
    use(Plugin$1);

    //
    /**
     * The classic button, in different colors, sizes, and states
     * @displayName Button
     * @example ./examples/Button.md
     * @style _button.scss
     */

    var script$3 = {
      name: 'OButton',
      components: {
        [__vue_component__.name]: __vue_component__
      },
      configField: 'button',
      mixins: [BaseComponentMixin],
      inheritAttrs: false,
      props: {
        /**
        * Color of the control, optional
        * @values primary, info, success, warning, danger, and any other custom color
        */
        variant: String,

        /**
         * Size of button, optional
         * @values small, medium, large
         */
        size: String,

        /**
         * Button label, optional when default slot
         */
        label: String,

        /**
         * Icon pack to use
         * @values mdi, fa, fas and any other custom icon pack
         */
        iconPack: String,

        /**
         * Icon name to show on the left
         */
        iconLeft: String,

        /**
         * Icon name to show on the right
         */
        iconRight: String,

        /**
         * Rounded style
         */
        rounded: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'button.rounded', false);
          }
        },

        /**
         * Loading style
         */
        loading: Boolean,

        /**
         * Outlined style
         */
        outlined: Boolean,

        /**
         * Button will be expanded (full-width)
         */
        expanded: Boolean,
        inverted: Boolean,

        /**
         * Button type, like native
         */
        nativeType: {
          type: String,
          default: 'button',
          validator: value => {
            return ['button', 'submit', 'reset'].indexOf(value) >= 0;
          }
        },

        /**
         * Button tag name
         * @values button, a, input, router-link, nuxt-link (or other nuxt alias)
         */
        tag: {
          type: String,
          default: 'button'
        },

        /**
         * Button will be disabled
         */
        disabled: Boolean,

        /**  @ignore */
        iconBoth: Boolean,
        // This is used internally
        elementsWrapperClass: [String, Function, Array],
        rootClass: [String, Function, Array],
        outlinedClass: [String, Function, Array],
        loadingClass: [String, Function, Array],
        invertedClass: [String, Function, Array],
        expandedClass: [String, Function, Array],
        roundedClass: [String, Function, Array],
        disabledClass: [String, Function, Array],
        iconClass: [String, Function, Array],
        iconLeftClass: [String, Function, Array],
        iconRightClass: [String, Function, Array],
        labelClass: [String, Function, Array],
        sizeClass: [String, Function, Array],
        variantClass: [String, Function, Array]
      },
      computed: {
        rootClasses() {
          return [this.computedClass('rootClass', 'o-btn'), {
            [this.computedClass('sizeClass', 'o-btn--', this.size)]: this.size
          }, {
            [this.computedClass('variantClass', 'o-btn--', this.variant)]: this.variant
          }, {
            [this.computedClass('outlinedClass', 'o-btn--outlined')]: this.outlined && !this.variant
          }, {
            [this.computedClass('invertedClass', 'o-btn--inverted')]: this.inverted && !this.variant
          }, {
            [this.computedClass('outlinedClass', 'o-btn--outlined-', this.variant)]: this.outlined && this.variant
          }, {
            [this.computedClass('invertedClass', 'o-btn--inverted-', this.variant)]: this.inverted && this.variant
          }, {
            [this.computedClass('expandedClass', 'o-btn--expanded')]: this.expanded
          }, {
            [this.computedClass('roundedClass', 'o-btn--rounded')]: this.rounded
          }, {
            [this.computedClass('disabledClass', 'o-btn--disabled')]: this.disabled
          }, {
            [this.computedClass('loadingClass', 'o-btn--loading')]: this.loading
          }];
        },

        labelClasses() {
          return [this.computedClass('labelClass', 'o-btn__label')];
        },

        iconClasses() {
          return [this.computedClass('iconClass', 'o-btn__icon')];
        },

        iconLeftClasses() {
          return [...this.iconClasses, this.computedClass('iconLeftClass', 'o-btn__icon-left')];
        },

        iconRightClasses() {
          return [...this.iconClasses, this.computedClass('iconRightClass', 'o-btn__icon-right')];
        },

        elementsWrapperClasses() {
          return [this.computedClass('elementsWrapperClass', 'o-btn__wrapper')];
        },

        computedTag() {
          if (this.disabled !== undefined && this.disabled !== false) {
            return 'button';
          }

          return this.tag;
        },

        computedNativeType() {
          if (this.tag === 'button' || this.tag === 'input') {
            return this.nativeType;
          }

          return null;
        }

      }
    };

    /* script */
    const __vue_script__$3 = script$3;

    /* template */
    var __vue_render__$3 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(_vm.computedTag,_vm._g(_vm._b({tag:"component",class:_vm.rootClasses,attrs:{"type":_vm.computedNativeType,"disabled":_vm.disabled}},'component',_vm.$attrs,false),_vm.$listeners),[_c('span',{class:_vm.elementsWrapperClasses},[(_vm.iconLeft)?_c('o-icon',{class:_vm.iconLeftClasses,attrs:{"pack":_vm.iconPack,"icon":_vm.iconLeft,"size":_vm.size,"both":_vm.iconBoth}}):_vm._e(),(_vm.label || _vm.$slots.default)?_c('span',{class:_vm.labelClasses},[_vm._t("default",[_vm._v(_vm._s(_vm.label))])],2):_vm._e(),(_vm.iconRight)?_c('o-icon',{class:_vm.iconRightClasses,attrs:{"pack":_vm.iconPack,"icon":_vm.iconRight,"size":_vm.size,"both":_vm.iconBoth}}):_vm._e()],1)])};
    var __vue_staticRenderFns__$3 = [];

      /* style */
      const __vue_inject_styles__$3 = undefined;
      /* scoped */
      const __vue_scope_id__$3 = undefined;
      /* module identifier */
      const __vue_module_identifier__$3 = undefined;
      /* functional template */
      const __vue_is_functional_template__$3 = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$3 = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },
        __vue_inject_styles__$3,
        __vue_script__$3,
        __vue_scope_id__$3,
        __vue_is_functional_template__$3,
        __vue_module_identifier__$3,
        false,
        undefined,
        undefined,
        undefined
      );

    const Plugin$2 = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$3);
      }

    };
    use(Plugin$2);

    const items = 1;
    const sorted = 3;
    const Sorted = sorted;
    var ProviderParentMixin = ((itemName, flags = 0) => {
      const mixin = {
        provide() {
          return {
            ['o' + itemName]: this
          };
        }

      };

      if (hasFlag(flags, items)) {
        mixin.data = function () {
          return {
            childItems: [],
            sequence: 1
          };
        };

        mixin.methods = {
          _registerItem(item) {
            item.index = this.childItems.length;
            this.childItems.push(item);

            if (this.$el) {
              this.$nextTick(() => {
                const ids = this.childItems.map(it => `#${itemName}-${it.newValue}`).join(',');
                const sortedIds = Array.from(this.$el.querySelectorAll(ids)).map(el => el.id.replace(`${itemName}-`, ''));
                this.childItems.forEach(it => it.index = sortedIds.indexOf(`${it.newValue}`));
              });
            }
          },

          _unregisterItem(item) {
            this.childItems = this.childItems.filter(i => i !== item);
          },

          _nextSequence() {
            return this.sequence++;
          }

        };

        if (hasFlag(flags, sorted)) {
          mixin.computed = {
            /**
             * When items are added/removed sort them according to their position
             */
            sortedItems() {
              return this.childItems.slice().sort((i1, i2) => {
                return i1.index - i2.index;
              });
            }

          };
        }
      }

      return mixin;
    });

    //
    /**
     * A Slideshow for cycling images in confined spaces
     * @displayName Carousel
     * @example ./examples/Carousel.md
     * @style _carousel.scss
     */

    var script$4 = {
      name: 'OCarousel',
      components: {
        [__vue_component__.name]: __vue_component__
      },
      configField: 'carousel',
      mixins: [ProviderParentMixin('carousel', Sorted), BaseComponentMixin],
      props: {
        value: {
          type: Number,
          default: 0
        },
        interval: {
          type: Number,
          default: () => {
            return getValueByPath(getOptions(), 'carousel.interval', 3500);
          }
        },
        hasDrag: {
          type: Boolean,
          default: true
        },
        autoplay: {
          type: Boolean,
          default: false
        },
        pauseHover: {
          type: Boolean,
          default: false
        },
        repeat: {
          type: Boolean,
          default: false
        },
        indicator: {
          type: Boolean,
          default: true
        },
        indicatorInside: {
          type: Boolean,
          default: false
        },
        indicatorMode: {
          type: String,
          default: 'click'
        },
        indicatorPosition: {
          type: String,
          default: 'bottom'
        },
        indicatorStyle: {
          type: String,
          default: 'dots'
        },
        overlay: Boolean,
        itemsToShow: {
          type: Number,
          default: 1
        },
        itemsToList: {
          type: Number,
          default: 1
        },
        asIndicator: Boolean,
        arrow: {
          type: Boolean,
          default: true
        },
        arrowHover: {
          type: Boolean,
          default: true
        },
        iconPack: String,
        iconSize: String,
        iconPrev: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'carousel.iconPrev', 'chevron-left');
          }
        },
        iconNext: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'carousel.iconNext', 'chevron-right');
          }
        },
        breakpoints: {
          type: Object,
          default: () => ({})
        },
        rootClass: [String, Function, Array],
        overlayClass: [String, Function, Array],
        sceneClass: [String, Function, Array],
        itemsClass: [String, Function, Array],
        itemsDraggingClass: [String, Function, Array],
        arrowIconClass: [String, Function, Array],
        arrowIconPrevClass: [String, Function, Array],
        arrowIconNextClass: [String, Function, Array],
        indicatorsClass: [String, Function, Array],
        indicatorsInsideClass: [String, Function, Array],
        indicatorsInsidePositionClass: [String, Function, Array],
        indicatorItemClass: [String, Function, Array],
        indicatorItemActiveClass: [String, Function, Array],
        indicatorItemStyleClass: [String, Function, Array]
      },

      data() {
        return {
          activeIndex: this.value,
          scrollIndex: this.value,
          delta: 0,
          dragX: false,
          hold: 0,
          windowWidth: 0,
          touch: false,
          observer: null,
          refresh_: 0,
          itemsHovered: false,
          isPause: false,
          timer: null
        };
      },

      computed: {
        rootClasses() {
          return [this.computedClass('rootClass', 'o-car'), {
            [this.computedClass('overlayClass', 'o-car__overlay')]: this.overlay
          }];
        },

        sceneClasses() {
          return [this.computedClass('sceneClass', 'o-car__scene')];
        },

        itemsClasses() {
          return [this.computedClass('itemsClass', 'o-car__items'), {
            [this.computedClass('itemsDraggingClass', 'o-car__items--dragging')]: this.dragging
          }];
        },

        arrowIconClasses() {
          return [this.computedClass('arrowIconClass', 'o-car__arrow__icon')];
        },

        arrowIconPrevClasses() {
          return [...this.arrowIconClasses, this.computedClass('arrowIconPrevClass', 'o-car__arrow__icon-prev')];
        },

        arrowIconNextClasses() {
          return [...this.arrowIconClasses, this.computedClass('arrowIconNextClass', 'o-car__arrow__icon-next')];
        },

        indicatorsClasses() {
          return [this.computedClass('indicatorsClass', 'o-car__indicators'), {
            [this.computedClass('indicatorsInsideClass', 'o-car__indicators--inside')]: this.indicatorInside
          }, {
            [this.computedClass('indicatorsInsidePositionClass', 'o-car__indicators--inside--', this.indicatorPosition)]: this.indicatorInside && this.indicatorPosition
          }];
        },

        indicatorClasses() {
          return [this.computedClass('indicatorClass', 'o-car__indicator')];
        },

        dragging() {
          return this.dragX !== false;
        },

        itemStyle() {
          return `width: ${this.itemWidth}px;`;
        },

        translation() {
          return -bound(this.delta + this.scrollIndex * this.itemWidth, 0, (this.childItems.length - this.settings.itemsToShow) * this.itemWidth);
        },

        total() {
          return this.childItems.length - this.settings.itemsToShow;
        },

        indicatorCount() {
          return Math.ceil(this.total / this.settings.itemsToList) + 1;
        },

        indicatorIndex() {
          return Math.ceil(this.scrollIndex / this.settings.itemsToList);
        },

        hasArrows() {
          return this.settings.arrowHover && this.itemsHovered || !this.settings.arrowHover;
        },

        hasPrev() {
          return (this.settings.repeat || this.scrollIndex > 0) && this.hasArrows;
        },

        hasNext() {
          return (this.settings.repeat || this.scrollIndex < this.total) && this.hasArrows;
        },

        breakpointKeys() {
          return Object.keys(this.breakpoints).sort((a, b) => b - a);
        },

        settings() {
          let breakpoint = this.breakpointKeys.filter(breakpoint => {
            if (this.windowWidth >= breakpoint) {
              return true;
            }
          })[0];

          if (breakpoint) {
            return { ...this.$props,
              ...this.breakpoints[breakpoint]
            };
          }

          return this.$props;
        },

        itemWidth() {
          if (this.windowWidth) {
            // Ensure component is mounted

            /* eslint-disable-next-line */
            this.refresh_; // We force the computed property to refresh if this prop is changed

            const rect = this.$el.getBoundingClientRect();
            return rect.width / this.settings.itemsToShow;
          }

          return 0;
        }

      },
      watch: {
        /**
         * When v-model is changed set the new active item.
         */
        value(value) {
          if (value <= this.childItems.length - 1) {
            this.activeIndex = value;
            this.switchTo(value * this.settings.itemsToList, true);
          }
        },

        /**
         *  When autoplay is changed, start or pause timer accordingly
         */
        autoplay(status) {
          if (status) {
            this.startTimer();
          } else {
            this.pauseTimer();
          }
        },

        /**
         *  Since the timer can get paused at the end, if repeat is changed we need to restart it
         */
        repeat(status) {
          if (status) {
            this.startTimer();
          }
        }

      },
      methods: {
        indicatorItemClasses(index) {
          return [this.computedClass('indicatorItemClass', 'o-car__indicator__item'), {
            [this.computedClass('indicatorItemActiveClass', 'o-car__indicator__item--active')]: this.indicatorIndex === index
          }, {
            [this.computedClass('indicatorItemStyleClass', 'o-car__indicator__item--', this.indicatorStyle)]: this.indicatorStyle
          }];
        },

        onMouseEnter() {
          this.itemsHovered = true;
          this.checkPause();
        },

        onMouseLeave() {
          this.itemsHovered = false;
          this.startTimer();
        },

        startTimer() {
          if (!this.autoplay || this.timer) return;
          this.isPause = false;
          this.timer = setInterval(() => {
            if (!this.repeat && this.activeIndex >= this.childItems.length - 1) {
              this.pauseTimer();
            } else {
              this.next();
            }
          }, this.interval);
        },

        pauseTimer() {
          this.isPause = true;

          if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
          }
        },

        restartTimer() {
          this.pauseTimer();
          this.startTimer();
        },

        checkPause() {
          if (this.pauseHover && this.autoplay) {
            this.pauseTimer();
          }
        },

        modeChange(trigger, value) {
          if (this.indicatorMode === trigger) {
            return this.switchTo(value * this.settings.itemsToList);
          }
        },

        resized() {
          this.windowWidth = window.innerWidth;
        },

        switchTo(newIndex, onlyMove = this.asIndicator) {
          if (this.settings.repeat) {
            newIndex = mod(newIndex, this.total + 1);
          }

          newIndex = bound(newIndex, 0, this.total);
          this.scrollIndex = newIndex;
          this.$emit('scroll', this.indicatorIndex);

          if (!onlyMove) {
            this.activeIndex = Math.ceil(newIndex / this.settings.itemsToList);

            if (this.value !== this.activeIndex) {
              this.$emit('input', this.activeIndex);
            }
          }
        },

        next() {
          this.switchTo(this.scrollIndex + this.settings.itemsToList);
        },

        prev() {
          this.switchTo(this.scrollIndex - this.settings.itemsToList);
        },

        // handle drag event
        dragStart(event) {
          if (this.dragging || !this.settings.hasDrag || event.button !== 0 && event.type !== 'touchstart') return;
          this.hold = Date.now();
          this.touch = !!event.touches;
          this.dragX = this.touch ? event.touches[0].clientX : event.clientX;

          if (this.touch) {
            this.pauseTimer();
          }

          window.addEventListener(this.touch ? 'touchmove' : 'mousemove', this.dragMove);
          window.addEventListener(this.touch ? 'touchend' : 'mouseup', this.dragEnd);
        },

        dragMove(event) {
          if (!this.dragging) return;
          const dragEndX = event.touches ? (event.changedTouches[0] || event.touches[0]).clientX : event.clientX;
          this.delta = this.dragX - dragEndX;

          if (!event.touches) {
            event.preventDefault();
          }
        },

        dragEnd(event) {
          if (!this.dragging && !this.hold) return;

          if (this.hold) {
            const signCheck = sign(this.delta);
            const results = Math.round(Math.abs(this.delta / this.itemWidth) + 0.15); // Hack

            this.switchTo(this.scrollIndex + signCheck * results);
          }

          this.delta = 0;
          this.dragX = false;

          if (event && event.touches) {
            this.startTimer();
          }

          window.removeEventListener(this.touch ? 'touchmove' : 'mousemove', this.dragMove);
          window.removeEventListener(this.touch ? 'touchend' : 'mouseup', this.dragEnd);
        },

        refresh() {
          this.$nextTick(() => {
            this.refresh_++;
          });
        }

      },

      mounted() {
        if (typeof window !== 'undefined') {
          if (window.ResizeObserver) {
            this.observer = new ResizeObserver(this.refresh);
            this.observer.observe(this.$el);
          }

          window.addEventListener('resize', this.resized);
          document.addEventListener('animationend', this.refresh);
          document.addEventListener('transitionend', this.refresh);
          document.addEventListener('transitionstart', this.refresh);
          this.resized();
          this.startTimer();
        }

        if (this.$attrs.config) {
          throw new Error('The config prop was removed, you need to use v-bind instead');
        }
      },

      beforeDestroy() {
        if (typeof window !== 'undefined') {
          if (window.ResizeObserver) {
            this.observer.disconnect();
          }

          window.removeEventListener('resize', this.resized);
          document.removeEventListener('animationend', this.refresh);
          document.removeEventListener('transitionend', this.refresh);
          document.removeEventListener('transitionstart', this.refresh);
          this.dragEnd();
          this.pauseTimer();
        }
      }

    };

    /* script */
    const __vue_script__$4 = script$4;

    /* template */
    var __vue_render__$4 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.rootClasses,on:{"mouseenter":_vm.onMouseEnter,"mouseleave":_vm.onMouseLeave}},[_c('div',{class:_vm.sceneClasses},[_c('div',{class:_vm.itemsClasses,style:('transform:translateX('+_vm.translation+'px)'),on:{"mousedown":_vm.dragStart,"touchstart":_vm.dragStart}},[_vm._t("default")],2),_vm._t("arrow",[(_vm.arrow)?[_c('o-icon',{directives:[{name:"show",rawName:"v-show",value:(_vm.hasPrev),expression:"hasPrev"}],class:_vm.arrowIconPrevClasses,attrs:{"pack":_vm.iconPack,"icon":_vm.iconPrev,"size":_vm.iconSize,"both":""},nativeOn:{"click":function($event){return _vm.prev($event)}}}),_c('o-icon',{directives:[{name:"show",rawName:"v-show",value:(_vm.hasNext),expression:"hasNext"}],class:_vm.arrowIconNextClasses,attrs:{"pack":_vm.iconPack,"icon":_vm.iconNext,"size":_vm.iconSize,"both":""},nativeOn:{"click":function($event){return _vm.next($event)}}})]:_vm._e()],{"hasPrev":_vm.hasPrev,"prev":_vm.prev,"hasNext":_vm.hasNext,"next":_vm.next})],2),_vm._t("indicators",[(_vm.childItems.length)?[(_vm.indicator && !_vm.asIndicator)?_c('div',{class:_vm.indicatorsClasses},_vm._l((_vm.indicatorCount),function(_,index){return _c('a',{key:index,class:_vm.indicatorClasses,on:{"mouseover":function($event){return _vm.modeChange('hover', index)},"click":function($event){return _vm.modeChange('click', index)}}},[_vm._t("indicator",[_c('span',{class:_vm.indicatorItemClasses(index)})],{"i":index})],2)}),0):_vm._e()]:_vm._e()],{"active":_vm.activeIndex,"switchTo":_vm.switchTo,"indicatorIndex":_vm.indicatorIndex}),(_vm.overlay)?[_vm._t("overlay")]:_vm._e()],2)};
    var __vue_staticRenderFns__$4 = [];

      /* style */
      const __vue_inject_styles__$4 = undefined;
      /* scoped */
      const __vue_scope_id__$4 = undefined;
      /* module identifier */
      const __vue_module_identifier__$4 = undefined;
      /* functional template */
      const __vue_is_functional_template__$4 = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$4 = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 },
        __vue_inject_styles__$4,
        __vue_script__$4,
        __vue_scope_id__$4,
        __vue_is_functional_template__$4,
        __vue_module_identifier__$4,
        false,
        undefined,
        undefined,
        undefined
      );

    const sorted$1 = 1;
    const optional = 2;
    const Sorted$1 = sorted$1;
    var InjectedChildMixin = ((parentItemName, flags = 0) => {
      const mixin = {
        inject: {
          parent: {
            from: 'o' + parentItemName
          }
        },

        created() {
          this.newValue = defaultIfUndefined(this.value, this.parent._nextSequence());

          if (!this.parent) {
            if (!hasFlag(flags, optional)) {
              throw new Error('You should wrap ' + this.$options.name + ' in a ' + parentItemName);
            }
          } else {
            this.parent._registerItem(this);
          }
        },

        beforeDestroy() {
          if (this.parent) {
            this.parent._unregisterItem(this);
          }
        }

      };

      if (hasFlag(flags, sorted$1)) {
        mixin.data = () => {
          return {
            index: null
          };
        };
      }

      return mixin;
    });

    //
    /**
     * @displayName Carousel Item
     */

    var script$5 = {
      name: 'OCarouselItem',
      configField: 'carousel',
      mixins: [InjectedChildMixin('carousel', Sorted$1), BaseComponentMixin],
      props: {
        itemClass: [String, Function, Array],
        itemActiveClass: [String, Function, Array]
      },
      computed: {
        itemClasses() {
          return [this.computedClass('itemClass', 'o-car__item'), {
            [this.computedClass('itemActiveClass', 'o-car__item--active')]: this.isActive
          }];
        },

        itemStyle() {
          return `width: ${this.parent.itemWidth}px;`;
        },

        isActive() {
          return this.parent.activeIndex === this.index;
        }

      },
      methods: {
        onClick(event) {
          if (this.isActive) {
            this.parent.$emit('click', event);
          }

          if (this.parent.asIndicator) {
            this.parent.activeIndex = this.index;
            this.parent.$emit('input', this.index);
          }
        }

      }
    };

    /* script */
    const __vue_script__$5 = script$5;

    /* template */
    var __vue_render__$5 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.itemClasses,style:(_vm.itemStyle),on:{"click":_vm.onClick}},[_vm._t("default")],2)};
    var __vue_staticRenderFns__$5 = [];

      /* style */
      const __vue_inject_styles__$5 = undefined;
      /* scoped */
      const __vue_scope_id__$5 = undefined;
      /* module identifier */
      const __vue_module_identifier__$5 = undefined;
      /* functional template */
      const __vue_is_functional_template__$5 = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$5 = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$5, staticRenderFns: __vue_staticRenderFns__$5 },
        __vue_inject_styles__$5,
        __vue_script__$5,
        __vue_scope_id__$5,
        __vue_is_functional_template__$5,
        __vue_module_identifier__$5,
        false,
        undefined,
        undefined,
        undefined
      );

    const Plugin$3 = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$4);
        registerComponent(Vue, __vue_component__$5);
      }

    };
    use(Plugin$3);

    var CheckRadioMixin = {
      props: {
        /** @model */
        value: [String, Number, Boolean, Array],

        /**
         * Same as native value
         */
        nativeValue: [String, Number, Boolean, Array],

        /**
         * Color of the control, optional
         * @values primary, info, success, warning, danger, and any other custom color
         */
        variant: String,

        /**
         * Same as native disabled
         */
        disabled: Boolean,
        required: Boolean,

        /**
         * Same as native name
         */
        name: String,

        /**
         * Size of the control, optional
         * @values small, medium, large
         */
        size: String
      },

      data() {
        return {
          newValue: this.value,
          isIndeterminate: this.indeterminate
        };
      },

      computed: {
        computedValue: {
          get() {
            return this.newValue;
          },

          set(value) {
            this.newValue = value;
            this.isIndeterminate = false;
            this.$emit('input', this.newValue);
          }

        }
      },
      watch: {
        /**
         * When v-model change, set internal value.
         */
        value(value) {
          this.newValue = value;
        }

      },
      methods: {
        focus() {
          // MacOS FireFox and Safari do not focus when clicked
          this.$refs.input.focus();
        }

      }
    };

    //
    /**
     * Select a single or grouped options
     * @displayName Checkbox
     * @example ./examples/Checkbox.md
     * @style _checkbox.scss
     */

    var script$6 = {
      name: 'OCheckbox',
      mixins: [BaseComponentMixin, CheckRadioMixin],
      configField: 'checkbox',
      props: {
        /**
         * Same as native indeterminate
         */
        indeterminate: {
          type: Boolean,
          default: false
        },

        /**
         * Overrides the returned value when it's checked
         */
        trueValue: {
          type: [String, Number, Boolean],
          default: true
        },

        /**
         * Overrides the returned value when it's not checked
         */
        falseValue: {
          type: [String, Number, Boolean],
          default: false
        },

        /** Accessibility label to establish relationship between the checkbox and control label */
        ariaLabelledby: String,

        /* Same as native autocomplete */
        autocomplete: String,
        rootClass: [String, Function, Array],
        disabledClass: [String, Function, Array],
        checkClass: [String, Function, Array],
        checkedClass: [String, Function, Array],
        checkCheckedClass: [String, Function, Array],
        checkIndeterminateClass: [String, Function, Array],
        labelClass: [String, Function, Array],
        sizeClass: [String, Function, Array],
        variantClass: [String, Function, Array]
      },
      watch: {
        indeterminate: {
          handler(val) {
            this.isIndeterminate = val;
          },

          immediate: true
        }
      },
      computed: {
        isChecked() {
          return this.computedValue === this.trueValue || Array.isArray(this.computedValue) && this.computedValue.indexOf(this.nativeValue) !== -1;
        },

        rootClasses() {
          return [this.computedClass('rootClass', 'o-chk'), {
            [this.computedClass('checkedClass', 'o-chk--checked')]: this.isChecked
          }, {
            [this.computedClass('sizeClass', 'o-chk--', this.size)]: this.size
          }, {
            [this.computedClass('disabledClass', 'o-chk--disabled')]: this.disabled
          }, {
            [this.computedClass('variantClass', 'o-chk--', this.variant)]: this.variant
          }];
        },

        checkClasses() {
          return [this.computedClass('checkClass', 'o-chk__check'), {
            [this.computedClass('checkCheckedClass', 'o-chk__check--checked')]: this.isChecked
          }, {
            [this.computedClass('checkIndeterminateClass', 'o-chk__check--indeterminate')]: this.isIndeterminate
          }];
        },

        labelClasses() {
          return [this.computedClass('labelClass', 'o-chk__label')];
        }

      }
    };

    /* script */
    const __vue_script__$6 = script$6;

    /* template */
    var __vue_render__$6 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{ref:"label",class:_vm.rootClasses,attrs:{"disabled":_vm.disabled},on:{"click":function($event){$event.stopPropagation();return _vm.focus($event)},"keydown":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }$event.preventDefault();return _vm.$refs.label.click()}}},[_c('input',_vm._b({directives:[{name:"model",rawName:"v-model",value:(_vm.computedValue),expression:"computedValue"}],ref:"input",class:_vm.checkClasses,attrs:{"type":"checkbox","disabled":_vm.disabled,"required":_vm.required,"name":_vm.name,"autocomplete":_vm.autocomplete,"true-value":_vm.trueValue,"false-value":_vm.falseValue,"aria-labelledby":_vm.ariaLabelledby},domProps:{"indeterminate":_vm.indeterminate,"value":_vm.nativeValue,"checked":Array.isArray(_vm.computedValue)?_vm._i(_vm.computedValue,_vm.nativeValue)>-1:_vm._q(_vm.computedValue,_vm.trueValue)},on:{"click":function($event){$event.stopPropagation();},"change":function($event){var $$a=_vm.computedValue,$$el=$event.target,$$c=$$el.checked?(_vm.trueValue):(_vm.falseValue);if(Array.isArray($$a)){var $$v=_vm.nativeValue,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.computedValue=$$a.concat([$$v]));}else {$$i>-1&&(_vm.computedValue=$$a.slice(0,$$i).concat($$a.slice($$i+1)));}}else {_vm.computedValue=$$c;}}}},'input',_vm.$attrs,false)),_c('span',{class:_vm.labelClasses,attrs:{"id":_vm.ariaLabelledby}},[_vm._t("default")],2)])};
    var __vue_staticRenderFns__$6 = [];

      /* style */
      const __vue_inject_styles__$6 = undefined;
      /* scoped */
      const __vue_scope_id__$6 = undefined;
      /* module identifier */
      const __vue_module_identifier__$6 = undefined;
      /* functional template */
      const __vue_is_functional_template__$6 = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$6 = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$6, staticRenderFns: __vue_staticRenderFns__$6 },
        __vue_inject_styles__$6,
        __vue_script__$6,
        __vue_scope_id__$6,
        __vue_is_functional_template__$6,
        __vue_module_identifier__$6,
        false,
        undefined,
        undefined,
        undefined
      );

    const Plugin$4 = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$6);
      }

    };
    use(Plugin$4);

    /**
     * An easy way to toggle what you want
     * @displayName Collapse
     * @example ./examples/Collapse.md
     * @style _collapse.scss
     */

    var script$7 = {
      name: 'OCollapse',
      mixins: [BaseComponentMixin],
      configField: 'collapse',
      props: {
        /**
         * Whether collapse is open or not, use the .sync modifier (Vue 2.x) or v-model:open (Vue 3.x) to make it two-way binding
         */
        open: {
          type: Boolean,
          default: true
        },

        /**
         * Custom animation (transition name)
         */
        animation: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'collapse.animation', 'fade');
          }
        },
        ariaId: {
          type: String,
          default: ''
        },

        /**
         * Trigger position
         * @values top, bottom
         */
        position: {
          type: String,
          default: 'top',

          validator(value) {
            return ['top', 'bottom'].indexOf(value) > -1;
          }

        },
        rootClass: [String, Function, Array],
        triggerClass: [String, Function, Array],
        contentClass: [String, Function, Array]
      },

      data() {
        return {
          isOpen: this.open
        };
      },

      watch: {
        open(value) {
          this.isOpen = value;
        }

      },
      methods: {
        /**
        * Toggle and emit events
        */
        toggle() {
          this.isOpen = !this.isOpen;
          this.$emit('update:open', this.isOpen);
          this.$emit(this.isOpen ? 'open' : 'close');
        }

      },

      render(h) {
        const trigger = h('div', {
          staticClass: this.computedClass('triggerClass', 'o-clps__trigger'),
          on: {
            click: this.toggle
          }
        }, this.$scopedSlots.trigger ? this.$scopedSlots.trigger({
          open: this.isOpen
        }) : this.$slots.trigger);
        const content = h('transition', {
          props: {
            name: this.animation
          }
        }, [h('div', {
          staticClass: this.computedClass('contentClass', 'o-clps__content'),
          attrs: {
            'id': this.ariaId
          },
          directives: [{
            name: 'show',
            value: this.isOpen
          }]
        }, this.$slots.default)]);
        return h('div', {
          staticClass: this.computedClass('rootClass', 'o-clps')
        }, this.position === 'top' ? [trigger, content] : [content, trigger]);
      }

    };

    /* script */
    const __vue_script__$7 = script$7;

    /* template */

      /* style */
      const __vue_inject_styles__$7 = undefined;
      /* scoped */
      const __vue_scope_id__$7 = undefined;
      /* module identifier */
      const __vue_module_identifier__$7 = undefined;
      /* functional template */
      const __vue_is_functional_template__$7 = undefined;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$7 = /*#__PURE__*/normalizeComponent(
        {},
        __vue_inject_styles__$7,
        __vue_script__$7,
        __vue_scope_id__$7,
        __vue_is_functional_template__$7,
        __vue_module_identifier__$7,
        false,
        undefined,
        undefined,
        undefined
      );

    const Plugin$5 = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$7);
      }

    };
    use(Plugin$5);

    var MatchMediaMixin = {
      props: {
        /**
         * Mobile breakpoint as max-width value
         */
        mobileBreakpoint: String
      },

      data() {
        return {
          isMatchMedia: undefined
        };
      },

      methods: {
        onMatchMedia(event) {
          this.isMatchMedia = event.matches;
        }

      },

      mounted() {
        let width = this.mobileBreakpoint;

        if (!width) {
          const config = getOptions();
          const defaultWidth = getValueByPath(config, 'mobileBreakpoint', '1023px');
          width = getValueByPath(config, `${this.$options.configField}.mobileBreakpoint`, defaultWidth);
        }

        this.$mediaRef = window.matchMedia(`(max-width: ${width})`);

        if (this.$mediaRef) {
          this.isMatchMedia = this.$mediaRef.matches;
          this.$mediaRef.addEventListener('change', this.onMatchMedia);
        } else {
          this.isMatchMedia = false;
        }
      },

      unmounted() {
        if (this.$mediaRef) {
          this.$mediaRef.removeEventListener('change', this.onMatchMedia);
        }
      }

    };

    const findFocusable = (element, programmatic = false) => {
      if (!element) {
        return null;
      }

      if (programmatic) {
        return element.querySelectorAll(`*[tabindex="-1"]`);
      }

      return element.querySelectorAll(`a[href]:not([tabindex="-1"]),
                                     area[href],
                                     input:not([disabled]),
                                     select:not([disabled]),
                                     textarea:not([disabled]),
                                     button:not([disabled]),
                                     iframe,
                                     object,
                                     embed,
                                     *[tabindex]:not([tabindex="-1"]),
                                     *[contenteditable]`);
    };

    let onKeyDown;

    const bind = (el, {
      value = true
    }) => {
      if (value) {
        let focusable = findFocusable(el);
        let focusableProg = findFocusable(el, true);

        if (focusable && focusable.length > 0) {
          onKeyDown = event => {
            // Need to get focusable each time since it can change between key events
            // ex. changing month in a datepicker
            focusable = findFocusable(el);
            focusableProg = findFocusable(el, true);
            const firstFocusable = focusable[0];
            const lastFocusable = focusable[focusable.length - 1];

            if (event.target === firstFocusable && event.shiftKey && event.key === 'Tab') {
              event.preventDefault();
              lastFocusable.focus();
            } else if ((event.target === lastFocusable || Array.from(focusableProg).indexOf(event.target) >= 0) && !event.shiftKey && event.key === 'Tab') {
              event.preventDefault();
              firstFocusable.focus();
            }
          };

          el.addEventListener('keydown', onKeyDown);
        }
      }
    };

    const unbind = el => {
      el.removeEventListener('keydown', onKeyDown);
    };

    const directive = {
      bind,
      unbind
    };

    //
    /**
     * Dropdowns are very versatile, can used as a quick menu or even like a select for discoverable content
     * @displayName Dropdown
     * @requires ./DropdownItem.vue
     * @example ./examples/Dropdown.md
     * @style _dropdown.scss
     */

    var script$8 = {
      name: 'ODropdown',
      directives: {
        trapFocus: directive
      },
      configField: 'dropdown',
      mixins: [BaseComponentMixin, MatchMediaMixin],

      provide() {
        return {
          $dropdown: this
        };
      },

      props: {
        /** @model */
        value: {
          type: [String, Number, Boolean, Object, Array],
          default: null
        },

        /**
         * Dropdown disabled
         */
        disabled: Boolean,

        /**
         * Dropdown content (items) are shown inline, trigger is removed
         */
        inline: Boolean,

        /**
         * Dropdown content will be scrollable
         */
        scrollable: Boolean,

        /**
         * Max height of dropdown content
         */
        maxHeight: {
          type: [String, Number],
          default: () => {
            return getValueByPath(getOptions(), 'dropdown.maxHeight', 200);
          }
        },

        /**
         * Optional, position of the dropdown relative to the trigger
         * @values top-right, top-left, bottom-left
         */
        position: {
          type: String,

          validator(value) {
            return ['top-right', 'top-left', 'bottom-left', 'bottom-right'].indexOf(value) > -1;
          }

        },

        /**
         * Dropdown content (items) are shown into a modal on mobile
         */
        mobileModal: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'dropdown.mobileModal', true);
          }
        },

        /**
         * Role attribute to be passed to list container for better accessibility. Use menu only in situations where your dropdown is related to navigation menus
         * @values list, menu, dialog
         */
        ariaRole: {
          type: String,

          validator(value) {
            return ['menu', 'list', 'dialog'].indexOf(value) > -1;
          },

          default: null
        },

        /**
         * Custom animation (transition name)
         */
        animation: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'dropdown.animation', 'fade');
          }
        },

        /**
         * Allows multiple selections
         */
        multiple: Boolean,

        /**
         * Trap focus inside the dropdown.
         */
        trapFocus: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'dropdown.trapFocus', true);
          }
        },

        /**
         * Close dropdown when content is clicked
         */
        closeOnClick: {
          type: Boolean,
          default: true
        },

        /**
         * Can close dropdown by pressing escape or by clicking outside
         * @values escape, outside
         */
        canClose: {
          type: [Array, Boolean],
          default: true
        },

        /**
         * Dropdown will be expanded (full-width)
         */
        expanded: Boolean,

        /**
         * Dropdown will be triggered by any events
         * @values click, hover, contextmenu, focus
         */
        triggers: {
          type: Array,
          default: () => ['click']
        },

        /**
         * Dropdown menu tag name
         */
        menuTag: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'dropdown.menuTag', 'div');
          }
        },

        /**
         * Set the tabindex attribute on the dropdown trigger div (-1 to prevent selection via tab key)
         */
        triggerTabindex: {
          type: Number,
          default: 0
        },

        /**
         * Append dropdown content to body
         */
        appendToBody: Boolean,

        /**
        * @ignore
        */
        appendToBodyCopyParent: Boolean,
        rootClass: [String, Function, Array],
        triggerClass: [String, Function, Array],
        inlineClass: [String, Function, Array],
        menuMobileOverlayClass: [String, Function, Array],
        menuClass: [String, Function, Array],
        menuPositionClass: [String, Function, Array],
        menuActiveClass: [String, Function, Array],
        mobileClass: [String, Function, Array],
        disabledClass: [String, Function, Array],
        expandedClass: [String, Function, Array]
      },

      data() {
        return {
          selected: this.value,
          isActive: false,
          isHoverable: false,
          bodyEl: undefined // Used to append to body

        };
      },

      computed: {
        rootClasses() {
          return [this.computedClass('rootClass', 'o-drop'), {
            [this.computedClass('disabledClass', 'o-drop--disabled')]: this.disabled
          }, {
            [this.computedClass('expandedClass', 'o-drop--expanded')]: this.expanded
          }, {
            [this.computedClass('inlineClass', 'o-drop--inline')]: this.inline
          }, {
            [this.computedClass('mobileClass', 'o-drop--mobile')]: this.isMobileModal && this.isMatchMedia && !this.hoverable
          }];
        },

        triggerClasses() {
          return [this.computedClass('triggerClass', 'o-drop__trigger')];
        },

        menuMobileOverlayClasses() {
          return [this.computedClass('menuMobileOverlayClass', 'o-drop__overlay')];
        },

        menuClasses() {
          return [this.computedClass('menuClass', 'o-drop__menu'), {
            [this.computedClass('menuPositionClass', 'o-drop__menu--', this.position)]: this.position
          }, {
            [this.computedClass('menuActiveClass', 'o-drop__menu--active')]: this.isActive || this.inline
          }];
        },

        isMobileModal() {
          return this.mobileModal && !this.inline;
        },

        cancelOptions() {
          return typeof this.canClose === 'boolean' ? this.canClose ? ['escape', 'outside'] : [] : this.canClose;
        },

        menuStyle() {
          return {
            maxHeight: this.scrollable ? toCssDimension(this.maxHeight) : null,
            overflow: this.scrollable ? 'auto' : null
          };
        },

        hoverable() {
          return this.triggers.indexOf('hover') >= 0;
        }

      },
      watch: {
        /**
        * When v-model is changed set the new selected item.
        */
        value(value) {
          this.selected = value;
        },

        /**
        * Emit event when isActive value is changed.
        */
        isActive(value) {
          this.$emit('active-change', value);

          if (this.appendToBody) {
            this.$nextTick(() => {
              this.updateAppendToBody();
            });
          }
        }

      },
      methods: {
        /**
         * Click listener from DropdownItem.
         *   1. Set new selected item.
         *   2. Emit input event to update the user v-model.
         *   3. Close the dropdown.
         */
        selectItem(value) {
          if (this.multiple) {
            if (this.selected) {
              if (this.selected.indexOf(value) === -1) {
                // Add value
                this.selected = [...this.selected, value];
              } else {
                // Remove value
                this.selected = this.selected.filter(val => val !== value);
              }
            } else {
              this.selected = [value];
            }

            this.$emit('change', this.selected);
          } else {
            if (this.selected !== value) {
              this.selected = value;
              this.$emit('change', this.selected);
            }
          }

          this.$emit('input', this.selected);

          if (!this.multiple) {
            this.isActive = !this.closeOnClick;

            if (this.hoverable && this.closeOnClick) {
              this.isHoverable = false;
            }
          }
        },

        /**
        * White-listed items to not close when clicked.
        */
        isInWhiteList(el) {
          if (el === this.$refs.dropdownMenu) return true;
          if (el === this.$refs.trigger) return true; // All chidren from dropdown

          if (this.$refs.dropdownMenu !== undefined) {
            const children = this.$refs.dropdownMenu.querySelectorAll('*');

            for (const child of children) {
              if (el === child) {
                return true;
              }
            }
          } // All children from trigger


          if (this.$refs.trigger !== undefined) {
            const children = this.$refs.trigger.querySelectorAll('*');

            for (const child of children) {
              if (el === child) {
                return true;
              }
            }
          }

          return false;
        },

        /**
        * Close dropdown if clicked outside.
        */
        clickedOutside(event) {
          if (this.cancelOptions.indexOf('outside') < 0) return;
          if (this.inline) return;
          if (!this.isInWhiteList(event.target)) this.isActive = false;
        },

        /**
         * Keypress event that is bound to the document
         */
        keyPress({
          key
        }) {
          if (this.isActive && (key === 'Escape' || key === 'Esc')) {
            if (this.cancelOptions.indexOf('escape') < 0) return;
            this.isActive = false;
          }
        },

        onClick() {
          if (this.triggers.indexOf('click') < 0) return;
          this.toggle();
        },

        onContextMenu() {
          if (this.triggers.indexOf('contextmenu') < 0) return;
          this.toggle();
        },

        onHover() {
          if (this.triggers.indexOf('hover') < 0) return;
          this.isHoverable = true;
        },

        onFocus() {
          if (this.triggers.indexOf('focus') < 0) return;
          this.toggle();
        },

        /**
        * Toggle dropdown if it's not disabled.
        */
        toggle() {
          if (this.disabled) return;

          if (!this.isActive) {
            // if not active, toggle after clickOutside event
            // this fixes toggling programmatic
            this.$nextTick(() => {
              const value = !this.isActive;
              this.isActive = value; // Vue 2.6.x ???

              setTimeout(() => this.isActive = value);
            });
          } else {
            this.isActive = !this.isActive;
          }
        },

        updateAppendToBody() {
          const dropdownMenu = this.$refs.dropdownMenu;
          const trigger = this.$refs.trigger;

          if (dropdownMenu && trigger) {
            // update wrapper dropdown
            const dropdown = this.$data.bodyEl.children[0];
            dropdown.classList.forEach(item => dropdown.classList.remove(...item.split(' ')));
            this.rootClasses.forEach(item => {
              if (item) {
                if (typeof item === 'object') {
                  Object.keys(item).filter(key => key && item[key]).forEach(key => dropdown.classList.add(key));
                } else {
                  dropdown.classList.add(...item.split(' '));
                }
              }
            });

            if (this.appendToBodyCopyParent) {
              const parentNode = this.$refs.dropdown.parentNode;
              const parent = this.$data.bodyEl;
              parent.classList.forEach(item => parent.classList.remove(...item.split(' ')));
              parentNode.classList.forEach(item => parent.classList.add(...item.split(' ')));
            }

            const rect = trigger.getBoundingClientRect();
            let top = rect.top + window.scrollY;
            let left = rect.left + window.scrollX;

            if (!this.position || this.position.indexOf('bottom') >= 0) {
              top += trigger.clientHeight;
            } else {
              top -= dropdownMenu.clientHeight;
            }

            if (this.position && this.position.indexOf('left') >= 0) {
              left -= dropdownMenu.clientWidth - trigger.clientWidth;
            }

            dropdownMenu.style.position = 'absolute';
            dropdownMenu.style.top = `${top}px`;
            dropdownMenu.style.left = `${left}px`;
            dropdownMenu.style.zIndex = '9999';
          }
        }

      },

      mounted() {
        if (this.appendToBody) {
          this.$data.bodyEl = createAbsoluteElement(this.$refs.dropdownMenu);
          this.updateAppendToBody();
        }
      },

      created() {
        if (typeof window !== 'undefined') {
          document.addEventListener('click', this.clickedOutside);
          document.addEventListener('keyup', this.keyPress);
        }
      },

      beforeDestroy() {
        if (typeof window !== 'undefined') {
          document.removeEventListener('click', this.clickedOutside);
          document.removeEventListener('keyup', this.keyPress);
        }

        if (this.appendToBody) {
          removeElement(this.$data.bodyEl);
        }
      }

    };

    /* script */
    const __vue_script__$8 = script$8;

    /* template */
    var __vue_render__$7 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:"dropdown",class:_vm.rootClasses},[(!_vm.inline)?_c('div',{ref:"trigger",class:_vm.triggerClasses,attrs:{"tabindex":_vm.disabled ? null : _vm.triggerTabindex,"aria-haspopup":"true"},on:{"click":_vm.onClick,"contextmenu":function($event){$event.preventDefault();return _vm.onContextMenu($event)},"mouseenter":_vm.onHover,"mouseleave":function($event){_vm.isHoverable = false;},"!focus":function($event){return _vm.onFocus($event)}}},[_vm._t("trigger",null,{"active":_vm.isActive})],2):_vm._e(),_c('transition',{attrs:{"name":_vm.animation}},[(_vm.isMobileModal)?_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.isActive),expression:"isActive"}],class:_vm.menuMobileOverlayClasses,attrs:{"aria-hidden":!_vm.isActive}}):_vm._e()]),_c('transition',{attrs:{"name":_vm.animation}},[_c(_vm.menuTag,{directives:[{name:"show",rawName:"v-show",value:((!_vm.disabled && (_vm.isActive || _vm.isHoverable)) || _vm.inline),expression:"(!disabled && (isActive || isHoverable)) || inline"},{name:"trap-focus",rawName:"v-trap-focus",value:(_vm.trapFocus),expression:"trapFocus"}],ref:"dropdownMenu",tag:"div",class:_vm.menuClasses,style:(_vm.menuStyle),attrs:{"aria-hidden":!_vm.isActive,"role":_vm.ariaRole,"aria-modal":!_vm.inline},on:{"mouseenter":_vm.onHover,"mouseleave":function($event){_vm.isHoverable = false;}}},[_vm._t("default")],2)],1)],1)};
    var __vue_staticRenderFns__$7 = [];

      /* style */
      const __vue_inject_styles__$8 = undefined;
      /* scoped */
      const __vue_scope_id__$8 = undefined;
      /* module identifier */
      const __vue_module_identifier__$8 = undefined;
      /* functional template */
      const __vue_is_functional_template__$8 = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$8 = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$7, staticRenderFns: __vue_staticRenderFns__$7 },
        __vue_inject_styles__$8,
        __vue_script__$8,
        __vue_scope_id__$8,
        __vue_is_functional_template__$8,
        __vue_module_identifier__$8,
        false,
        undefined,
        undefined,
        undefined
      );

    //
    /**
     * @displayName Dropdown Item
     */

    var script$9 = {
      name: 'ODropdownItem',
      mixins: [BaseComponentMixin],
      configField: 'dropdown',
      inject: ["$dropdown"],
      props: {
        /**
         * The value that will be returned on events and v-model
         */
        value: {
          type: [String, Number, Boolean, Object, Array],
          default: null
        },

        /**
         * Item is disabled
         */
        disabled: Boolean,

        /**
         * Item is clickable and emit an event
         */
        clickable: {
          type: Boolean,
          default: true
        },

        /**
         * Dropdown item tag name
         */
        tag: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'dropdown.itemTag', 'div');
          }
        },
        tabindex: {
          type: [Number, String],
          default: 0
        },
        ariaRole: {
          type: String,
          default: ''
        },
        itemClass: [String, Function, Array],
        itemActiveClass: [String, Function, Array],
        itemDisabledClass: [String, Function, Array]
      },
      computed: {
        parent() {
          return this.$dropdown;
        },

        rootClasses() {
          return [this.computedClass('itemClass', 'o-drop__item'), {
            [this.computedClass('itemDisabledClass', 'o-drop__item--disabled')]: this.parent.disabled || this.disabled
          }, {
            [this.computedClass('itemActiveClass', 'o-drop__item--active')]: this.isActive
          }];
        },

        ariaRoleItem() {
          return this.ariaRole === 'menuitem' || this.ariaRole === 'listitem' ? this.ariaRole : null;
        },

        isClickable() {
          return !this.parent.disabled && !this.disabled && this.clickable;
        },

        isActive() {
          if (this.parent.selected === null) return false;
          if (this.parent.multiple) return this.parent.selected.indexOf(this.value) >= 0;
          return this.value === this.parent.selected;
        }

      },
      methods: {
        /**
        * Click listener, select the item.
        */
        selectItem() {
          if (!this.isClickable) return;
          this.parent.selectItem(this.value);
          this.$emit('click');
        }

      },

      created() {
        if (!this.parent) {
          throw new Error('You should wrap oDropdownItem on a oDropdown');
        }
      }

    };

    /* script */
    const __vue_script__$9 = script$9;

    /* template */
    var __vue_render__$8 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(_vm.tag,{tag:"component",class:_vm.rootClasses,attrs:{"role":_vm.ariaRoleItem,"tabindex":_vm.tabindex},on:{"click":_vm.selectItem}},[_vm._t("default")],2)};
    var __vue_staticRenderFns__$8 = [];

      /* style */
      const __vue_inject_styles__$9 = undefined;
      /* scoped */
      const __vue_scope_id__$9 = undefined;
      /* module identifier */
      const __vue_module_identifier__$9 = undefined;
      /* functional template */
      const __vue_is_functional_template__$9 = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$9 = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$8, staticRenderFns: __vue_staticRenderFns__$8 },
        __vue_inject_styles__$9,
        __vue_script__$9,
        __vue_scope_id__$9,
        __vue_is_functional_template__$9,
        __vue_module_identifier__$9,
        false,
        undefined,
        undefined,
        undefined
      );

    //
    /**
     * Select an item in a dropdown list. Use with Field to access all functionalities
     * @displayName Select
     * @example ./examples/Select.md
     * @style _select.scss
     */

    var script$a = {
      name: 'OSelect',
      components: {
        [__vue_component__.name]: __vue_component__
      },
      mixins: [BaseComponentMixin, FormElementMixin],
      configField: 'select',
      inheritAttrs: false,
      props: {
        /** @model */
        value: {
          type: [String, Number, Boolean, Object, Array],
          default: null
        },

        /**
         * Vertical size of input, optional
         * @values small, medium, large
         */
        size: String,

        /**
        * Color of the control, optional
        * @values primary, info, success, warning, danger, and any other custom color
        */
        variant: String,

        /**
        * Icon pack to use
        * @values mdi, fa, fas and any other custom icon pack
        */
        iconPack: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'select.iconPack', undefined);
          }
        },

        /**
         * 	Icon name to be added on the right side
         */
        iconRight: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'select.iconRight', undefined);
          }
        },

        /** Text when nothing is selected */
        placeholder: String,
        multiple: Boolean,

        /** Same as native size */
        nativeSize: [String, Number],
        rootClass: [String, Function, Array],
        selectClass: [String, Function, Array],
        iconLeftSpaceClass: [String, Function, Array],
        iconRightSpaceClass: [String, Function, Array],
        roundedClass: [String, Function, Array],
        multipleClass: [String, Function, Array],
        expandedClass: [String, Function, Array],
        iconLeftClass: [String, Function, Array],
        iconRightClass: [String, Function, Array],
        sizeClass: [String, Function, Array],
        variantClass: [String, Function, Array],
        placeholderClass: [String, Function, Array],
        arrowClass: [String, Function, Array]
      },

      data() {
        return {
          selected: this.value
        };
      },

      computed: {
        rootClasses() {
          return [this.computedClass('rootClass', 'o-ctrl-sel'), {
            [this.computedClass('expandedClass', 'o-ctrl-sel--expanded')]: this.expanded
          }];
        },

        selectClasses() {
          return [this.computedClass('selectClass', 'o-sel'), {
            [this.computedClass('roundedClass', 'o-sel--rounded')]: this.rounded
          }, {
            [this.computedClass('multipleClass', 'o-sel--multiple')]: this.multiple
          }, {
            [this.computedClass('sizeClass', 'o-sel--', this.size)]: this.size
          }, {
            [this.computedClass('variantClass', 'o-sel--', this.statusVariant || this.variant)]: this.statusVariant || this.variant
          }, {
            [this.computedClass('iconLeftSpaceClass', 'o-sel-iconspace-left')]: this.icon
          }, {
            [this.computedClass('iconRightSpaceClass', 'o-sel-iconspace-right')]: this.iconRight
          }, {
            [this.computedClass('placeholderClass', 'o-sel--placeholder')]: this.placeholderVisible
          }, {
            [this.computedClass('arrowClass', 'o-sel-arrow')]: !this.iconRight && !this.multiple
          }];
        },

        iconLeftClasses() {
          return [this.computedClass('iconLeftClass', 'o-sel__icon-left')];
        },

        iconRightClasses() {
          return [this.computedClass('iconRightClass', 'o-sel__icon-right')];
        },

        placeholderVisible() {
          return this.computedValue === null;
        },

        computedValue: {
          get() {
            return this.selected;
          },

          set(value) {
            this.selected = value;
            this.$emit('input', value);
            this.syncFilled(this.selected);
            !this.isValid && this.checkHtml5Validity();
          }

        },

        $elementRef() {
          return 'select';
        }

      },
      watch: {
        /**
        * When v-model is changed:
        *   1. Set the selected option.
        *   2. If it's invalid, validate again.
        */
        value(value) {
          this.selected = value;
          this.syncFilled(this.selected);
          !this.isValid && this.checkHtml5Validity();
        }

      }
    };

    /* script */
    const __vue_script__$a = script$a;

    /* template */
    var __vue_render__$9 = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.rootClasses},[_c('select',_vm._b({directives:[{name:"model",rawName:"v-model",value:(_vm.computedValue),expression:"computedValue"}],ref:"select",class:_vm.selectClasses,attrs:{"autocomplete":_vm.autocomplete,"multiple":_vm.multiple,"size":_vm.nativeSize},on:{"blur":_vm.onBlur,"focus":_vm.onFocus,"invalid":_vm.onInvalid,"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.computedValue=$event.target.multiple ? $$selectedVal : $$selectedVal[0];}}},'select',_vm.$attrs,false),[(_vm.placeholder)?[(_vm.placeholderVisible)?_c('option',{attrs:{"disabled":"","hidden":""},domProps:{"value":null}},[_vm._v(" "+_vm._s(_vm.placeholder)+" ")]):_vm._e()]:_vm._e(),_vm._t("default")],2),(_vm.icon)?_c('o-icon',{class:_vm.iconLeftClasses,attrs:{"icon":_vm.icon,"pack":_vm.iconPack,"size":_vm.size}}):_vm._e(),(_vm.iconRight)?_c('o-icon',{class:_vm.iconRightClasses,attrs:{"icon":_vm.iconRight,"pack":_vm.iconPack,"size":_vm.size}}):_vm._e()],1)};
    var __vue_staticRenderFns__$9 = [];

      /* style */
      const __vue_inject_styles__$a = undefined;
      /* scoped */
      const __vue_scope_id__$a = undefined;
      /* module identifier */
      const __vue_module_identifier__$a = undefined;
      /* functional template */
      const __vue_is_functional_template__$a = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$a = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$9, staticRenderFns: __vue_staticRenderFns__$9 },
        __vue_inject_styles__$a,
        __vue_script__$a,
        __vue_scope_id__$a,
        __vue_is_functional_template__$a,
        __vue_module_identifier__$a,
        false,
        undefined,
        undefined,
        undefined
      );

    var DatepickerMixin = {
      methods: {
        manageKeydown(event, weekDay) {
          // https://developer.mozilla.org/fr/docs/Web/API/KeyboardEvent/key/Key_Values#Navigation_keys
          const {
            key
          } = event;
          let preventDefault = true;

          switch (key) {
            case 'Tab':
              {
                preventDefault = false;
                break;
              }

            case ' ':
            case 'Space':
            case 'Spacebar':
            case 'Enter':
              {
                this.emitChosenDate(weekDay);
                break;
              }

            case 'ArrowLeft':
            case 'Left':
              {
                this.changeFocus(weekDay, -1);
                break;
              }

            case 'ArrowRight':
            case 'Right':
              {
                this.changeFocus(weekDay, 1);
                break;
              }

            case 'ArrowUp':
            case 'Up':
              {
                this.changeFocus(weekDay, -7);
                break;
              }

            case 'ArrowDown':
            case 'Down':
              {
                this.changeFocus(weekDay, 7);
                break;
              }
          }

          if (preventDefault) {
            event.preventDefault();
          }
        }

      }
    };

    //
    var script$b = {
      name: 'ODatepickerTableRow',
      mixins: [BaseComponentMixin, DatepickerMixin],
      configField: 'datepicker',
      inject: {
        $datepicker: {
          name: '$datepicker',
          default: false
        }
      },
      props: {
        selectedDate: {
          type: [Date, Array]
        },
        hoveredDateRange: Array,
        day: {
          type: Number
        },
        week: {
          type: Array,
          required: true
        },
        month: {
          type: Number,
          required: true
        },
        showWeekNumber: Boolean,
        minDate: Date,
        maxDate: Date,
        disabled: Boolean,
        unselectableDates: Array,
        unselectableDaysOfWeek: Array,
        selectableDates: Array,
        events: Array,
        indicators: String,
        dateCreator: Function,
        nearbyMonthDays: Boolean,
        nearbySelectableMonthDays: Boolean,
        weekNumberClickable: Boolean,
        range: Boolean,
        multiple: Boolean,
        rulesForFirstWeek: Number,
        firstDayOfWeek: Number,
        tableRowClass: [String, Function, Array],
        tableCellClass: [String, Function, Array],
        tableCellSelectedClass: [String, Function, Array],
        tableCellFirstSelectedClass: [String, Function, Array],
        tableCellWithinSelectedClass: [String, Function, Array],
        tableCellLastSelectedClass: [String, Function, Array],
        tableCellFirstHoveredClass: [String, Function, Array],
        tableCellInvisibleClass: [String, Function, Array],
        tableCellWithinHoveredClass: [String, Function, Array],
        tableCellLastHoveredClass: [String, Function, Array],
        tableCellTodayClass: [String, Function, Array],
        tableCellSelectableClass: [String, Function, Array],
        tableCellUnselectableClass: [String, Function, Array],
        tableCellNearbyClass: [String, Function, Array],
        tableCellEventsClass: [String, Function, Array],
        tableEventClass: [String, Function, Array],
        tableEventIndicatorsClass: [String, Function, Array],
        tableEventsClass: [String, Function, Array],
        tableEventVariantClass: [String, Function, Array]
      },
      computed: {
        tableRowClasses() {
          return [this.computedClass('tableRowClass', 'o-dpck__table__row')];
        },

        tableCellClasses() {
          return [this.computedClass('tableCellClass', 'o-dpck__table__cell')];
        },

        tableEventsClasses() {
          return [this.computedClass('tableEventsClass', 'o-dpck__table__events')];
        },

        hasEvents() {
          return this.events && this.events.length;
        }

      },
      watch: {
        day(day) {
          const refName = `day-${this.month}-${day}`;
          this.$nextTick(() => {
            if (this.$refs[refName] && this.$refs[refName].length > 0) {
              if (this.$refs[refName][0]) {
                this.$refs[refName][0].focus();
              }
            }
          }); // $nextTick needed when month is changed
        }

      },
      methods: {
        firstWeekOffset(year, dow, doy) {
          // first-week day -- which january is always in the first week (4 for iso, 1 for other)
          const fwd = 7 + dow - doy; // first-week day local weekday -- which local weekday is fwd

          const firstJanuary = new Date(year, 0, fwd);
          const fwdlw = (7 + firstJanuary.getDay() - dow) % 7;
          return -fwdlw + fwd - 1;
        },

        daysInYear(year) {
          return this.isLeapYear(year) ? 366 : 365;
        },

        isLeapYear(year) {
          return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        },

        getSetDayOfYear(input) {
          return Math.round((input - new Date(input.getFullYear(), 0, 1)) / 864e5) + 1;
        },

        weeksInYear(year, dow, doy) {
          const weekOffset = this.firstWeekOffset(year, dow, doy);
          const weekOffsetNext = this.firstWeekOffset(year + 1, dow, doy);
          return (this.daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        },

        getWeekNumber(mom) {
          const dow = this.firstDayOfWeek; // first day of week
          // Rules for the first week : 1 for the 1st January, 4 for the 4th January

          const doy = this.rulesForFirstWeek;
          const weekOffset = this.firstWeekOffset(mom.getFullYear(), dow, doy);
          const week = Math.floor((this.getSetDayOfYear(mom) - weekOffset - 1) / 7) + 1;
          let resWeek;
          let resYear;

          if (week < 1) {
            resYear = mom.getFullYear() - 1;
            resWeek = week + this.weeksInYear(resYear, dow, doy);
          } else if (week > this.weeksInYear(mom.getFullYear(), dow, doy)) {
            resWeek = week - this.weeksInYear(mom.getFullYear(), dow, doy);
            resYear = mom.getFullYear() + 1;
          } else {
            resYear = mom.getFullYear();
            resWeek = week;
          }

          return resWeek;
        },

        clickWeekNumber(week) {
          if (this.weekNumberClickable) {
            this.$datepicker.$emit('week-number-click', week);
          }
        },

        /*
         * Check that selected day is within earliest/latest params and
         * is within this month
         */
        selectableDate(day) {
          const validity = [];

          if (this.minDate) {
            validity.push(day >= this.minDate);
          }

          if (this.maxDate) {
            validity.push(day <= this.maxDate);
          }

          if (this.nearbyMonthDays && !this.nearbySelectableMonthDays) {
            validity.push(day.getMonth() === this.month);
          }

          if (this.selectableDates) {
            for (let i = 0; i < this.selectableDates.length; i++) {
              const enabledDate = this.selectableDates[i];

              if (day.getDate() === enabledDate.getDate() && day.getFullYear() === enabledDate.getFullYear() && day.getMonth() === enabledDate.getMonth()) {
                return true;
              } else {
                validity.push(false);
              }
            }
          }

          if (this.unselectableDates) {
            for (let i = 0; i < this.unselectableDates.length; i++) {
              const disabledDate = this.unselectableDates[i];
              validity.push(day.getDate() !== disabledDate.getDate() || day.getFullYear() !== disabledDate.getFullYear() || day.getMonth() !== disabledDate.getMonth());
            }
          }

          if (this.unselectableDaysOfWeek) {
            for (let i = 0; i < this.unselectableDaysOfWeek.length; i++) {
              const dayOfWeek = this.unselectableDaysOfWeek[i];
              validity.push(day.getDay() !== dayOfWeek);
            }
          }

          return validity.indexOf(false) < 0;
        },

        /*
        * Emit select event with chosen date as payload
        */
        emitChosenDate(day) {
          if (this.disabled) return;

          if (this.selectableDate(day)) {
            this.$emit('select', day);
          }
        },

        eventsDateMatch(day) {
          if (!this.events || !this.events.length) return false;
          const dayEvents = [];

          for (let i = 0; i < this.events.length; i++) {
            if (this.events[i].date.getDay() === day.getDay()) {
              dayEvents.push(this.events[i]);
            }
          }

          if (!dayEvents.length) {
            return false;
          }

          return dayEvents;
        },

        /*
        * Build cellClasses for cell using validations
        */
        cellClasses(day) {
          function dateMatch(dateOne, dateTwo, multiple = false) {
            // if either date is null or undefined, return false
            // if using multiple flag, return false
            if (!dateOne || !dateTwo || multiple) {
              return false;
            }

            if (Array.isArray(dateTwo)) {
              return dateTwo.some(date => dateOne.getDate() === date.getDate() && dateOne.getFullYear() === date.getFullYear() && dateOne.getMonth() === date.getMonth());
            }

            return dateOne.getDate() === dateTwo.getDate() && dateOne.getFullYear() === dateTwo.getFullYear() && dateOne.getMonth() === dateTwo.getMonth();
          }

          function dateWithin(dateOne, dates, multiple = false) {
            if (!Array.isArray(dates) || multiple) {
              return false;
            }

            return dateOne > dates[0] && dateOne < dates[1];
          }

          return [...this.tableCellClasses, {
            [this.computedClass('tableCellSelectedClass', 'o-dpck__table__cell--selected')]: dateMatch(day, this.selectedDate) || dateWithin(day, this.selectedDate, this.multiple)
          }, {
            [this.computedClass('tableCellFirstSelectedClass', 'o-dpck__table__cell--first-selected')]: dateMatch(day, Array.isArray(this.selectedDate) && this.selectedDate[0], this.multiple)
          }, {
            [this.computedClass('tableCellWithinSelectedClass', 'o-dpck__table__cell--within-selected')]: dateWithin(day, this.selectedDate, this.multiple)
          }, {
            [this.computedClass('tableCellLastSelectedClass', 'o-dpck__table__cell--last-selected')]: dateMatch(day, Array.isArray(this.selectedDate) && this.selectedDate[1], this.multiple)
          }, {
            [this.computedClass('tableCellFirstHoveredClass', 'o-dpck__table__cell--first-hovered')]: dateMatch(day, Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[0])
          }, {
            [this.computedClass('tableCellWithinHoveredClass', 'o-dpck__table__cell--within-hovered')]: dateWithin(day, this.hoveredDateRange)
          }, {
            [this.computedClass('tableCellLastHoveredClass', 'o-dpck__table__cell--last-hovered')]: dateMatch(day, Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[1])
          }, {
            [this.computedClass('tableCellTodayClass', 'o-dpck__table__cell--today')]: dateMatch(day, this.dateCreator())
          }, {
            [this.computedClass('tableCellSelectableClass', 'o-dpck__table__cell--selectable')]: this.selectableDate(day) && !this.disabled
          }, {
            [this.computedClass('tableCellUnselectableClass', 'o-dpck__table__cell--unselectable')]: !this.selectableDate(day) || this.disabled
          }, {
            [this.computedClass('tableCellInvisibleClass', 'o-dpck__table__cell--invisible')]: !this.nearbyMonthDays && day.getMonth() !== this.month
          }, {
            [this.computedClass('tableCellNearbyClass', 'o-dpck__table__cell--nearby')]: this.nearbySelectableMonthDays && day.getMonth() !== this.month
          }, {
            [this.computedClass('tableCellEventsClass', 'o-dpck__table__cell--events')]: this.hasEvents
          }, {
            [this.computedClass('tableCellTodayClass', 'o-dpck__table__cell--today')]: dateMatch(day, this.dateCreator())
          }];
        },

        eventClasses(event) {
          return [this.computedClass('tableEventClass', 'o-dpck__table__event'), {
            [this.computedClass('tableEventVariantClass', 'o-dpck__table__event--', event.type)]: event.type
          }, {
            [this.computedClass('tableEventIndicatorsClass', 'o-dpck__table__event--', this.indicators)]: this.indicators
          }];
        },

        setRangeHoverEndDate(day) {
          if (this.range) {
            this.$emit('rangeHoverEndDate', day);
          }
        },

        changeFocus(day, inc) {
          const nextDay = new Date(day.getTime());
          nextDay.setDate(day.getDate() + inc);

          while ((!this.minDate || nextDay > this.minDate) && (!this.maxDate || nextDay < this.maxDate) && !this.selectableDate(nextDay)) {
            nextDay.setDate(day.getDate() + Math.sign(inc));
          }

          this.setRangeHoverEndDate(nextDay);
          this.$emit('change-focus', nextDay);
        }

      }
    };

    /* script */
    const __vue_script__$b = script$b;

    /* template */
    var __vue_render__$a = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.tableRowClasses},[(_vm.showWeekNumber)?_c('a',{class:_vm.tableCellClasses,style:({'cursor: pointer': _vm.weekNumberClickable }),on:{"click":function($event){$event.preventDefault();_vm.clickWeekNumber(_vm.getWeekNumber(_vm.week[6]));}}},[_c('span',[_vm._v(_vm._s(_vm.getWeekNumber(_vm.week[6])))])]):_vm._e(),_vm._l((_vm.week),function(weekDay,index){return [(_vm.selectableDate(weekDay) && !_vm.disabled)?_c('a',{key:index,ref:("day-" + (weekDay.getMonth()) + "-" + (weekDay.getDate())),refInFor:true,class:_vm.cellClasses(weekDay),attrs:{"role":"button","href":"#","disabled":_vm.disabled,"tabindex":_vm.day === weekDay.getDate() && _vm.month === weekDay.getMonth() ? null : -1},on:{"click":function($event){$event.preventDefault();return _vm.emitChosenDate(weekDay)},"mouseenter":function($event){return _vm.setRangeHoverEndDate(weekDay)},"keydown":function($event){return _vm.manageKeydown($event, weekDay)}}},[_c('span',[_vm._v(_vm._s(weekDay.getDate()))]),(_vm.eventsDateMatch(weekDay))?_c('div',{class:_vm.tableEventsClasses},_vm._l((_vm.eventsDateMatch(weekDay)),function(event,index){return _c('div',{key:index,class:_vm.eventClasses(event)})}),0):_vm._e()]):_c('div',{key:index,class:_vm.cellClasses(weekDay)},[_c('span',[_vm._v(_vm._s(weekDay.getDate()))])])]})],2)};
    var __vue_staticRenderFns__$a = [];

      /* style */
      const __vue_inject_styles__$b = undefined;
      /* scoped */
      const __vue_scope_id__$b = undefined;
      /* module identifier */
      const __vue_module_identifier__$b = undefined;
      /* functional template */
      const __vue_is_functional_template__$b = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$b = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$a, staticRenderFns: __vue_staticRenderFns__$a },
        __vue_inject_styles__$b,
        __vue_script__$b,
        __vue_scope_id__$b,
        __vue_is_functional_template__$b,
        __vue_module_identifier__$b,
        false,
        undefined,
        undefined,
        undefined
      );

    //
    var script$c = {
      name: 'ODatepickerTable',
      mixins: [BaseComponentMixin],
      configField: 'datepicker',
      components: {
        [__vue_component__$b.name]: __vue_component__$b
      },
      props: {
        value: {
          type: [Date, Array]
        },
        dayNames: Array,
        monthNames: Array,
        firstDayOfWeek: Number,
        events: Array,
        indicators: String,
        minDate: Date,
        maxDate: Date,
        focused: Object,
        disabled: Boolean,
        dateCreator: Function,
        unselectableDates: Array,
        unselectableDaysOfWeek: Array,
        selectableDates: Array,
        nearbyMonthDays: Boolean,
        nearbySelectableMonthDays: Boolean,
        showWeekNumber: Boolean,
        weekNumberClickable: Boolean,
        rulesForFirstWeek: Number,
        range: Boolean,
        multiple: Boolean,
        tableClass: [String, Function, Array],
        tableHeadClass: [String, Function, Array],
        tableHeadCellClass: [String, Function, Array],
        tableBodyClass: [String, Function, Array],
        tableRowClass: [String, Function, Array],
        tableCellClass: [String, Function, Array],
        tableCellSelectedClass: [String, Function, Array],
        tableCellFirstSelectedClass: [String, Function, Array],
        tableCellInvisibleClass: [String, Function, Array],
        tableCellWithinSelectedClass: [String, Function, Array],
        tableCellLastSelectedClass: [String, Function, Array],
        tableCellFirstHoveredClass: [String, Function, Array],
        tableCellWithinHoveredClass: [String, Function, Array],
        tableCellLastHoveredClass: [String, Function, Array],
        tableCellTodayClass: [String, Function, Array],
        tableCellSelectableClass: [String, Function, Array],
        tableCellUnselectableClass: [String, Function, Array],
        tableCellNearbyClass: [String, Function, Array],
        tableCellEventsClass: [String, Function, Array],
        tableEventClass: [String, Function, Array],
        tableEventIndicatorsClass: [String, Function, Array],
        tableEventsClass: [String, Function, Array],
        tableEventVariantClass: [String, Function, Array]
      },

      data() {
        return {
          selectedBeginDate: undefined,
          selectedEndDate: undefined,
          hoveredEndDate: undefined
        };
      },

      computed: {
        tableClasses() {
          return [this.computedClass('tableClass', 'o-dpck__table')];
        },

        tableHeadClasses() {
          return [this.computedClass('tableHeadClass', 'o-dpck__table__head')];
        },

        tableHeadCellClasses() {
          return [this.computedClass('tableHeadCellClass', 'o-dpck__table__head-cell'), ...this.tableCellClasses];
        },

        tableBodyClasses() {
          return [this.computedClass('tableBodyClass', 'o-dpck__table__body')];
        },

        tableCellClasses() {
          return [this.computedClass('tableCellClass', 'o-dpck__table__cell')];
        },

        visibleDayNames() {
          const visibleDayNames = [];
          let index = this.firstDayOfWeek;

          while (visibleDayNames.length < this.dayNames.length) {
            const currentDayName = this.dayNames[index % this.dayNames.length];
            visibleDayNames.push(currentDayName);
            index++;
          }

          if (this.showWeekNumber) visibleDayNames.unshift('');
          return visibleDayNames;
        },

        /*
        * Return array of all events in the specified month
        */
        eventsInThisMonth() {
          if (!this.events) return [];
          const monthEvents = [];

          for (let i = 0; i < this.events.length; i++) {
            let event = this.events[i];

            if (!Object.prototype.hasOwnProperty.call(event, 'date')) {
              event = {
                date: event
              };
            }

            if (event.date.getMonth() === this.focused.month && event.date.getFullYear() === this.focused.year) {
              monthEvents.push(event);
            }
          }

          return monthEvents;
        },

        /*
        * Return array of all weeks in the specified month
        */
        weeksInThisMonth() {
          this.validateFocusedDay();
          const month = this.focused.month;
          const year = this.focused.year;
          const weeksInThisMonth = [];
          let startingDay = 1;

          while (weeksInThisMonth.length < 6) {
            const newWeek = this.weekBuilder(startingDay, month, year);
            weeksInThisMonth.push(newWeek);
            startingDay += 7;
          }

          return weeksInThisMonth;
        },

        hoveredDateRange() {
          if (!this.range) {
            return [];
          }

          if (!isNaN(this.selectedEndDate)) {
            return [];
          }

          if (this.hoveredEndDate < this.selectedBeginDate) {
            return [this.hoveredEndDate, this.selectedBeginDate].filter(d => d !== undefined);
          }

          return [this.selectedBeginDate, this.hoveredEndDate].filter(d => d !== undefined);
        }

      },
      methods: {
        /*
        * Emit input event with selected date as payload for v-model in parent
        */
        updateSelectedDate(date) {
          if (!this.range && !this.multiple) {
            this.$emit('input', date);
          } else if (this.range) {
            this.handleSelectRangeDate(date);
          } else if (this.multiple) {
            this.handleSelectMultipleDates(date);
          }
        },

        /*
        * If both begin and end dates are set, reset the end date and set the begin date.
        * If only begin date is selected, emit an array of the begin date and the new date.
        * If not set, only set the begin date.
        */
        handleSelectRangeDate(date) {
          if (this.selectedBeginDate && this.selectedEndDate) {
            this.selectedBeginDate = date;
            this.selectedEndDate = undefined;
            this.$emit('range-start', date);
          } else if (this.selectedBeginDate && !this.selectedEndDate) {
            if (this.selectedBeginDate > date) {
              this.selectedEndDate = this.selectedBeginDate;
              this.selectedBeginDate = date;
            } else {
              this.selectedEndDate = date;
            }

            this.$emit('range-end', date);
            this.$emit('input', [this.selectedBeginDate, this.selectedEndDate]);
          } else {
            this.selectedBeginDate = date;
            this.$emit('range-start', date);
          }
        },

        /*
        * If selected date already exists list of selected dates, remove it from the list
        * Otherwise, add date to list of selected dates
        */
        handleSelectMultipleDates(date) {
          let multipleSelectedDates = this.value;
          const multipleSelect = multipleSelectedDates.filter(selectedDate => selectedDate.getDate() === date.getDate() && selectedDate.getFullYear() === date.getFullYear() && selectedDate.getMonth() === date.getMonth());

          if (multipleSelect.length) {
            multipleSelectedDates = multipleSelectedDates.filter(selectedDate => selectedDate.getDate() !== date.getDate() || selectedDate.getFullYear() !== date.getFullYear() || selectedDate.getMonth() !== date.getMonth());
          } else {
            multipleSelectedDates = [...multipleSelectedDates, date];
          }

          this.$emit('input', multipleSelectedDates);
        },

        /*
         * Return array of all days in the week that the startingDate is within
         */
        weekBuilder(startingDate, month, year) {
          const thisMonth = new Date(year, month);
          const thisWeek = [];
          const dayOfWeek = new Date(year, month, startingDate).getDay();
          const end = dayOfWeek >= this.firstDayOfWeek ? dayOfWeek - this.firstDayOfWeek : 7 - this.firstDayOfWeek + dayOfWeek;
          let daysAgo = 1;

          for (let i = 0; i < end; i++) {
            thisWeek.unshift(new Date(thisMonth.getFullYear(), thisMonth.getMonth(), startingDate - daysAgo));
            daysAgo++;
          }

          thisWeek.push(new Date(year, month, startingDate));
          let daysForward = 1;

          while (thisWeek.length < 7) {
            thisWeek.push(new Date(year, month, startingDate + daysForward));
            daysForward++;
          }

          return thisWeek;
        },

        validateFocusedDay() {
          const focusedDate = new Date(this.focused.year, this.focused.month, this.focused.day);
          if (this.selectableDate(focusedDate)) return;
          let day = 0; // Number of days in the current month

          const monthDays = new Date(this.focused.year, this.focused.month + 1, 0).getDate();
          let firstFocusable = null;

          while (!firstFocusable && ++day < monthDays) {
            const date = new Date(this.focused.year, this.focused.month, day);

            if (this.selectableDate(date)) {
              firstFocusable = focusedDate;
              const focused = {
                day: date.getDate(),
                month: date.getMonth(),
                year: date.getFullYear()
              };
              this.$emit('update:focused', focused);
            }
          }
        },

        /*
         * Check that selected day is within earliest/latest params and
         * is within this month
         */
        selectableDate(day) {
          const validity = [];

          if (this.minDate) {
            validity.push(day >= this.minDate);
          }

          if (this.maxDate) {
            validity.push(day <= this.maxDate);
          }

          if (this.nearbyMonthDays && !this.nearbySelectableMonthDays) {
            validity.push(day.getMonth() === this.focused.month);
          }

          if (this.selectableDates) {
            for (let i = 0; i < this.selectableDates.length; i++) {
              const enabledDate = this.selectableDates[i];

              if (day.getDate() === enabledDate.getDate() && day.getFullYear() === enabledDate.getFullYear() && day.getMonth() === enabledDate.getMonth()) {
                return true;
              } else {
                validity.push(false);
              }
            }
          }

          if (this.unselectableDates) {
            for (let i = 0; i < this.unselectableDates.length; i++) {
              const disabledDate = this.unselectableDates[i];
              validity.push(day.getDate() !== disabledDate.getDate() || day.getFullYear() !== disabledDate.getFullYear() || day.getMonth() !== disabledDate.getMonth());
            }
          }

          if (this.unselectableDaysOfWeek) {
            for (let i = 0; i < this.unselectableDaysOfWeek.length; i++) {
              const dayOfWeek = this.unselectableDaysOfWeek[i];
              validity.push(day.getDay() !== dayOfWeek);
            }
          }

          return validity.indexOf(false) < 0;
        },

        eventsInThisWeek(week) {
          return this.eventsInThisMonth.filter(event => {
            const stripped = new Date(Date.parse(event.date));
            stripped.setHours(0, 0, 0, 0);
            const timed = stripped.getTime();
            return week.some(weekDate => weekDate.getTime() === timed);
          });
        },

        setRangeHoverEndDate(day) {
          this.hoveredEndDate = day;
        },

        changeFocus(day) {
          const focused = {
            day: day.getDate(),
            month: day.getMonth(),
            year: day.getFullYear()
          };
          this.$emit('update:focused', focused);
        }

      }
    };

    /* script */
    const __vue_script__$c = script$c;

    /* template */
    var __vue_render__$b = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('section',{class:_vm.tableClasses},[_c('header',{class:_vm.tableHeadClasses},_vm._l((_vm.visibleDayNames),function(day,index){return _c('div',{key:index,class:_vm.tableHeadCellClasses},[_c('span',[_vm._v(_vm._s(day))])])}),0),_c('div',{class:_vm.tableBodyClasses},_vm._l((_vm.weeksInThisMonth),function(week,index){return _c('o-datepicker-table-row',{key:index,attrs:{"selected-date":_vm.value,"day":_vm.focused.day,"week":week,"month":_vm.focused.month,"min-date":_vm.minDate,"max-date":_vm.maxDate,"disabled":_vm.disabled,"unselectable-dates":_vm.unselectableDates,"unselectable-days-of-week":_vm.unselectableDaysOfWeek,"selectable-dates":_vm.selectableDates,"events":_vm.eventsInThisWeek(week),"indicators":_vm.indicators,"date-creator":_vm.dateCreator,"nearby-month-days":_vm.nearbyMonthDays,"nearby-selectable-month-days":_vm.nearbySelectableMonthDays,"show-week-number":_vm.showWeekNumber,"week-number-clickable":_vm.weekNumberClickable,"first-day-of-week":_vm.firstDayOfWeek,"rules-for-first-week":_vm.rulesForFirstWeek,"range":_vm.range,"hovered-date-range":_vm.hoveredDateRange,"multiple":_vm.multiple,"table-row-class":_vm.tableRowClass,"table-cell-class":_vm.tableCellClass,"table-cell-selected-class":_vm.tableCellSelectedClass,"table-cell-first-selected-class":_vm.tableCellFirstSelectedClass,"table-cell-invisible-class":_vm.tableCellInvisibleClass,"table-cell-within-selected-class":_vm.tableCellWithinSelectedClass,"table-cell-last-selected-class":_vm.tableCellLastSelectedClass,"table-cell-first-hovered-class":_vm.tableCellFirstHoveredClass,"table-cell-within-hovered-class":_vm.tableCellWithinHoveredClass,"table-cell-last-hovered-class":_vm.tableCellLastHoveredClass,"table-cell-today-class":_vm.tableCellTodayClass,"table-cell-selectable-class":_vm.tableCellSelectableClass,"table-cell-unselectable-class":_vm.tableCellUnselectableClass,"table-cell-nearby-class":_vm.tableCellNearbyClass,"table-cell-events-class":_vm.tableCellEventsClass,"table-events-class":_vm.tableEventsClass,"table-event-variant-class":_vm.tableEventVariantClass,"table-event-class":_vm.tableEventClass,"table-event-indicators-class":_vm.tableEventIndicatorsClass},on:{"select":_vm.updateSelectedDate,"rangeHoverEndDate":_vm.setRangeHoverEndDate,"change-focus":_vm.changeFocus}})}),1)])};
    var __vue_staticRenderFns__$b = [];

      /* style */
      const __vue_inject_styles__$c = undefined;
      /* scoped */
      const __vue_scope_id__$c = undefined;
      /* module identifier */
      const __vue_module_identifier__$c = undefined;
      /* functional template */
      const __vue_is_functional_template__$c = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$c = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$b, staticRenderFns: __vue_staticRenderFns__$b },
        __vue_inject_styles__$c,
        __vue_script__$c,
        __vue_scope_id__$c,
        __vue_is_functional_template__$c,
        __vue_module_identifier__$c,
        false,
        undefined,
        undefined,
        undefined
      );

    //
    var script$d = {
      name: 'ODatepickerMonth',
      mixins: [BaseComponentMixin, DatepickerMixin],
      configField: 'datepicker',
      props: {
        value: {
          type: [Date, Array]
        },
        monthNames: Array,
        events: Array,
        indicators: String,
        minDate: Date,
        maxDate: Date,
        focused: Object,
        disabled: Boolean,
        dateCreator: Function,
        unselectableDates: [Array, Function],
        unselectableDaysOfWeek: Array,
        selectableDates: [Array, Function],
        range: Boolean,
        multiple: Boolean,
        monthClass: [String, Function, Array],
        monthBodyClass: [String, Function, Array],
        monthTableClass: [String, Function, Array],
        monthCellClass: [String, Function, Array],
        monthCellSelectedClass: [String, Function, Array],
        monthCellFirstSelectedClass: [String, Function, Array],
        monthCellWithinSelectedClass: [String, Function, Array],
        monthCellLastSelectedClass: [String, Function, Array],
        monthCellWithinHoveredRangeClass: [String, Function, Array],
        monthCellFirstHoveredClass: [String, Function, Array],
        monthCellWithinHoveredClass: [String, Function, Array],
        monthCellLastHoveredClass: [String, Function, Array],
        monthCellTodayClass: [String, Function, Array],
        monthCellSelectableClass: [String, Function, Array],
        monthCellUnselectableClass: [String, Function, Array],
        monthCellEventsClass: [String, Function, Array]
      },

      data() {
        return {
          selectedBeginDate: undefined,
          selectedEndDate: undefined,
          hoveredEndDate: undefined,
          multipleSelectedDates: this.multiple && this.value ? this.value : []
        };
      },

      computed: {
        monthClasses() {
          return [this.computedClass('monthClass', 'o-dpck__month')];
        },

        monthBodyClasses() {
          return [this.computedClass('monthBodyClass', 'o-dpck__month__body')];
        },

        monthTableClasses() {
          return [this.computedClass('monthTableClass', 'o-dpck__month__table')];
        },

        monthCellClasses() {
          return [this.computedClass('monthCellClass', 'o-dpck__month__cell')];
        },

        hasEvents() {
          return this.events && this.events.length;
        },

        /*
        * Return array of all events in the specified month
        */
        eventsInThisYear() {
          if (!this.events) return [];
          const yearEvents = [];

          for (let i = 0; i < this.events.length; i++) {
            let event = this.events[i];

            if (!Object.prototype.hasOwnProperty.call(event, 'date')) {
              event = {
                date: event
              };
            }

            if (!Object.prototype.hasOwnProperty.call(event, 'type')) {
              event.type = 'is-primary';
            }

            if (event.date.getFullYear() === this.focused.year) {
              yearEvents.push(event);
            }
          }

          return yearEvents;
        },

        monthDates() {
          const year = this.focused.year;
          const months = [];

          for (let i = 0; i < 12; i++) {
            const d = new Date(year, i, 1);
            d.setHours(0, 0, 0, 0);
            months.push(d);
          }

          return months;
        },

        focusedMonth() {
          return this.focused.month;
        },

        hoveredDateRange() {
          if (!this.range) {
            return [];
          }

          if (!isNaN(this.selectedEndDate)) {
            return [];
          }

          if (this.hoveredEndDate < this.selectedBeginDate) {
            return [this.hoveredEndDate, this.selectedBeginDate].filter(isDefined);
          }

          return [this.selectedBeginDate, this.hoveredEndDate].filter(isDefined);
        }

      },
      watch: {
        focusedMonth(month) {
          const refName = `month-${month}`;

          if (this.$refs[refName] && this.$refs[refName].length > 0) {
            this.$nextTick(() => {
              if (this.$refs[refName][0]) {
                this.$refs[refName][0].focus();
              }
            }); // $nextTick needed when year is changed
          }
        }

      },
      methods: {
        selectMultipleDates(date) {
          const multipleSelect = this.multipleSelectedDates.filter(selectedDate => selectedDate.getDate() === date.getDate() && selectedDate.getFullYear() === date.getFullYear() && selectedDate.getMonth() === date.getMonth());

          if (multipleSelect.length) {
            this.multipleSelectedDates = this.multipleSelectedDates.filter(selectedDate => selectedDate.getDate() !== date.getDate() || selectedDate.getFullYear() !== date.getFullYear() || selectedDate.getMonth() !== date.getMonth());
          } else {
            this.multipleSelectedDates.push(date);
          }

          this.$emit('input', this.multipleSelectedDates);
        },

        selectableDate(day) {
          const validity = [];

          if (this.minDate) {
            validity.push(day >= this.minDate);
          }

          if (this.maxDate) {
            validity.push(day <= this.maxDate);
          }

          validity.push(day.getFullYear() === this.focused.year);

          if (this.selectableDates) {
            if (typeof this.selectableDates === 'function') {
              if (this.selectableDates(day)) {
                return true;
              } else {
                validity.push(false);
              }
            } else {
              for (let i = 0; i < this.selectableDates.length; i++) {
                const enabledDate = this.selectableDates[i];

                if (day.getFullYear() === enabledDate.getFullYear() && day.getMonth() === enabledDate.getMonth()) {
                  return true;
                } else {
                  validity.push(false);
                }
              }
            }
          }

          if (this.unselectableDates) {
            if (typeof this.unselectableDates === 'function') {
              validity.push(!this.unselectableDates(day));
            } else {
              for (let i = 0; i < this.unselectableDates.length; i++) {
                const disabledDate = this.unselectableDates[i];
                validity.push(day.getFullYear() !== disabledDate.getFullYear() || day.getMonth() !== disabledDate.getMonth());
              }
            }
          }

          if (this.unselectableDaysOfWeek) {
            for (let i = 0; i < this.unselectableDaysOfWeek.length; i++) {
              const dayOfWeek = this.unselectableDaysOfWeek[i];
              validity.push(day.getDay() !== dayOfWeek);
            }
          }

          return validity.indexOf(false) < 0;
        },

        eventsDateMatch(day) {
          if (!this.eventsInThisYear.length) return false;
          const monthEvents = [];

          for (let i = 0; i < this.eventsInThisYear.length; i++) {
            if (this.eventsInThisYear[i].date.getMonth() === day.getMonth()) {
              monthEvents.push(this.events[i]);
            }
          }

          if (!monthEvents.length) {
            return false;
          }

          return monthEvents;
        },

        /*
        * Build cellClasses for cell using validations
        */
        cellClasses(day) {
          function dateMatch(dateOne, dateTwo, multiple) {
            // if either date is null or undefined, return false
            if (!dateOne || !dateTwo || multiple) {
              return false;
            }

            if (Array.isArray(dateTwo)) {
              return dateTwo.some(date => dateOne.getFullYear() === date.getFullYear() && dateOne.getMonth() === date.getMonth());
            }

            return dateOne.getFullYear() === dateTwo.getFullYear() && dateOne.getMonth() === dateTwo.getMonth();
          }

          function dateWithin(dateOne, dates, multiple) {
            if (!Array.isArray(dates) || multiple) {
              return false;
            }

            return dateOne > dates[0] && dateOne < dates[1];
          }

          function dateMultipleSelected(dateOne, dates, multiple) {
            if (!Array.isArray(dates) || !multiple) {
              return false;
            }

            return dates.some(date => dateOne.getDate() === date.getDate() && dateOne.getFullYear() === date.getFullYear() && dateOne.getMonth() === date.getMonth());
          }

          return [...this.monthCellClasses, {
            [this.computedClass('monthCellSelectedClass', 'o-dpck__month__cell--selected')]: dateMatch(day, this.value, this.multiple) || dateWithin(day, this.value, this.multiple) || dateMultipleSelected(day, this.multipleSelectedDates, this.multiple)
          }, {
            [this.computedClass('monthCellFirstSelectedClass', 'o-dpck__month__cell--first-selected')]: dateMatch(day, Array.isArray(this.value) && this.value[0], this.multiple)
          }, {
            [this.computedClass('monthCellWithinSelectedClass', 'o-dpck__month__cell--within-selected')]: dateWithin(day, this.value, this.multiple)
          }, {
            [this.computedClass('monthCellLastSelectedClass', 'o-dpck__month__cell--last-selected')]: dateMatch(day, Array.isArray(this.value) && this.value[1], this.multiple)
          }, {
            [this.computedClass('monthCellWithinHoveredRangeClass', 'o-dpck__month__cell--within-hovered-range')]: this.hoveredDateRange && this.hoveredDateRange.length === 2 && (dateMatch(day, this.hoveredDateRange) || dateWithin(day, this.hoveredDateRange))
          }, {
            [this.computedClass('monthCellFirstHoveredClass', 'o-dpck__month__cell--first-hovered')]: dateMatch(day, Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[0])
          }, {
            [this.computedClass('monthCellWithinHoveredClass', 'o-dpck__month__cell--within-hovered')]: dateWithin(day, this.hoveredDateRange)
          }, {
            [this.computedClass('monthCellLastHoveredClass', 'o-dpck__month__cell--last-hovered')]: dateMatch(day, Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[1])
          }, {
            [this.computedClass('monthCellTodayClass', 'o-dpck__month__cell--today')]: dateMatch(day, this.dateCreator())
          }, {
            [this.computedClass('monthCellSelectableclass', 'o-dpck__month__cell--selectable')]: this.selectableDate(day) && !this.disabled
          }, {
            [this.computedClass('monthCellUnselectableClass', 'o-dpck__month__cell--unselectable')]: !this.selectableDate(day) || this.disabled
          }, {
            [this.computedClass('monthCellEventsClass', 'o-dpck__month__cell--events')]: this.hasEvents
          }];
        },

        /*
         * Emit input event with selected date as payload for v-model in parent
         */
        updateSelectedDate(date) {
          if (!this.range && !this.multiple) {
            this.emitChosenDate(date);
          } else if (this.range) {
            this.handleSelectRangeDate(date);
          } else if (this.multiple) {
            this.selectMultipleDates(date);
          }
        },

        /*
         * Emit select event with chosen date as payload
         */
        emitChosenDate(day) {
          if (this.disabled) return;

          if (!this.multiple) {
            if (this.selectableDate(day)) {
              this.$emit('input', day);
            }
          } else {
            this.selectMultipleDates(day);
          }
        },

        /*
        * If both begin and end dates are set, reset the end date and set the begin date.
        * If only begin date is selected, emit an array of the begin date and the new date.
        * If not set, only set the begin date.
        */
        handleSelectRangeDate(date) {
          if (this.disabled) return;

          if (this.selectedBeginDate && this.selectedEndDate) {
            this.selectedBeginDate = date;
            this.selectedEndDate = undefined;
            this.$emit('range-start', date);
          } else if (this.selectedBeginDate && !this.selectedEndDate) {
            if (this.selectedBeginDate > date) {
              this.selectedEndDate = this.selectedBeginDate;
              this.selectedBeginDate = date;
            } else {
              this.selectedEndDate = date;
            }

            this.$emit('range-end', date);
            this.$emit('input', [this.selectedBeginDate, this.selectedEndDate]);
          } else {
            this.selectedBeginDate = date;
            this.$emit('range-start', date);
          }
        },

        setRangeHoverEndDate(day) {
          if (this.range) {
            this.hoveredEndDate = day;
          }
        },

        changeFocus(month, inc) {
          const nextMonth = month;
          nextMonth.setMonth(month.getMonth() + inc);
          this.$emit('change-focus', nextMonth);
        }

      }
    };

    /* script */
    const __vue_script__$d = script$d;

    /* template */
    var __vue_render__$c = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('section',{class:_vm.monthClasses},[_c('div',{class:_vm.monthBodyClasses},[_c('div',{class:_vm.monthTableClasses},[_vm._l((_vm.monthDates),function(date,index){return [(_vm.selectableDate(date) && !_vm.disabled)?_c('a',{key:index,ref:("month-" + (date.getMonth())),refInFor:true,class:_vm.cellClasses(date),attrs:{"role":"button","href":"#","disabled":_vm.disabled,"tabindex":_vm.focused.month === date.getMonth() ? null : -1},on:{"click":function($event){$event.preventDefault();return _vm.updateSelectedDate(date)},"mouseenter":function($event){return _vm.setRangeHoverEndDate(date)},"keydown":function($event){$event.preventDefault();return _vm.manageKeydown($event, date)}}},[_vm._v(" "+_vm._s(_vm.monthNames[date.getMonth()])+" "),(_vm.eventsDateMatch(date))?_c('div',{staticClass:"events"},_vm._l((_vm.eventsDateMatch(date)),function(event,index){return _c('div',{key:index,staticClass:"event",class:event.type})}),0):_vm._e()]):_c('div',{key:index,class:_vm.cellClasses(date)},[_vm._v(" "+_vm._s(_vm.monthNames[date.getMonth()])+" ")])]})],2)])])};
    var __vue_staticRenderFns__$c = [];

      /* style */
      const __vue_inject_styles__$d = undefined;
      /* scoped */
      const __vue_scope_id__$d = undefined;
      /* module identifier */
      const __vue_module_identifier__$d = undefined;
      /* functional template */
      const __vue_is_functional_template__$d = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$d = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$c, staticRenderFns: __vue_staticRenderFns__$c },
        __vue_inject_styles__$d,
        __vue_script__$d,
        __vue_scope_id__$d,
        __vue_is_functional_template__$d,
        __vue_module_identifier__$d,
        false,
        undefined,
        undefined,
        undefined
      );

    //

    const defaultDateFormatter = (date, vm) => {
      const targetDates = Array.isArray(date) ? date : [date];
      const dates = targetDates.map(date => {
        const d = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12);
        return !vm.isTypeMonth ? vm.dtf.format(d) : vm.dtfMonth.format(d);
      });
      return !vm.multiple ? dates.join(' - ') : dates.join(', ');
    };

    const defaultDateParser = (date, vm) => {
      if (vm.dtf.formatToParts && typeof vm.dtf.formatToParts === 'function') {
        const formatRegex = (vm.isTypeMonth ? vm.dtfMonth : vm.dtf).formatToParts(new Date(2000, 11, 25)).map(part => {
          if (part.type === 'literal') {
            return part.value;
          }

          return `((?!=<${part.type}>)\\d+)`;
        }).join('');
        const dateGroups = matchWithGroups(formatRegex, date); // We do a simple validation for the group.
        // If it is not valid, it will fallback to Date.parse below

        if (dateGroups.year && dateGroups.year.length === 4 && dateGroups.month && dateGroups.month <= 12) {
          if (vm.isTypeMonth) return new Date(dateGroups.year, dateGroups.month - 1);else if (dateGroups.day && dateGroups.day <= 31) {
            return new Date(dateGroups.year, dateGroups.month - 1, dateGroups.day, 12);
          }
        }
      } // Fallback if formatToParts is not supported or if we were not able to parse a valid date


      if (!vm.isTypeMonth) return new Date(Date.parse(date));

      if (date) {
        const s = date.split('/');
        const year = s[0].length === 4 ? s[0] : s[1];
        const month = s[0].length === 2 ? s[0] : s[1];

        if (year && month) {
          return new Date(parseInt(year, 10), parseInt(month, 10) - 1, 1, 0, 0, 0, 0);
        }
      }

      return null;
    };
    /**
     * An input with a simple dropdown/modal for selecting a date, uses native datepicker for mobile
     * @displayName Datepicker
     * @example ./examples/Datepicker.md
     * @style _datepicker.scss
     */


    var script$e = {
      name: 'ODatepicker',
      components: {
        [__vue_component__$c.name]: __vue_component__$c,
        [__vue_component__$d.name]: __vue_component__$d,
        [__vue_component__$1.name]: __vue_component__$1,
        [__vue_component__$a.name]: __vue_component__$a,
        [__vue_component__.name]: __vue_component__,
        [__vue_component__$8.name]: __vue_component__$8,
        [__vue_component__$9.name]: __vue_component__$9
      },
      configField: 'datepicker',
      mixins: [BaseComponentMixin, FormElementMixin, MatchMediaMixin],
      inheritAttrs: false,

      provide() {
        return {
          $datepicker: this
        };
      },

      props: {
        /** @model */
        value: {
          type: [Date, Array]
        },

        /* Names of days to display in table header */
        dayNames: {
          type: Array,
          default: () => {
            return getValueByPath(getOptions(), 'datepicker.dayNames', undefined);
          }
        },

        /* Names of months to display in table header */
        monthNames: {
          type: Array,
          default: () => {
            return getValueByPath(getOptions(), 'datepicker.monthNames', undefined);
          }
        },

        /**
         * First day of week to display in table header (getDay() of Date Object)
         * @values 0, 1, 2, 3, 4, 5, 6
         */
        firstDayOfWeek: {
          type: Number,
          default: () => {
            return getValueByPath(getOptions(), 'datepicker.firstDayOfWeek', 0);
          }
        },

        /**
         * Size of button, optional
         * @values small, medium, large
         */
        size: String,

        /* Datepicker is shown inline, input is removed */
        inline: Boolean,

        /* Earliest date available for selection */
        minDate: Date,

        /* Latest date available for selection */
        maxDate: Date,

        /* Date that should be initially focused upon */
        focusedDate: Date,
        placeholder: String,

        /* Enable input/typing. Note that you might have to set a custom date parser */
        editable: Boolean,
        disabled: Boolean,

        /* Array or function of unselectable dates */
        unselectableDates: [Array, Function],

        /* Array of unselectable days of week */
        unselectableDaysOfWeek: {
          type: Array,
          default: () => {
            return getValueByPath(getOptions(), 'datepicker.unselectableDaysOfWeek', undefined);
          }
        },

        /* Array or function of selectable dates */
        selectableDates: [Array, Function],

        /* Function to format date to a string for display in the input */
        dateFormatter: {
          type: Function,
          default: (date, vm) => {
            const dateFormatter = getValueByPath(getOptions(), 'datepicker.dateFormatter', undefined);

            if (typeof dateFormatter === 'function') {
              return dateFormatter(date);
            } else {
              return defaultDateFormatter(date, vm);
            }
          }
        },

        /* Function to parse string to a date for set a date from the input to the component */
        dateParser: {
          type: Function,
          default: (date, vm) => {
            const dateParser = getValueByPath(getOptions(), 'datepicker.dateParser', undefined);

            if (typeof dateParser === 'function') {
              return dateParser(date);
            } else {
              return defaultDateParser(date, vm);
            }
          }
        },

        /* Function used internally to create a new Date instance */
        dateCreator: {
          type: Function,
          default: () => {
            const dateCreator = getValueByPath(getOptions(), 'datepicker.dateCreator', undefined);

            if (typeof dateCreator === 'function') {
              return dateCreator();
            } else {
              return new Date();
            }
          }
        },

        /* Enable native datepicker on mobile */
        mobileNative: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'datepicker.mobileNative', true);
          }
        },

        /**
         * Optional, position of the datepicker relative to the input
         * @values top-right, top-left, bottom-left
         */
        position: String,

        /**
         * 	Icon name to be added on the right side
         */
        iconRight: String,

        /**
         * Make the icon right clickable
         */
        iconRightClickable: Boolean,

        /* Dates to display indicators */
        events: Array,

        /* Shape to use when showing event indicators */
        indicators: {
          type: String,
          default: 'dots'
        },

        /* Open datepicker on input focus */
        openOnFocus: Boolean,

        /* Icon to use for previous month */
        iconPrev: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'datepicker.iconPrev', 'chevron-left');
          }
        },

        /* Icon to use for next month */
        iconNext: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'datepicker.iconNext', 'chevron-right');
          }
        },

        /* Years range relative to selected year */
        yearsRange: {
          type: Array,
          default: () => {
            return getValueByPath(getOptions(), 'datepicker.yearsRange', [-100, 10]);
          }
        },
        type: {
          type: String,
          validator: value => {
            return ['month'].indexOf(value) >= 0;
          }
        },

        /* Show/Hide nearby month days (prev and next month) */
        nearbyMonthDays: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'datepicker.nearbyMonthDays', true);
          }
        },

        /* When nearby-month-days, it allows to select/unselect nearby month days */
        nearbySelectableMonthDays: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'datepicker.nearbySelectableMonthDays', false);
          }
        },

        /* Display week number */
        showWeekNumber: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'datepicker.showWeekNumber', false);
          }
        },

        /* Enable click on week number */
        weekNumberClickable: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'datepicker.weekNumberClickable', false);
          }
        },

        /* Choose the rule to determinate the first week of Year, 4 for ISO or 1 for other */
        rulesForFirstWeek: {
          type: Number,
          default: () => 4
        },

        /* Flag to allow choosing a range of date */
        range: {
          type: Boolean,
          default: false
        },

        /* Choose whether the Datepicker should close after selecting a date */
        closeOnClick: {
          type: Boolean,
          default: true
        },

        /* Flag to allow choosing multiple dates */
        multiple: {
          type: Boolean,
          default: false
        },

        /* Datepicker is shown into a modal on mobile */
        mobileModal: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'datepicker.mobileModal', true);
          }
        },

        /* Trap focus inside the datepicker */
        trapFocus: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'datepicker.trapFocus', true);
          }
        },

        /* Accept a string with a BCP 47 language tag, or an array of such strings. See Unicode BCP 47 locale identifier */
        locale: {
          type: [String, Array],
          default: () => {
            return getValueByPath(getOptions(), 'locale');
          }
        },

        /* Append datepicker calendar to body */
        appendToBody: Boolean,

        /* Accessibility label for the next month button */
        ariaNextLabel: String,

        /* Accessibility label for the prev month button */
        ariaPreviousLabel: String,
        rootClass: [String, Function, Array],
        sizeClass: [String, Function, Array],
        boxClass: [String, Function, Array],
        headerClass: [String, Function, Array],
        headerButtonsClass: [String, Function, Array],
        headerButtonsSizeClass: [String, Function, Array],
        prevBtnClass: [String, Function, Array],
        nextBtnClass: [String, Function, Array],
        listsClass: [String, Function, Array],
        footerClass: [String, Function, Array],
        tableClass: [String, Function, Array],
        tableHeadClass: [String, Function, Array],
        tableHeadCellClass: [String, Function, Array],
        tableBodyClass: [String, Function, Array],
        tableRowClass: [String, Function, Array],
        tableCellClass: [String, Function, Array],
        tableCellSelectedClass: [String, Function, Array],
        tableCellFirstSelectedClass: [String, Function, Array],
        tableCellInvisibleClass: [String, Function, Array],
        tableCellWithinSelectedClass: [String, Function, Array],
        tableCellLastSelectedClass: [String, Function, Array],
        tableCellFirstHoveredClass: [String, Function, Array],
        tableCellWithinHoveredClass: [String, Function, Array],
        tableCellLastHoveredClass: [String, Function, Array],
        tableCellTodayClass: [String, Function, Array],
        tableCellSelectableClass: [String, Function, Array],
        tableCellUnselectableClass: [String, Function, Array],
        tableCellNearbyClass: [String, Function, Array],
        tableCellEventsClass: [String, Function, Array],
        tableEventsClass: [String, Function, Array],
        tableEventVariantClass: [String, Function, Array],
        tableEventClass: [String, Function, Array],
        tableEventIndicatorsClass: [String, Function, Array],
        mobileClass: [String, Function, Array],

        /* datapickermonth classes */
        monthClass: [String, Function, Array],
        monthBodyClass: [String, Function, Array],
        monthTableClass: [String, Function, Array],
        monthCellClass: [String, Function, Array],
        monthCellSelectedClass: [String, Function, Array],
        monthCellFirstSelectedClass: [String, Function, Array],
        monthCellWithinSelectedClass: [String, Function, Array],
        monthCellLastSelectedClass: [String, Function, Array],
        monthCellWithinHoveredRangeClass: [String, Function, Array],
        monthCellFirstHoveredClass: [String, Function, Array],
        monthCellWithinHoveredClass: [String, Function, Array],
        monthCellLastHoveredClass: [String, Function, Array],
        monthCellTodayClass: [String, Function, Array],
        monthCellSelectableClass: [String, Function, Array],
        monthCellUnselectableClass: [String, Function, Array],
        monthCellEventsClass: [String, Function, Array],
        inputClasses: {
          type: Object,
          default: () => {
            return getValueByPath(getOptions(), 'datepicker.inputClasses', {});
          }
        },
        dropdownClasses: {
          type: Object,
          default: () => {
            return getValueByPath(getOptions(), 'datepicker.dropdownClasses', {});
          }
        },
        selectListClasses: Object
      },

      data() {
        const focusedDate = (Array.isArray(this.value) ? this.value[0] : this.value) || this.focusedDate || this.dateCreator();

        if (!this.value && this.maxDate && this.maxDate.getFullYear() < focusedDate.getFullYear()) {
          focusedDate.setFullYear(this.maxDate.getFullYear());
        }

        return {
          dateSelected: this.value,
          focusedDateData: {
            day: focusedDate.getDate(),
            month: focusedDate.getMonth(),
            year: focusedDate.getFullYear()
          }
        };
      },

      computed: {
        inputBind() {
          return { ...this.$attrs,
            ...this.inputClasses
          };
        },

        dropdownBind() {
          return {
            'root-class': this.computedClass('dropdownClasses.rootClass', 'o-dpck__dropdown'),
            ...this.dropdownClasses
          };
        },

        selectListBind() {
          return { ...this.selectListClasses
          };
        },

        rootClasses() {
          return [this.computedClass('rootClass', 'o-dpck'), {
            [this.computedClass('sizeClass', 'o-dpck--', this.size)]: this.size
          }, {
            [this.computedClass('mobileClass', 'o-dpck--mobile')]: this.isMatchMedia
          }];
        },

        boxClasses() {
          return [this.computedClass('boxClass', 'o-dpck__box')];
        },

        headerClasses() {
          return [this.computedClass('headerClass', 'o-dpck__header')];
        },

        headerButtonsClasses() {
          return [this.computedClass('headerButtonsClass', 'o-dpck__header__buttons'), {
            [this.computedClass('headerButtonsSizeClass', 'o-dpck__header__buttons--', this.size)]: this.size
          }];
        },

        prevBtnClasses() {
          return [this.computedClass('prevBtnClass', 'o-dpck__header__previous')];
        },

        nextBtnClasses() {
          return [this.computedClass('nextBtnClass', 'o-dpck__header__next')];
        },

        listsClasses() {
          return [this.computedClass('listsClass', 'o-dpck__header__list')];
        },

        footerClasses() {
          return [this.computedClass('footerClass', 'o-dpck__footer')];
        },

        computedValue: {
          get() {
            return this.dateSelected;
          },

          set(value) {
            this.updateInternalState(value);
            if (!this.multiple) this.togglePicker(false);
            this.$emit('input', value);

            if (this.useHtml5Validation) {
              this.$nextTick(() => {
                this.checkHtml5Validity();
              });
            }
          }

        },

        formattedValue() {
          return this.formatValue(this.computedValue);
        },

        localeOptions() {
          return new Intl.DateTimeFormat(this.locale, {
            year: 'numeric',
            month: 'numeric'
          }).resolvedOptions();
        },

        dtf() {
          return new Intl.DateTimeFormat(this.locale
          /*, { timeZone: 'UTC' } */
          );
        },

        dtfMonth() {
          return new Intl.DateTimeFormat(this.locale, {
            year: this.localeOptions.year || 'numeric',
            month: this.localeOptions.month || '2-digit' // timeZone: 'UTC'

          });
        },

        newMonthNames() {
          if (Array.isArray(this.monthNames)) {
            return this.monthNames;
          }

          return getMonthNames(this.locale);
        },

        newDayNames() {
          if (Array.isArray(this.dayNames)) {
            return this.dayNames;
          }

          return getWeekdayNames(this.locale);
        },

        listOfMonths() {
          let minMonth = 0;
          let maxMonth = 12;

          if (this.minDate && this.focusedDateData.year === this.minDate.getFullYear()) {
            minMonth = this.minDate.getMonth();
          }

          if (this.maxDate && this.focusedDateData.year === this.maxDate.getFullYear()) {
            maxMonth = this.maxDate.getMonth();
          }

          return this.newMonthNames.map((name, index) => {
            return {
              name: name,
              index: index,
              disabled: index < minMonth || index > maxMonth
            };
          });
        },

        /*
         * Returns an array of years for the year dropdown. If earliest/latest
         * dates are set by props, range of years will fall within those dates.
         */
        listOfYears() {
          let latestYear = this.focusedDateData.year + this.yearsRange[1];

          if (this.maxDate && this.maxDate.getFullYear() < latestYear) {
            latestYear = Math.max(this.maxDate.getFullYear(), this.focusedDateData.year);
          }

          let earliestYear = this.focusedDateData.year + this.yearsRange[0];

          if (this.minDate && this.minDate.getFullYear() > earliestYear) {
            earliestYear = Math.min(this.minDate.getFullYear(), this.focusedDateData.year);
          }

          const arrayOfYears = [];

          for (let i = earliestYear; i <= latestYear; i++) {
            arrayOfYears.push(i);
          }

          return arrayOfYears.reverse();
        },

        showPrev() {
          if (!this.minDate) return false;

          if (this.isTypeMonth) {
            return this.focusedDateData.year <= this.minDate.getFullYear();
          }

          const dateToCheck = new Date(this.focusedDateData.year, this.focusedDateData.month);
          const date = new Date(this.minDate.getFullYear(), this.minDate.getMonth());
          return dateToCheck <= date;
        },

        showNext() {
          if (!this.maxDate) return false;

          if (this.isTypeMonth) {
            return this.focusedDateData.year >= this.maxDate.getFullYear();
          }

          const dateToCheck = new Date(this.focusedDateData.year, this.focusedDateData.month);
          const date = new Date(this.maxDate.getFullYear(), this.maxDate.getMonth());
          return dateToCheck >= date;
        },

        isMobile() {
          return this.mobileNative && isMobile.any();
        },

        isTypeMonth() {
          return this.type === 'month';
        },

        ariaRole() {
          return !this.inline ? 'dialog' : undefined;
        },

        $elementRef() {
          return 'input';
        }

      },
      watch: {
        /**
         * When v-model is changed:
         *   1. Update internal value.
         *   2. If it's invalid, validate again.
         */
        value(value) {
          this.updateInternalState(value);
          if (!this.multiple) this.togglePicker(false);
        },

        focusedDate(value) {
          if (value) {
            this.focusedDateData = {
              day: value.getDate(),
              month: value.getMonth(),
              year: value.getFullYear()
            };
          }
        },

        /*
         * Emit input event on month and/or year change
         */
        'focusedDateData.month'(value) {
          this.$emit('change-month', value);
        },

        'focusedDateData.year'(value) {
          this.$emit('change-year', value);
        }

      },
      methods: {
        /*
         * Parse string into date
         */
        onChange(value) {
          const date = this.dateParser(value, this);

          if (date && (!isNaN(date) || Array.isArray(date) && date.length === 2 && !isNaN(date[0]) && !isNaN(date[1]))) {
            this.computedValue = date;
          } else {
            // Force refresh input value when not valid date
            this.computedValue = null;

            if (this.$refs.input) {
              this.$refs.input.newValue = this.computedValue;
            }
          }
        },

        /*
         * Format date into string
         */
        formatValue(value) {
          if (Array.isArray(value)) {
            const isArrayWithValidDates = Array.isArray(value) && value.every(v => !isNaN(v));
            return isArrayWithValidDates ? this.dateFormatter([...value], this) : null;
          }

          return value && !isNaN(value) ? this.dateFormatter(value, this) : null;
        },

        /*
         * Either decrement month by 1 if not January or decrement year by 1
         * and set month to 11 (December) or decrement year when 'month'
         */
        prev() {
          if (this.disabled) return;

          if (this.isTypeMonth) {
            this.focusedDateData.year -= 1;
          } else {
            if (this.focusedDateData.month > 0) {
              this.focusedDateData.month -= 1;
            } else {
              this.focusedDateData.month = 11;
              this.focusedDateData.year -= 1;
            }
          }
        },

        /*
         * Either increment month by 1 if not December or increment year by 1
         * and set month to 0 (January) or increment year when 'month'
         */
        next() {
          if (this.disabled) return;

          if (this.isTypeMonth) {
            this.focusedDateData.year += 1;
          } else {
            if (this.focusedDateData.month < 11) {
              this.focusedDateData.month += 1;
            } else {
              this.focusedDateData.month = 0;
              this.focusedDateData.year += 1;
            }
          }
        },

        formatNative(value) {
          return this.isTypeMonth ? this.formatYYYYMM(value) : this.formatYYYYMMDD(value);
        },

        /*
         * Format date into string 'YYYY-MM-DD'
         */
        formatYYYYMMDD(value) {
          const date = new Date(value);

          if (value && !isNaN(date.getTime())) {
            const year = date.getFullYear();
            const month = date.getMonth() + 1;
            const day = date.getDate();
            return year + '-' + ((month < 10 ? '0' : '') + month) + '-' + ((day < 10 ? '0' : '') + day);
          }

          return '';
        },

        /*
         * Format date into string 'YYYY-MM'
         */
        formatYYYYMM(value) {
          const date = new Date(value);

          if (value && !isNaN(date.getTime())) {
            const year = date.getFullYear();
            const month = date.getMonth() + 1;
            return year + '-' + ((month < 10 ? '0' : '') + month);
          }

          return '';
        },

        /*
         * Parse date from string
         */
        onChangeNativePicker(event) {
          const date = event.target.value;
          const s = date ? date.split('-') : [];

          if (s.length === 3) {
            const year = parseInt(s[0], 10);
            const month = parseInt(s[1]) - 1;
            const day = parseInt(s[2]);
            this.computedValue = new Date(year, month, day);
          } else {
            this.computedValue = null;
          }
        },

        updateInternalState(value) {
          if (this.dateSelected === value) return;
          const isArray = Array.isArray(value);
          const currentDate = isArray ? !value.length ? this.dateCreator() : value[value.length - 1] : !value ? this.dateCreator() : value;

          if (!isArray || isArray && this.dateSelected && value.length > this.dateSelected.length) {
            this.focusedDateData = {
              day: currentDate.getDate(),
              month: currentDate.getMonth(),
              year: currentDate.getFullYear()
            };
          }

          this.dateSelected = value;
        },

        /*
         * Toggle datepicker
         */
        togglePicker(active) {
          if (this.$refs.dropdown) {
            const isActive = typeof active === 'boolean' ? active : !this.$refs.dropdown.isActive;

            if (isActive) {
              this.$refs.dropdown.isActive = isActive;
            } else if (this.closeOnClick) {
              this.$refs.dropdown.isActive = isActive;
            }
          }
        },

        /*
         * Call default onFocus method and show datepicker
         */
        handleOnFocus(event) {
          this.onFocus(event);

          if (this.openOnFocus) {
            this.togglePicker(true);
          }
        },

        /*
         * Toggle dropdown
         */
        toggle() {
          if (this.mobileNative && this.isMobile) {
            const input = this.$refs.input.$refs.input;
            input.focus();
            input.click();
            return;
          }

          this.$refs.dropdown.toggle();
        },

        /*
         * Avoid dropdown toggle when is already visible
         */
        onInputClick(event) {
          if (this.$refs.dropdown.isActive) {
            event.stopPropagation();
          }
        },

        /**
         * Keypress event that is bound to the document.
         */
        keyPress({
          key
        }) {
          if (this.$refs.dropdown && this.$refs.dropdown.isActive && (key === 'Escape' || key === 'Esc')) {
            this.togglePicker(false);
          }
        },

        /**
         * Emit 'blur' event on dropdown is not active (closed)
         */
        onActiveChange(value) {
          if (!value) {
            this.onBlur();
          }

          this.$emit('active-change', value);
        },

        changeFocus(day) {
          this.focusedDateData = {
            day: day.getDate(),
            month: day.getMonth(),
            year: day.getFullYear()
          };
        }

      },

      created() {
        if (typeof window !== 'undefined') {
          document.addEventListener('keyup', this.keyPress);
        }
      },

      beforeDestroy() {
        if (typeof window !== 'undefined') {
          document.removeEventListener('keyup', this.keyPress);
        }
      }

    };

    /* script */
    const __vue_script__$e = script$e;

    /* template */
    var __vue_render__$d = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.rootClasses},[(!_vm.isMobile || _vm.inline)?_c('o-dropdown',_vm._b({ref:"dropdown",attrs:{"position":_vm.position,"disabled":_vm.disabled,"inline":_vm.inline,"mobile-modal":_vm.mobileModal,"trap-focus":_vm.trapFocus,"aria-role":_vm.ariaRole,"aria-modal":!_vm.inline,"trigger-tabindex":-1,"append-to-body":_vm.appendToBody,"append-to-body-copy-parent":""},on:{"active-change":_vm.onActiveChange},scopedSlots:_vm._u([(!_vm.inline)?{key:"trigger",fn:function(){return [_vm._t("trigger",[_c('o-input',_vm._b({ref:"input",attrs:{"autocomplete":"off","value":_vm.formattedValue,"expanded":_vm.expanded,"placeholder":_vm.placeholder,"size":_vm.size,"icon":_vm.icon,"icon-right":_vm.iconRight,"icon-right-clickable":_vm.iconRightClickable,"icon-pack":_vm.iconPack,"rounded":_vm.rounded,"disabled":_vm.disabled,"readonly":!_vm.editable,"use-html5-validation":false},on:{"icon-right-click":function($event){return _vm.$emit('icon-right-click')},"focus":_vm.handleOnFocus},nativeOn:{"click":function($event){return _vm.onInputClick($event)},"keyup":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.togglePicker(true)},"change":function($event){return _vm.onChange($event.target.value)}}},'o-input',_vm.inputBind,false))])]},proxy:true}:null],null,true)},'o-dropdown',_vm.dropdownBind,false),[_c('o-dropdown-item',{attrs:{"override":"","tag":"div","item-class":_vm.boxClasses,"disabled":_vm.disabled,"clickable":false}},[_c('header',{class:_vm.headerClasses},[_vm._t("header",[_c('div',{class:_vm.headerButtonsClasses},[_c('a',{directives:[{name:"show",rawName:"v-show",value:(!_vm.showPrev && !_vm.disabled),expression:"!showPrev && !disabled"}],class:_vm.prevBtnClasses,attrs:{"role":"button","href":"#","disabled":_vm.disabled,"aria-label":_vm.ariaPreviousLabel},on:{"click":function($event){$event.preventDefault();return _vm.prev($event)},"keydown":[function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }$event.preventDefault();return _vm.prev($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"space",32,$event.key,[" ","Spacebar"])){ return null; }$event.preventDefault();return _vm.prev($event)}]}},[_c('o-icon',{attrs:{"icon":_vm.iconPrev,"pack":_vm.iconPack,"both":"","clickable":""}})],1),_c('a',{directives:[{name:"show",rawName:"v-show",value:(!_vm.showNext && !_vm.disabled),expression:"!showNext && !disabled"}],class:_vm.nextBtnClasses,attrs:{"role":"button","href":"#","disabled":_vm.disabled,"aria-label":_vm.ariaNextLabel},on:{"click":function($event){$event.preventDefault();return _vm.next($event)},"keydown":[function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }$event.preventDefault();return _vm.next($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"space",32,$event.key,[" ","Spacebar"])){ return null; }$event.preventDefault();return _vm.next($event)}]}},[_c('o-icon',{attrs:{"icon":_vm.iconNext,"pack":_vm.iconPack,"both":"","clickable":""}})],1),_c('div',{class:_vm.listsClasses},[(!_vm.isTypeMonth)?_c('o-select',_vm._b({attrs:{"disabled":_vm.disabled,"size":_vm.size},model:{value:(_vm.focusedDateData.month),callback:function ($$v) {_vm.$set(_vm.focusedDateData, "month", $$v);},expression:"focusedDateData.month"}},'o-select',_vm.selectListBind,false),_vm._l((_vm.listOfMonths),function(month){return _c('option',{key:month.name,attrs:{"disabled":month.disabled},domProps:{"value":month.index}},[_vm._v(" "+_vm._s(month.name)+" ")])}),0):_vm._e(),_c('o-select',_vm._b({attrs:{"disabled":_vm.disabled,"size":_vm.size},model:{value:(_vm.focusedDateData.year),callback:function ($$v) {_vm.$set(_vm.focusedDateData, "year", $$v);},expression:"focusedDateData.year"}},'o-select',_vm.selectListBind,false),_vm._l((_vm.listOfYears),function(year){return _c('option',{key:year,domProps:{"value":year}},[_vm._v(" "+_vm._s(year)+" ")])}),0)],1)])])],2),_vm._t("table",[(!_vm.isTypeMonth)?_c('o-datepicker-table',{attrs:{"day-names":_vm.newDayNames,"month-names":_vm.newMonthNames,"first-day-of-week":_vm.firstDayOfWeek,"rules-for-first-week":_vm.rulesForFirstWeek,"min-date":_vm.minDate,"max-date":_vm.maxDate,"focused":_vm.focusedDateData,"disabled":_vm.disabled,"unselectable-dates":_vm.unselectableDates,"unselectable-days-of-week":_vm.unselectableDaysOfWeek,"selectable-dates":_vm.selectableDates,"events":_vm.events,"indicators":_vm.indicators,"date-creator":_vm.dateCreator,"type-month":_vm.isTypeMonth,"nearby-month-days":_vm.nearbyMonthDays,"nearby-selectable-month-days":_vm.nearbySelectableMonthDays,"show-week-number":_vm.showWeekNumber,"week-number-clickable":_vm.weekNumberClickable,"range":_vm.range,"multiple":_vm.multiple,"table-class":_vm.tableClass,"table-head-class":_vm.tableHeadClass,"table-head-cell-class":_vm.tableHeadCellClass,"table-body-class":_vm.tableBodyClass,"table-row-class":_vm.tableRowClass,"table-cell-class":_vm.tableCellClass,"table-cell-selected-class":_vm.tableCellSelectedClass,"table-cell-first-selected-class":_vm.tableCellFirstSelectedClass,"table-cell-invisible-class":_vm.tableCellInvisibleClass,"table-cell-within-selected-class":_vm.tableCellWithinSelectedClass,"table-cell-last-selected-class":_vm.tableCellLastSelectedClass,"table-cell-first-hovered-class":_vm.tableCellFirstHoveredClass,"table-cell-within-hovered-class":_vm.tableCellWithinHoveredClass,"table-cell-last-hovered-class":_vm.tableCellLastHoveredClass,"table-cell-today-class":_vm.tableCellTodayClass,"table-cell-selectable-class":_vm.tableCellSelectableClass,"table-cell-unselectable-class":_vm.tableCellUnselectableClass,"table-cell-nearby-class":_vm.tableCellNearbyClass,"table-cell-events-class":_vm.tableCellEventsClass,"table-events-class":_vm.tableEventsClass,"table-event-variant-class":_vm.tableEventVariantClass,"table-event-class":_vm.tableEventClass,"table-event-indicators-class":_vm.tableEventIndicatorsClass},on:{"range-start":function (date) { return _vm.$emit('range-start', date); },"range-end":function (date) { return _vm.$emit('range-end', date); },"close":function($event){return _vm.togglePicker(false)},"update:focused":function($event){_vm.focusedDateData = $event;}},model:{value:(_vm.computedValue),callback:function ($$v) {_vm.computedValue=$$v;},expression:"computedValue"}}):_vm._e(),(_vm.isTypeMonth)?_c('o-datepicker-month',{attrs:{"month-names":_vm.newMonthNames,"min-date":_vm.minDate,"max-date":_vm.maxDate,"focused":_vm.focusedDateData,"disabled":_vm.disabled,"unselectable-dates":_vm.unselectableDates,"unselectable-days-of-week":_vm.unselectableDaysOfWeek,"selectable-dates":_vm.selectableDates,"events":_vm.events,"indicators":_vm.indicators,"date-creator":_vm.dateCreator,"range":_vm.range,"multiple":_vm.multiple,"month-class":_vm.monthClass,"month-body-class":_vm.monthBodyClass,"month-table-class":_vm.monthTableClass,"month-cell-class":_vm.monthCellClass,"month-cell-selected-class":_vm.monthCellSelectedClass,"month-cell-first-selected-class":_vm.monthCellFirstSelectedClass,"month-cell-within-selected-class":_vm.monthCellWithinSelectedClass,"month-cell-last-selected-class":_vm.monthCellLastSelectedClass,"month-cell-within-hovered-range-class":_vm.monthCellWithinHoveredRangeClass,"month-cell-first-hovered-class":_vm.monthCellFirstHoveredClass,"month-cell-within-hovered-class":_vm.monthCellWithinHoveredClass,"month-cell-last-hovered-class":_vm.monthCellLastHoveredClass,"month-cell-today-class":_vm.monthCellTodayClass,"month-cell-selectable-class":_vm.monthCellSelectableClass,"month-cell-unselectable-class":_vm.monthCellUnselectableClass,"month-cell-events-class":_vm.monthCellEventsClass},on:{"range-start":function (date) { return _vm.$emit('range-start', date); },"range-end":function (date) { return _vm.$emit('range-end', date); },"close":function($event){return _vm.togglePicker(false)},"change-focus":_vm.changeFocus,"update:focused":function($event){_vm.focusedDateData = $event;}},model:{value:(_vm.computedValue),callback:function ($$v) {_vm.computedValue=$$v;},expression:"computedValue"}}):_vm._e()]),(_vm.$slots.footer !== undefined)?_c('footer',{class:_vm.footerClasses},[_vm._t("footer")],2):_vm._e()],2)],1):_c('o-input',_vm._b({ref:"input",attrs:{"type":!_vm.isTypeMonth ? 'date' : 'month',"autocomplete":"off","value":_vm.formatNative(_vm.computedValue),"placeholder":_vm.placeholder,"size":_vm.size,"icon":_vm.icon,"icon-pack":_vm.iconPack,"rounded":_vm.rounded,"max":_vm.formatNative(_vm.maxDate),"min":_vm.formatNative(_vm.minDate),"disabled":_vm.disabled,"readonly":false,"use-html5-validation":false},on:{"focus":_vm.onFocus,"blur":_vm.onBlur,"invalid":_vm.onInvalid},nativeOn:{"change":function($event){return _vm.onChangeNativePicker($event)}}},'o-input',_vm.inputBind,false))],1)};
    var __vue_staticRenderFns__$d = [];

      /* style */
      const __vue_inject_styles__$e = undefined;
      /* scoped */
      const __vue_scope_id__$e = undefined;
      /* module identifier */
      const __vue_module_identifier__$e = undefined;
      /* functional template */
      const __vue_is_functional_template__$e = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$e = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$d, staticRenderFns: __vue_staticRenderFns__$d },
        __vue_inject_styles__$e,
        __vue_script__$e,
        __vue_scope_id__$e,
        __vue_is_functional_template__$e,
        __vue_module_identifier__$e,
        false,
        undefined,
        undefined,
        undefined
      );

    const Plugin$6 = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$e);
      }

    };
    use(Plugin$6);

    const AM = 'AM';
    const PM = 'PM';
    const HOUR_FORMAT_24 = '24';
    const HOUR_FORMAT_12 = '12';

    const defaultTimeFormatter = (date, vm) => {
      return vm.dtf.format(date);
    };

    const defaultTimeParser = (timeString, vm) => {
      if (timeString) {
        let d = null;

        if (vm.computedValue && !isNaN(vm.computedValue)) {
          d = new Date(vm.computedValue);
        } else {
          d = vm.timeCreator();
          d.setMilliseconds(0);
        }

        if (vm.dtf.formatToParts && typeof vm.dtf.formatToParts === 'function') {
          const formatRegex = vm.dtf.formatToParts(d).map(part => {
            if (part.type === 'literal') {
              return part.value.replace(/ /g, '\\s?');
            } else if (part.type === 'dayPeriod') {
              return `((?!=<${part.type}>)(${vm.amString}|${vm.pmString}|${AM}|${PM}|${AM.toLowerCase()}|${PM.toLowerCase()})?)`;
            }

            return `((?!=<${part.type}>)\\d+)`;
          }).join('');
          const timeGroups = matchWithGroups(formatRegex, timeString); // We do a simple validation for the group.
          // If it is not valid, it will fallback to Date.parse below

          timeGroups.hour = timeGroups.hour ? parseInt(timeGroups.hour, 10) : null;
          timeGroups.minute = timeGroups.minute ? parseInt(timeGroups.minute, 10) : null;
          timeGroups.second = timeGroups.second ? parseInt(timeGroups.second, 10) : null;

          if (timeGroups.hour && timeGroups.hour >= 0 && timeGroups.hour < 24 && timeGroups.minute && timeGroups.minute >= 0 && timeGroups.minute < 59) {
            if (timeGroups.dayPeriod && (timeGroups.dayPeriod.toLowerCase() === vm.pmString.toLowerCase() || timeGroups.dayPeriod.toLowerCase() === PM.toLowerCase()) && timeGroups.hour < 12) {
              timeGroups.hour += 12;
            }

            d.setHours(timeGroups.hour);
            d.setMinutes(timeGroups.minute);
            d.setSeconds(timeGroups.second || 0);
            return d;
          }
        } // Fallback if formatToParts is not supported or if we were not able to parse a valid date


        let am = false;

        if (vm.hourFormat === HOUR_FORMAT_12) {
          const dateString12 = timeString.split(' ');
          timeString = dateString12[0];
          am = dateString12[1] === vm.amString || dateString12[1] === AM;
        }

        const time = timeString.split(':');
        let hours = parseInt(time[0], 10);
        const minutes = parseInt(time[1], 10);
        const seconds = vm.enableSeconds ? parseInt(time[2], 10) : 0;

        if (isNaN(hours) || hours < 0 || hours > 23 || vm.hourFormat === HOUR_FORMAT_12 && (hours < 1 || hours > 12) || isNaN(minutes) || minutes < 0 || minutes > 59) {
          return null;
        }

        d.setSeconds(seconds);
        d.setMinutes(minutes);

        if (vm.hourFormat === HOUR_FORMAT_12) {
          if (am && hours === 12) {
            hours = 0;
          } else if (!am && hours !== 12) {
            hours += 12;
          }
        }

        d.setHours(hours);
        return new Date(d.getTime());
      }

      return null;
    };

    var TimepickerMixin = {
      mixins: [FormElementMixin],
      inheritAttrs: false,
      props: {
        /* @model */
        value: Date,

        /* Timepicker is shown inline, input is removed */
        inline: Boolean,

        /* Earliest time available for selection */
        minTime: Date,

        /* Latest time available for selection */
        maxTime: Date,
        placeholder: String,

        /* Enable input/typing. Note that you might have to set a custom time parser */
        editable: Boolean,
        disabled: Boolean,

        /**
         * Size of button, optional
         * @values small, medium, large
         */
        size: String,

        /**
         * Hour format for input and display
         * @values 12, 24
         */
        hourFormat: {
          type: String,
          validator: value => {
            return value === HOUR_FORMAT_24 || value === HOUR_FORMAT_12;
          }
        },

        /* Step hours for select component */
        incrementHours: {
          type: Number,
          default: 1
        },

        /* Step minutes for select component */
        incrementMinutes: {
          type: Number,
          default: 1
        },

        /* Step seconds for select component */
        incrementSeconds: {
          type: Number,
          default: 1
        },

        /* Function to format time (Date type) to a string for display in the input */
        timeFormatter: {
          type: Function,
          default: (date, vm) => {
            const timeFormatter = getValueByPath(getOptions(), 'timepicker.timeFormatter', undefined);

            if (typeof timeFormatter === 'function') {
              return timeFormatter(date);
            } else {
              return defaultTimeFormatter(date, vm);
            }
          }
        },

        /* Function to parse string to a time (Date type) for set a time from the input to the component */
        timeParser: {
          type: Function,
          default: (date, vm) => {
            const timeParser = getValueByPath(getOptions(), 'timepicker.timeParser', undefined);

            if (typeof timeParser === 'function') {
              return timeParser(date);
            } else {
              return defaultTimeParser(date, vm);
            }
          }
        },

        /* Enable native timepicker on mobile */
        mobileNative: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'timepicker.mobileNative', true);
          }
        },

        /* Function used internally to create a new Date instance */
        timeCreator: {
          type: Function,
          default: () => {
            const timeCreator = getValueByPath(getOptions(), 'timepicker.timeCreator', undefined);

            if (typeof timeCreator === 'function') {
              return timeCreator();
            } else {
              return new Date();
            }
          }
        },

        /**
         * Optional, position of the datepicker relative to the input
         * @values top-right, top-left, bottom-left
         */
        position: String,

        /* Array of unselectable times (Date object) */
        unselectableTimes: Array,

        /* Open timepicker on input focus */
        openOnFocus: Boolean,

        /* Show seconds picker */
        enableSeconds: Boolean,

        /* Default value when hours change */
        defaultMinutes: Number,

        /* Default value when hours or minutes change */
        defaultSeconds: Number,

        /* Append timepicker calendar to body */
        appendToBody: Boolean,

        /* Reset timepicker values on meridian change */
        resetOnMeridianChange: {
          type: Boolean,
          default: false
        }
      },

      data() {
        return {
          dateSelected: this.value,
          hoursSelected: null,
          minutesSelected: null,
          secondsSelected: null,
          meridienSelected: null,
          _elementRef: 'input'
        };
      },

      computed: {
        computedValue: {
          get() {
            return this.dateSelected;
          },

          set(value) {
            this.dateSelected = value;
            this.$emit('input', this.dateSelected);
          }

        },

        localeOptions() {
          return new Intl.DateTimeFormat(this.locale, {
            hour: 'numeric',
            minute: 'numeric',
            second: this.enableSeconds ? 'numeric' : undefined
          }).resolvedOptions();
        },

        dtf() {
          return new Intl.DateTimeFormat(this.locale, {
            hour: this.localeOptions.hour || 'numeric',
            minute: this.localeOptions.minute || 'numeric',
            second: this.enableSeconds ? this.localeOptions.second || 'numeric' : undefined,
            hourCycle: !this.isHourFormat24 ? 'h12' : 'h23'
          });
        },

        newHourFormat() {
          return this.hourFormat || (this.localeOptions.hour12 ? HOUR_FORMAT_12 : HOUR_FORMAT_24);
        },

        sampleTime() {
          let d = this.timeCreator();
          d.setHours(10);
          d.setSeconds(0);
          d.setMinutes(0);
          d.setMilliseconds(0);
          return d;
        },

        hourLiteral() {
          if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {
            let d = this.sampleTime;
            const parts = this.dtf.formatToParts(d);
            const literal = parts.find((part, idx) => idx > 0 && parts[idx - 1].type === 'hour');

            if (literal) {
              return literal.value;
            }
          }

          return ':';
        },

        minuteLiteral() {
          if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {
            let d = this.sampleTime;
            const parts = this.dtf.formatToParts(d);
            const literal = parts.find((part, idx) => idx > 0 && parts[idx - 1].type === 'minute');

            if (literal) {
              return literal.value;
            }
          }

          return ':';
        },

        secondLiteral() {
          if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {
            let d = this.sampleTime;
            const parts = this.dtf.formatToParts(d);
            const literal = parts.find((part, idx) => idx > 0 && parts[idx - 1].type === 'second');

            if (literal) {
              return literal.value;
            }
          }
        },

        amString() {
          if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {
            let d = this.sampleTime;
            d.setHours(10);
            const dayPeriod = this.dtf.formatToParts(d).find(part => part.type === 'dayPeriod');

            if (dayPeriod) {
              return dayPeriod.value;
            }
          }

          return AM;
        },

        pmString() {
          if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {
            let d = this.sampleTime;
            d.setHours(20);
            const dayPeriod = this.dtf.formatToParts(d).find(part => part.type === 'dayPeriod');

            if (dayPeriod) {
              return dayPeriod.value;
            }
          }

          return PM;
        },

        hours() {
          if (!this.incrementHours || this.incrementHours < 1) throw new Error('Hour increment cannot be null or less than 1.');
          const hours = [];
          const numberOfHours = this.isHourFormat24 ? 24 : 12;

          for (let i = 0; i < numberOfHours; i += this.incrementHours) {
            let value = i;
            let label = value;

            if (!this.isHourFormat24) {
              value = i + 1;
              label = value;

              if (this.meridienSelected === this.amString) {
                if (value === 12) {
                  value = 0;
                }
              } else if (this.meridienSelected === this.pmString) {
                if (value !== 12) {
                  value += 12;
                }
              }
            }

            hours.push({
              label: this.formatNumber(label),
              value: value
            });
          }

          return hours;
        },

        minutes() {
          if (!this.incrementMinutes || this.incrementMinutes < 1) throw new Error('Minute increment cannot be null or less than 1.');
          const minutes = [];

          for (let i = 0; i < 60; i += this.incrementMinutes) {
            minutes.push({
              label: this.formatNumber(i, true),
              value: i
            });
          }

          return minutes;
        },

        seconds() {
          if (!this.incrementSeconds || this.incrementSeconds < 1) throw new Error('Second increment cannot be null or less than 1.');
          const seconds = [];

          for (let i = 0; i < 60; i += this.incrementSeconds) {
            seconds.push({
              label: this.formatNumber(i, true),
              value: i
            });
          }

          return seconds;
        },

        meridiens() {
          return [this.amString, this.pmString];
        },

        isMobile() {
          return this.mobileNative && isMobile.any();
        },

        isHourFormat24() {
          return this.newHourFormat === HOUR_FORMAT_24;
        }

      },
      watch: {
        hourFormat() {
          if (this.hoursSelected !== null) {
            this.meridienSelected = this.hoursSelected >= 12 ? this.pmString : this.amString;
          }
        },

        locale() {
          // see updateInternalState default
          if (!this.value) {
            this.meridienSelected = this.amString;
          }
        },

        /**
         * When v-model is changed:
         *   1. Update internal value.
         *   2. If it's invalid, validate again.
         */
        value: {
          handler(value) {
            this.updateInternalState(value);
            !this.isValid && this.$refs.input.checkHtml5Validity();
          },

          immediate: true
        }
      },
      methods: {
        onMeridienChange(value) {
          if (this.hoursSelected !== null && this.resetOnMeridianChange) {
            this.hoursSelected = null;
            this.minutesSelected = null;
            this.secondsSelected = null;
            this.computedValue = null;
          } else if (this.hoursSelected !== null) {
            if (value === this.pmString) {
              this.hoursSelected += 12;
            } else if (value === this.amString) {
              this.hoursSelected -= 12;
            }
          }

          this.updateDateSelected(this.hoursSelected, this.minutesSelected, this.enableSeconds ? this.secondsSelected : 0, value);
        },

        onHoursChange(value) {
          if (!this.minutesSelected && typeof this.defaultMinutes !== 'undefined') {
            this.minutesSelected = this.defaultMinutes;
          }

          if (!this.secondsSelected && typeof this.defaultSeconds !== 'undefined') {
            this.secondsSelected = this.defaultSeconds;
          }

          this.updateDateSelected(parseInt(value, 10), this.minutesSelected, this.enableSeconds ? this.secondsSelected : 0, this.meridienSelected);
        },

        onMinutesChange(value) {
          if (!this.secondsSelected && this.defaultSeconds) {
            this.secondsSelected = this.defaultSeconds;
          }

          this.updateDateSelected(this.hoursSelected, parseInt(value, 10), this.enableSeconds ? this.secondsSelected : 0, this.meridienSelected);
        },

        onSecondsChange(value) {
          this.updateDateSelected(this.hoursSelected, this.minutesSelected, parseInt(value, 10), this.meridienSelected);
        },

        updateDateSelected(hours, minutes, seconds, meridiens) {
          if (hours != null && minutes != null && (!this.isHourFormat24 && meridiens !== null || this.isHourFormat24)) {
            let time = null;

            if (this.computedValue && !isNaN(this.computedValue)) {
              time = new Date(this.computedValue);
            } else {
              time = this.timeCreator();
              time.setMilliseconds(0);
            }

            time.setHours(hours);
            time.setMinutes(minutes);
            time.setSeconds(seconds);

            if (!isNaN(time.getTime())) {
              this.computedValue = new Date(time.getTime());
            }
          }
        },

        updateInternalState(value) {
          if (value) {
            this.hoursSelected = value.getHours();
            this.minutesSelected = value.getMinutes();
            this.secondsSelected = value.getSeconds();
            this.meridienSelected = value.getHours() >= 12 ? this.pmString : this.amString;
          } else {
            this.hoursSelected = null;
            this.minutesSelected = null;
            this.secondsSelected = null;
            this.meridienSelected = this.amString;
          }

          this.dateSelected = value;
        },

        isHourDisabled(hour) {
          let disabled = false;

          if (this.minTime) {
            const minHours = this.minTime.getHours();
            const noMinutesAvailable = this.minutes.every(minute => {
              return this.isMinuteDisabledForHour(hour, minute.value);
            });
            disabled = hour < minHours || noMinutesAvailable;
          }

          if (this.maxTime) {
            if (!disabled) {
              const maxHours = this.maxTime.getHours();
              disabled = hour > maxHours;
            }
          }

          if (this.unselectableTimes) {
            if (!disabled) {
              const unselectable = this.unselectableTimes.filter(time => {
                if (this.enableSeconds && this.secondsSelected !== null) {
                  return time.getHours() === hour && time.getMinutes() === this.minutesSelected && time.getSeconds() === this.secondsSelected;
                } else if (this.minutesSelected !== null) {
                  return time.getHours() === hour && time.getMinutes() === this.minutesSelected;
                }

                return false;
              });

              if (unselectable.length > 0) {
                disabled = true;
              } else {
                disabled = this.minutes.every(minute => {
                  return this.unselectableTimes.filter(time => {
                    return time.getHours() === hour && time.getMinutes() === minute.value;
                  }).length > 0;
                });
              }
            }
          }

          return disabled;
        },

        isMinuteDisabledForHour(hour, minute) {
          let disabled = false;

          if (this.minTime) {
            const minHours = this.minTime.getHours();
            const minMinutes = this.minTime.getMinutes();
            disabled = hour === minHours && minute < minMinutes;
          }

          if (this.maxTime) {
            if (!disabled) {
              const maxHours = this.maxTime.getHours();
              const maxMinutes = this.maxTime.getMinutes();
              disabled = hour === maxHours && minute > maxMinutes;
            }
          }

          return disabled;
        },

        isMinuteDisabled(minute) {
          let disabled = false;

          if (this.hoursSelected !== null) {
            if (this.isHourDisabled(this.hoursSelected)) {
              disabled = true;
            } else {
              disabled = this.isMinuteDisabledForHour(this.hoursSelected, minute);
            }

            if (this.unselectableTimes) {
              if (!disabled) {
                const unselectable = this.unselectableTimes.filter(time => {
                  if (this.enableSeconds && this.secondsSelected !== null) {
                    return time.getHours() === this.hoursSelected && time.getMinutes() === minute && time.getSeconds() === this.secondsSelected;
                  } else {
                    return time.getHours() === this.hoursSelected && time.getMinutes() === minute;
                  }
                });
                disabled = unselectable.length > 0;
              }
            }
          }

          return disabled;
        },

        isSecondDisabled(second) {
          let disabled = false;

          if (this.minutesSelected !== null) {
            if (this.isMinuteDisabled(this.minutesSelected)) {
              disabled = true;
            } else {
              if (this.minTime) {
                const minHours = this.minTime.getHours();
                const minMinutes = this.minTime.getMinutes();
                const minSeconds = this.minTime.getSeconds();
                disabled = this.hoursSelected === minHours && this.minutesSelected === minMinutes && second < minSeconds;
              }

              if (this.maxTime) {
                if (!disabled) {
                  const maxHours = this.maxTime.getHours();
                  const maxMinutes = this.maxTime.getMinutes();
                  const maxSeconds = this.maxTime.getSeconds();
                  disabled = this.hoursSelected === maxHours && this.minutesSelected === maxMinutes && second > maxSeconds;
                }
              }
            }

            if (this.unselectableTimes) {
              if (!disabled) {
                const unselectable = this.unselectableTimes.filter(time => {
                  return time.getHours() === this.hoursSelected && time.getMinutes() === this.minutesSelected && time.getSeconds() === second;
                });
                disabled = unselectable.length > 0;
              }
            }
          }

          return disabled;
        },

        isMeridienDisabled(meridienString) {
          const offset = meridienString == "AM" ? 0 : 12;

          for (let i = 0; i < 12; i++) {
            if (!this.isHourDisabled(i + offset)) {
              return false;
            }
          }

          return true;
        },

        /*
         * Parse string into date
         */
        onChange(value) {
          const date = this.timeParser(value, this);
          this.updateInternalState(date);

          if (date && !isNaN(date)) {
            this.computedValue = date;
          } else {
            // Force refresh input value when not valid date
            this.computedValue = null;
            this.$refs.input.newValue = this.computedValue;
          }
        },

        /*
         * Toggle timepicker
         */
        toggle(active) {
          if (this.$refs.dropdown) {
            this.$refs.dropdown.isActive = typeof active === 'boolean' ? active : !this.$refs.dropdown.isActive;
          }
        },

        /*
         * Close timepicker
         */
        close() {
          this.toggle(false);
        },

        /*
         * Call default onFocus method and show timepicker
         */
        handleOnFocus() {
          this.onFocus();

          if (this.openOnFocus) {
            this.toggle(true);
          }
        },

        /*
         * Format date into string 'HH-MM-SS'
         */
        formatHHMMSS(value) {
          const date = new Date(value);

          if (value && !isNaN(date)) {
            const hours = date.getHours();
            const minutes = date.getMinutes();
            const seconds = date.getSeconds();
            return this.formatNumber(hours, true) + ':' + this.formatNumber(minutes, true) + ':' + this.formatNumber(seconds, true);
          }

          return '';
        },

        /*
         * Parse time from string
         */
        onChangeNativePicker(event) {
          const date = event.target.value;

          if (date) {
            let time = null;

            if (this.computedValue && !isNaN(this.computedValue)) {
              time = new Date(this.computedValue);
            } else {
              time = new Date();
              time.setMilliseconds(0);
            }

            const t = date.split(':');
            time.setHours(parseInt(t[0], 10));
            time.setMinutes(parseInt(t[1], 10));
            time.setSeconds(t[2] ? parseInt(t[2], 10) : 0);
            this.computedValue = new Date(time.getTime());
          } else {
            this.computedValue = null;
          }
        },

        formatNumber(value, prependZero) {
          return this.isHourFormat24 || prependZero ? this.pad(value) : value;
        },

        pad(value) {
          return (value < 10 ? '0' : '') + value;
        },

        /*
         * Format date into string
         */
        formatValue(date) {
          if (date && !isNaN(date)) {
            return this.timeFormatter(date, this);
          } else {
            return null;
          }
        },

        /**
         * Keypress event that is bound to the document.
         */
        keyPress({
          key
        }) {
          if (this.$refs.dropdown && this.$refs.dropdown.isActive && (key === 'Escape' || key === 'Esc')) {
            this.toggle(false);
          }
        },

        /**
         * Emit 'blur' event on dropdown is not active (closed)
         */
        onActiveChange(value) {
          if (!value) {
            this.onBlur();
          }
        }

      },

      created() {
        if (typeof window !== 'undefined') {
          document.addEventListener('keyup', this.keyPress);
        }
      },

      beforeDestroy() {
        if (typeof window !== 'undefined') {
          document.removeEventListener('keyup', this.keyPress);
        }
      }

    };

    //
    /**
     * An input with a simple dropdown/modal for selecting a time, uses native timepicker for mobile
     * @displayName Timepicker
     * @example ./examples/Timepicker.md
     * @style _timepicker.scss
     */

    var script$f = {
      name: 'OTimepicker',
      components: {
        [__vue_component__$1.name]: __vue_component__$1,
        [__vue_component__$a.name]: __vue_component__$a,
        [__vue_component__.name]: __vue_component__,
        [__vue_component__$8.name]: __vue_component__$8,
        [__vue_component__$9.name]: __vue_component__$9
      },
      configField: 'timepicker',
      mixins: [BaseComponentMixin, TimepickerMixin, MatchMediaMixin],
      inheritAttrs: false,
      props: {
        rootClass: [String, Function, Array],
        sizeClass: [String, Function, Array],
        boxClass: [String, Function, Array],
        separatorClass: [String, Function, Array],
        footerClass: [String, Function, Array],
        mobileClass: [String, Function, Array],
        inputClasses: {
          type: Object,
          default: () => {
            return getValueByPath(getOptions(), 'timepicker.inputClasses', {});
          }
        },
        dropdownClasses: {
          type: Object,
          default: () => {
            return getValueByPath(getOptions(), 'timepicker.dropdownClasses', {});
          }
        },
        selectClasses: {
          type: Object,
          default: () => {
            return getValueByPath(getOptions(), 'timepicker.selectClasses', {});
          }
        }
      },
      computed: {
        inputBind() {
          return { ...this.$attrs,
            ...this.inputClasses
          };
        },

        dropdownBind() {
          return {
            'root-class': this.computedClass('dropdownClasses.rootClass', 'o-tpck__dropdown'),
            ...this.dropdownClasses
          };
        },

        selectBind() {
          return {
            'select-class': this.computedClass('selectClasses.selectClass', 'o-tpck__select'),
            'placeholder-class': this.computedClass('selectClasses.placeholderClass', 'o-tpck__select-placeholder'),
            ...this.selectClasses
          };
        },

        rootClasses() {
          return [this.computedClass('rootClass', 'o-tpck'), {
            [this.computedClass('sizeClass', 'o-tpck--', this.size)]: this.size
          }, {
            [this.computedClass('mobileClass', 'o-tpck--mobile')]: this.isMatchMedia
          }];
        },

        boxClasses() {
          return [this.computedClass('boxClass', 'o-tpck__box')];
        },

        separatorClasses() {
          return [this.computedClass('separatorClass', 'o-tpck__separator')];
        },

        footerClasses() {
          return [this.computedClass('footerClass', 'o-tpck__footer')];
        },

        nativeStep() {
          if (this.enableSeconds) return '1';
          return null;
        }

      }
    };

    /* script */
    const __vue_script__$f = script$f;

    /* template */
    var __vue_render__$e = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.rootClasses},[(!_vm.isMobile || _vm.inline)?_c('o-dropdown',_vm._b({ref:"dropdown",attrs:{"position":_vm.position,"disabled":_vm.disabled,"inline":_vm.inline,"append-to-body":_vm.appendToBody,"append-to-body-copy-parent":""},on:{"active-change":_vm.onActiveChange},scopedSlots:_vm._u([(!_vm.inline)?{key:"trigger",fn:function(){return [_vm._t("trigger",[_c('o-input',_vm._b({ref:"input",attrs:{"autocomplete":"off","value":_vm.formatValue(_vm.computedValue),"placeholder":_vm.placeholder,"size":_vm.size,"icon":_vm.icon,"icon-pack":_vm.iconPack,"disabled":_vm.disabled,"readonly":!_vm.editable,"rounded":_vm.rounded,"use-html5-validation":_vm.useHtml5Validation},on:{"focus":_vm.handleOnFocus},nativeOn:{"keyup":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }return _vm.toggle(true)},"change":function($event){return _vm.onChange($event.target.value)}}},'o-input',_vm.inputBind,false))])]},proxy:true}:null],null,true)},'o-dropdown',_vm.dropdownBind,false),[_c('o-dropdown-item',{attrs:{"override":"","tag":"div","item-class":_vm.boxClasses,"disabled":_vm.disabled,"clickable":false}},[_c('o-select',_vm._b({attrs:{"override":"","disabled":_vm.disabled,"placeholder":"00"},nativeOn:{"change":function($event){return _vm.onHoursChange($event.target.value)}},model:{value:(_vm.hoursSelected),callback:function ($$v) {_vm.hoursSelected=$$v;},expression:"hoursSelected"}},'o-select',_vm.selectBind,false),_vm._l((_vm.hours),function(hour){return _c('option',{key:hour.value,attrs:{"disabled":_vm.isHourDisabled(hour.value)},domProps:{"value":hour.value}},[_vm._v(" "+_vm._s(hour.label)+" ")])}),0),_c('span',{class:_vm.separatorClasses},[_vm._v(_vm._s(_vm.hourLiteral))]),_c('o-select',_vm._b({attrs:{"override":"","disabled":_vm.disabled,"placeholder":"00"},nativeOn:{"change":function($event){return _vm.onMinutesChange($event.target.value)}},model:{value:(_vm.minutesSelected),callback:function ($$v) {_vm.minutesSelected=$$v;},expression:"minutesSelected"}},'o-select',_vm.selectBind,false),_vm._l((_vm.minutes),function(minute){return _c('option',{key:minute.value,attrs:{"disabled":_vm.isMinuteDisabled(minute.value)},domProps:{"value":minute.value}},[_vm._v(" "+_vm._s(minute.label)+" ")])}),0),(_vm.enableSeconds)?[_c('span',{class:_vm.separatorClasses},[_vm._v(_vm._s(_vm.minuteLiteral))]),_c('o-select',_vm._b({attrs:{"override":"","disabled":_vm.disabled,"placeholder":"00"},nativeOn:{"change":function($event){return _vm.onSecondsChange($event.target.value)}},model:{value:(_vm.secondsSelected),callback:function ($$v) {_vm.secondsSelected=$$v;},expression:"secondsSelected"}},'o-select',_vm.selectBind,false),_vm._l((_vm.seconds),function(second){return _c('option',{key:second.value,attrs:{"disabled":_vm.isSecondDisabled(second.value)},domProps:{"value":second.value}},[_vm._v(" "+_vm._s(second.label)+" ")])}),0),_c('span',{class:_vm.separatorClasses},[_vm._v(_vm._s(_vm.secondLiteral))])]:_vm._e(),(!_vm.isHourFormat24)?_c('o-select',_vm._b({attrs:{"override":"","disabled":_vm.disabled},nativeOn:{"change":function($event){return _vm.onMeridienChange($event.target.value)}},model:{value:(_vm.meridienSelected),callback:function ($$v) {_vm.meridienSelected=$$v;},expression:"meridienSelected"}},'o-select',_vm.selectBind,false),_vm._l((_vm.meridiens),function(meridien){return _c('option',{key:meridien,attrs:{"disabled":_vm.isMeridienDisabled(meridien)},domProps:{"value":meridien}},[_vm._v(" "+_vm._s(meridien)+" ")])}),0):_vm._e(),(_vm.$slots.default !== undefined)?_c('footer',{class:_vm.footerClasses},[_vm._t("default")],2):_vm._e()],2)],1):_c('o-input',_vm._b({ref:"input",attrs:{"type":"time","step":_vm.nativeStep,"autocomplete":"off","value":_vm.formatHHMMSS(_vm.computedValue),"placeholder":_vm.placeholder,"size":_vm.size,"icon":_vm.icon,"icon-pack":_vm.iconPack,"rounded":_vm.rounded,"max":_vm.formatHHMMSS(_vm.maxTime),"min":_vm.formatHHMMSS(_vm.minTime),"disabled":_vm.disabled,"readonly":false,"use-html5-validation":_vm.useHtml5Validation},on:{"focus":_vm.handleOnFocus,"blur":function($event){_vm.onBlur() && _vm.checkHtml5Validity();},"invalid":_vm.onInvalid},nativeOn:{"change":function($event){return _vm.onChange($event.target.value)}}},'o-input',_vm.inputBind,false))],1)};
    var __vue_staticRenderFns__$e = [];

      /* style */
      const __vue_inject_styles__$f = undefined;
      /* scoped */
      const __vue_scope_id__$f = undefined;
      /* module identifier */
      const __vue_module_identifier__$f = undefined;
      /* functional template */
      const __vue_is_functional_template__$f = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$f = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$e, staticRenderFns: __vue_staticRenderFns__$e },
        __vue_inject_styles__$f,
        __vue_script__$f,
        __vue_scope_id__$f,
        __vue_is_functional_template__$f,
        __vue_module_identifier__$f,
        false,
        undefined,
        undefined,
        undefined
      );

    //
    const AM$1 = 'AM';
    const PM$1 = 'PM';
    /**
     * An input with a simple dropdown/modal for selecting a date and time, uses native datetimepicker for mobile
     * @displayName Datetimepicker
     * @example ./examples/Datetimepicker.md
     */

    var script$g = {
      name: 'ODatetimepicker',
      components: {
        [__vue_component__$e.name]: __vue_component__$e,
        [__vue_component__$f.name]: __vue_component__$f
      },
      configField: 'datetimepicker',
      mixins: [FormElementMixin, BaseComponentMixin],
      inheritAttrs: false,
      props: {
        /* @model */
        value: {
          type: Date
        },

        /* Enable input/typing. Note that you might have to set a custom datetime parser */
        editable: {
          type: Boolean,
          default: false
        },

        /**
         * Size of button, optional
         * @values small, medium, large
         */
        size: String,
        placeholder: String,
        disabled: Boolean,

        /**
         * 	Icon name to be added on the right side
         */
        iconRight: String,

        /**
         * Make the icon right clickable
         */
        iconRightClickable: Boolean,

        /* Datimepicker is shown inline, input is removed */
        inline: Boolean,

        /* Open datetimepicker on input focus */
        openOnFocus: Boolean,

        /**
         * Optional, position of the datepicker relative to the input
         * @values top-right, top-left, bottom-left
         */
        position: String,

        /* Enable native datetimepicker on mobile */
        mobileNative: {
          type: Boolean,
          default: true
        },

        /* Earliest datetime available for selection */
        minDatetime: Date,

        /* Latest datetime available for selection */
        maxDatetime: Date,

        /* Function to format datetime (Date type) to a string for displaying in the input */
        datetimeFormatter: {
          type: Function
        },

        /* Function to parse string to a datetime (Date type) for setting the component's datetime from the input */
        datetimeParser: {
          type: Function
        },

        /* Function used internally to create a new Date instance */
        datetimeCreator: {
          type: Function,
          default: date => {
            const datetimeCreator = getValueByPath(getOptions(), 'datetimepicker.datetimeCreator', undefined);

            if (typeof datetimeCreator === 'function') {
              return datetimeCreator(date);
            } else {
              return date;
            }
          }
        },

        /**
         * Properties and classes to bind to the internal DatePicker
         */
        datepicker: Object,

        /**
         * Properties and classes to bind to the internal TimePicker
         */
        timepicker: Object,

        /* Accept a string with a BCP 47 language tag, or an array of such strings. See Unicode BCP 47 locale identifier */
        locale: {
          type: [String, Array],
          default: () => {
            return getValueByPath(getOptions(), 'locale');
          }
        },

        /* Append datetimepicker calendar to body */
        appendToBody: Boolean,
        datepickerWrapperClass: [String, Function, Array],
        timepickerWrapperClass: [String, Function, Array]
      },

      data() {
        return {
          newValue: this.value
        };
      },

      computed: {
        datepickerWrapperClasses() {
          return [this.computedClass('datepickerWrapperClass', 'o-dtpck__date')];
        },

        timepickerWrapperClasses() {
          return [this.computedClass('timepickerWrapperClass', 'o-dtpck__time')];
        },

        computedValue: {
          get() {
            return this.newValue;
          },

          set(value) {
            if (value) {
              let val = new Date(value.getTime());

              if (this.newValue) {
                // restore time part
                if ((value.getDate() !== this.newValue.getDate() || value.getMonth() !== this.newValue.getMonth() || value.getFullYear() !== this.newValue.getFullYear()) && value.getHours() === 0 && value.getMinutes() === 0 && value.getSeconds() === 0) {
                  val.setHours(this.newValue.getHours(), this.newValue.getMinutes(), this.newValue.getSeconds(), 0);
                }
              } else {
                val = this.datetimeCreator(value);
              } // check min and max range


              if (this.minDatetime && val < this.minDatetime) {
                val = this.minDatetime;
              } else if (this.maxDatetime && val > this.maxDatetime) {
                val = this.maxDatetime;
              }

              this.newValue = new Date(val.getTime());
            } else {
              this.newValue = value;
            }

            this.$emit('input', this.newValue);
          }

        },

        localeOptions() {
          return new Intl.DateTimeFormat(this.locale, {
            year: 'numeric',
            month: 'numeric',
            day: 'numeric',
            hour: 'numeric',
            minute: 'numeric',
            second: this.enableSeconds() ? 'numeric' : undefined
          }).resolvedOptions();
        },

        dtf() {
          return new Intl.DateTimeFormat(this.locale, {
            year: this.localeOptions.year || 'numeric',
            month: this.localeOptions.month || 'numeric',
            day: this.localeOptions.day || 'numeric',
            hour: this.localeOptions.hour || 'numeric',
            minute: this.localeOptions.minute || 'numeric',
            second: this.enableSeconds() ? this.localeOptions.second || 'numeric' : undefined,
            hourCycle: !this.isHourFormat24() ? 'h12' : 'h23'
          });
        },

        isMobileNative() {
          return this.mobileNative;
        },

        isMobile() {
          return this.isMobileNative && isMobile.any();
        },

        minDate() {
          if (!this.minDatetime) {
            return this.datepicker ? this.datepicker.minDate : null;
          }

          return new Date(this.minDatetime.getFullYear(), this.minDatetime.getMonth(), this.minDatetime.getDate(), 0, 0, 0, 0);
        },

        maxDate() {
          if (!this.maxDatetime) {
            return this.datepicker ? this.datepicker.maxDate : null;
          }

          return new Date(this.maxDatetime.getFullYear(), this.maxDatetime.getMonth(), this.maxDatetime.getDate(), 0, 0, 0, 0);
        },

        minTime() {
          if (!this.minDatetime || this.newValue === null || typeof this.newValue === 'undefined' || this.newValue.getFullYear() != this.minDatetime.getFullYear() || this.newValue.getMonth() != this.minDatetime.getMonth() || this.newValue.getDate() != this.minDatetime.getDate()) {
            return this.timepicker ? this.timepicker.minTime : null;
          }

          return this.minDatetime;
        },

        maxTime() {
          if (!this.maxDatetime || this.newValue === null || typeof this.newValue === 'undefined' || this.newValue.getFullYear() != this.maxDatetime.getFullYear() || this.newValue.getMonth() != this.maxDatetime.getMonth() || this.newValue.getDate() != this.maxDatetime.getDate()) {
            return this.timepicker ? this.timepicker.maxTime : null;
          }

          return this.maxDatetime;
        },

        datepickerSize() {
          return this.datepicker && this.datepicker.size ? this.datepicker.size : this.size;
        },

        timepickerSize() {
          return this.timepicker && this.timepicker.size ? this.timepicker.size : this.size;
        },

        timepickerDisabled() {
          return this.timepicker && this.timepicker.disabled ? this.timepicker.disabled : this.disabled;
        }

      },
      watch: {
        value() {
          this.newValue = this.value;
        }

      },
      methods: {
        enableSeconds() {
          if (this.$refs.timepicker) {
            return this.$refs.timepicker.enableSeconds;
          }

          return false;
        },

        isHourFormat24() {
          if (this.$refs.timepicker) {
            return this.$refs.timepicker.isHourFormat24;
          }

          return !this.localeOptions.hour12;
        },

        defaultDatetimeParser(date) {
          const datetimeParser = getValueByPath(getOptions(), 'datetimepicker.datetimeParser', undefined);

          if (typeof this.datetimeParser === 'function') {
            return this.datetimeParser(date);
          } else if (typeof datetimeParser === 'function') {
            return datetimeParser(date);
          } else {
            if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {
              let dayPeriods = [AM$1, PM$1, AM$1.toLowerCase(), PM$1.toLowerCase()];

              if (this.$refs.timepicker) {
                dayPeriods.push(this.$refs.timepicker.amString);
                dayPeriods.push(this.$refs.timepicker.pmString);
              }

              const parts = this.dtf.formatToParts(new Date());
              const formatRegex = parts.map((part, idx) => {
                if (part.type === 'literal') {
                  if (idx + 1 < parts.length && parts[idx + 1].type === 'hour') {
                    return `[^\\d]+`;
                  }

                  return part.value.replace(/ /g, '\\s?');
                } else if (part.type === 'dayPeriod') {
                  return `((?!=<${part.type}>)(${dayPeriods.join('|')})?)`;
                }

                return `((?!=<${part.type}>)\\d+)`;
              }).join('');
              const datetimeGroups = matchWithGroups(formatRegex, date); // We do a simple validation for the group.
              // If it is not valid, it will fallback to Date.parse below

              if (datetimeGroups.year && datetimeGroups.year.length === 4 && datetimeGroups.month && datetimeGroups.month <= 12 && datetimeGroups.day && datetimeGroups.day <= 31 && datetimeGroups.hour && datetimeGroups.hour >= 0 && datetimeGroups.hour < 24 && datetimeGroups.minute && datetimeGroups.minute >= 0 && datetimeGroups.minute <= 59) {
                const d = new Date(datetimeGroups.year, datetimeGroups.month - 1, datetimeGroups.day, datetimeGroups.hour, datetimeGroups.minute, datetimeGroups.second || 0);
                return d;
              }
            }

            return new Date(Date.parse(date));
          }
        },

        defaultDatetimeFormatter(date) {
          const datetimeFormatter = getValueByPath(getOptions(), 'datetimepicker.datetimeFormatter', undefined);

          if (typeof this.datetimeFormatter === 'function') {
            return this.datetimeFormatter(date);
          } else if (typeof datetimeFormatter === 'function') {
            return datetimeFormatter(date);
          } else {
            return this.dtf.format(date);
          }
        },

        /*
        * Parse date from string
        */
        onChangeNativePicker(event) {
          const date = event.target.value;
          const s = date ? date.split(/\D/) : [];

          if (s.length >= 5) {
            const year = parseInt(s[0], 10);
            const month = parseInt(s[1], 10) - 1;
            const day = parseInt(s[2], 10);
            const hours = parseInt(s[3], 10);
            const minutes = parseInt(s[4], 10); // Seconds are omitted intentionally; they are unsupported by input
            // type=datetime-local and cause the control to fail native validation

            this.computedValue = new Date(year, month, day, hours, minutes);
          } else {
            this.computedValue = null;
          }
        },

        formatNative(value) {
          const date = new Date(value);

          if (value && !isNaN(date)) {
            const year = date.getFullYear();
            const month = date.getMonth() + 1;
            const day = date.getDate();
            const hours = date.getHours();
            const minutes = date.getMinutes();
            const seconds = date.getSeconds();
            return year + '-' + ((month < 10 ? '0' : '') + month) + '-' + ((day < 10 ? '0' : '') + day) + 'T' + ((hours < 10 ? '0' : '') + hours) + ':' + ((minutes < 10 ? '0' : '') + minutes) + ':' + ((seconds < 10 ? '0' : '') + seconds);
          }

          return '';
        },

        toggle() {
          this.$refs.datepicker.toggle();
        }

      },

      mounted() {
        if (!this.isMobile || this.inline) {
          // $refs attached, it's time to refresh datepicker (input)
          if (this.newValue) {
            this.$refs.datepicker.$forceUpdate();
          }
        }
      }

    };

    /* script */
    const __vue_script__$g = script$g;

    /* template */
    var __vue_render__$f = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (!_vm.isMobile || _vm.inline)?_c('o-datepicker',_vm._b({ref:"datepicker",class:_vm.datepickerWrapperClasses,attrs:{"rounded":_vm.rounded,"open-on-focus":_vm.openOnFocus,"position":_vm.position,"inline":_vm.inline,"editable":_vm.editable,"expanded":_vm.expanded,"close-on-click":false,"date-formatter":_vm.defaultDatetimeFormatter,"date-parser":_vm.defaultDatetimeParser,"min-date":_vm.minDate,"max-date":_vm.maxDate,"icon":_vm.icon,"icon-right":_vm.iconRight,"icon-right-clickable":_vm.iconRightClickable,"icon-pack":_vm.iconPack,"size":_vm.datepickerSize,"placeholder":_vm.placeholder,"range":false,"disabled":_vm.disabled,"mobile-native":_vm.isMobileNative,"locale":_vm.locale,"append-to-body":_vm.appendToBody},on:{"focus":_vm.onFocus,"blur":_vm.onBlur,"active-change":function($event){return _vm.$emit('active-change', $event)},"icon-right-click":function($event){return _vm.$emit('icon-right-click')},"change-month":function($event){return _vm.$emit('change-month', $event)},"change-year":function($event){return _vm.$emit('change-year', $event)}},scopedSlots:_vm._u([{key:"footer",fn:function(){return [_c('div',{class:_vm.timepickerWrapperClasses},[_c('o-timepicker',_vm._b({ref:"timepicker",attrs:{"inline":"","editable":_vm.editable,"min-time":_vm.minTime,"max-time":_vm.maxTime,"size":_vm.timepickerSize,"disabled":_vm.timepickerDisabled,"mobile-native":_vm.isMobileNative,"locale":_vm.locale},model:{value:(_vm.computedValue),callback:function ($$v) {_vm.computedValue=$$v;},expression:"computedValue"}},'o-timepicker',_vm.timepicker,false))],1),(_vm.$slots.footer !== undefined)?[_vm._t("footer")]:_vm._e()]},proxy:true}],null,true),model:{value:(_vm.computedValue),callback:function ($$v) {_vm.computedValue=$$v;},expression:"computedValue"}},'o-datepicker',_vm.datepicker,false)):_c('o-input',_vm._b({ref:"input",attrs:{"type":"datetime-local","autocomplete":"off","value":_vm.formatNative(_vm.computedValue),"placeholder":_vm.placeholder,"size":_vm.datepickerSize,"icon":_vm.icon,"icon-pack":_vm.iconPack,"rounded":_vm.rounded,"max":_vm.formatNative(_vm.maxDate),"min":_vm.formatNative(_vm.minDate),"disabled":_vm.disabled,"readonly":false,"use-html5-validation":_vm.useHtml5Validation},on:{"focus":_vm.onFocus,"blur":_vm.onBlur,"invalid":_vm.onInvalid},nativeOn:{"change":function($event){return _vm.onChangeNativePicker($event)}}},'o-input',_vm.$attrs,false))};
    var __vue_staticRenderFns__$f = [];

      /* style */
      const __vue_inject_styles__$g = undefined;
      /* scoped */
      const __vue_scope_id__$g = undefined;
      /* module identifier */
      const __vue_module_identifier__$g = undefined;
      /* functional template */
      const __vue_is_functional_template__$g = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$g = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$f, staticRenderFns: __vue_staticRenderFns__$f },
        __vue_inject_styles__$g,
        __vue_script__$g,
        __vue_scope_id__$g,
        __vue_is_functional_template__$g,
        __vue_module_identifier__$g,
        false,
        undefined,
        undefined,
        undefined
      );

    const Plugin$7 = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$g);
      }

    };
    use(Plugin$7);

    const Plugin$8 = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$8);
        registerComponent(Vue, __vue_component__$9);
      }

    };
    use(Plugin$8);

    var script$h = {
      name: 'OFieldBody',
      inject: {
        $field: {
          name: '$field',
          default: false
        }
      },
      configField: 'field',
      computed: {
        parent() {
          return this.$field;
        }

      },

      render(h) {
        let first = true;
        return h('div', {
          attrs: {
            'class': this.parent.bodyHorizontalClasses
          }
        }, this.$slots.default.map(element => {
          // skip returns and comments
          if (!element.tag) {
            return element;
          }

          let message;

          if (first) {
            message = this.parent.newMessage;
            first = false;
          }

          return h('o-field', {
            attrs: {
              variant: this.parent.newVariant,
              message
            }
          }, [element]);
        }));
      }

    };

    /* script */
    const __vue_script__$h = script$h;

    /* template */

      /* style */
      const __vue_inject_styles__$h = undefined;
      /* scoped */
      const __vue_scope_id__$h = undefined;
      /* module identifier */
      const __vue_module_identifier__$h = undefined;
      /* functional template */
      const __vue_is_functional_template__$h = undefined;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$h = /*#__PURE__*/normalizeComponent(
        {},
        __vue_inject_styles__$h,
        __vue_script__$h,
        __vue_scope_id__$h,
        __vue_is_functional_template__$h,
        __vue_module_identifier__$h,
        false,
        undefined,
        undefined,
        undefined
      );

    //
    /**
     * Fields are used to add functionality to controls and to attach/group components and elements together
     * @displayName Field
     * @example ./examples/Field.md
     * @style _field.scss
     */

    var script$i = {
      name: 'OField',
      components: {
        [__vue_component__$h.name]: __vue_component__$h
      },
      configField: 'field',
      mixins: [BaseComponentMixin, MatchMediaMixin],

      provide() {
        return {
          $field: this
        };
      },

      inject: {
        $field: {
          name: '$field',
          default: false
        }
      },
      props: {
        /**
         * 	Color of the field and help message, also adds a matching icon, optional. Used by Input, Select and Autocomplete
         *  @values primary, info, success, warning, danger, and any other custom color
         */
        variant: String,

        /**
         * Field label
         */
        label: String,

        /**
         * Same as native for set on the label
         */
        labelFor: String,

        /**
         * Help message text
         */
        message: String,

        /**
         * Direct child components/elements of Field will be grouped horizontally (see which ones at the top of the page)
         */
        grouped: Boolean,

        /**
         * Allow controls to fill up multiple lines, making it responsive
         */
        groupMultiline: Boolean,

        /**
         * Group label and control on the same line for horizontal forms
         */
        horizontal: Boolean,

        /**
         * Field automatically attach controls together
         */
        addons: {
          type: Boolean,
          default: true
        },

        /**
        * Vertical size of input, optional
        * @values small, medium, large
        */
        labelSize: String,
        rootClass: [String, Function, Array],
        horizontalClass: [String, Function, Array],
        groupedClass: [String, Function, Array],
        groupMultilineClass: [String, Function, Array],
        labelClass: [String, Function, Array],
        labelSizeClass: [String, Function, Array],
        labelHorizontalClass: [String, Function, Array],
        bodyClass: [String, Function, Array],
        bodyHorizontalClass: [String, Function, Array],
        addonsClass: [String, Function, Array],
        messageClass: [String, Function, Array],
        variantMessageClass: [String, Function, Array],
        variantLabelClass: [String, Function, Array],
        mobileClass: [String, Function, Array],
        focusedClass: [String, Function, Array],
        filledClass: [String, Function, Array]
      },

      data() {
        return {
          newVariant: this.variant,
          newMessage: this.message,
          isFocused: false,
          isFilled: false
        };
      },

      computed: {
        rootClasses() {
          return [this.computedClass('rootClass', 'o-field'), {
            [this.computedClass('horizontalClass', 'o-field--horizontal')]: this.horizontal
          }, {
            [this.computedClass('mobileClass', 'o-field--mobile')]: this.isMatchMedia
          }, {
            [this.computedClass('focusedClass', 'o-field--focused')]: this.isFocused
          }, {
            [this.computedClass('filledClass', 'o-field--filled')]: this.isFilled
          }];
        },

        messageClasses() {
          return [this.computedClass('messageClass', 'o-field__message'), {
            [this.computedClass('variantMessageClass', 'o-field__message-', this.newVariant)]: this.newVariant
          }];
        },

        labelClasses() {
          return [this.computedClass('labelClass', 'o-field__label'), {
            [this.computedClass('labelSizeClass', 'o-field__label-', this.labelSize)]: this.labelSize
          }, {
            [this.computedClass('variantLabelClass', 'o-field__label-', this.newVariant)]: this.newVariant
          }];
        },

        labelHorizontalClasses() {
          return [this.computedClass('labelHorizontalClass', 'o-field__horizontal-label')];
        },

        bodyClasses() {
          return [this.computedClass('bodyClass', 'o-field__body')];
        },

        bodyHorizontalClasses() {
          return [this.computedClass('bodyHorizontalClass', 'o-field__horizontal-body')];
        },

        innerFieldClasses() {
          return [this.computedClass('rootClass', 'o-field'), {
            [this.computedClass('groupMultilineClass', 'o-field--grouped-multiline')]: this.groupMultiline
          }, {
            [this.computedClass('groupedClass', 'o-field--grouped')]: this.grouped
          }, {
            [this.computedClass('addonsClass', 'o-field--addons')]: !this.grouped && this.hasAddons()
          }];
        },

        parent() {
          return this.$field;
        },

        hasLabelSlot() {
          return this.$slots.label;
        },

        hasMessageSlot() {
          return this.$slots.message;
        },

        hasLabel() {
          return this.label || this.hasLabelSlot;
        },

        hasMessage() {
          return (!this.parent || !this.parent.hasInnerField) && this.newMessage || this.hasMessageSlot;
        },

        hasInnerField() {
          return this.grouped || this.groupMultiline || this.hasAddons();
        }

      },
      watch: {
        /**
        * Set internal variant when prop change.
        */
        variant(value) {
          this.newVariant = value;
        },

        /**
        * Set internal message when prop change.
        */
        message(value) {
          this.newMessage = value;
        },

        /**
        * Set parent message if we use Field in Field.
        */
        newMessage(value) {
          if (this.parent && this.parent.hasInnerField) {
            if (!this.parent.variant) {
              this.parent.newVariant = this.newVariant;
            }

            if (!this.parent.message) {
              this.parent.newMessage = value;
            }
          }
        }

      },
      methods: {
        hasAddons() {
          let renderedNode = 0;

          if (this.$slots.default) {
            renderedNode = this.$slots.default.reduce((i, node) => node.tag ? i + 1 : i, 0);
          }

          return renderedNode > 1 && this.addons && !this.horizontal;
        }

      }
    };

    /* script */
    const __vue_script__$i = script$i;

    /* template */
    var __vue_render__$g = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.rootClasses},[(_vm.horizontal)?_c('div',{class:_vm.labelHorizontalClasses},[(_vm.hasLabel)?_c('label',{class:_vm.labelClasses,attrs:{"for":_vm.labelFor}},[(_vm.hasLabelSlot)?_vm._t("label"):[_vm._v(_vm._s(_vm.label))]],2):_vm._e()]):[(_vm.hasLabel)?_c('label',{class:_vm.labelClasses,attrs:{"for":_vm.labelFor}},[(_vm.hasLabelSlot)?_vm._t("label"):[_vm._v(_vm._s(_vm.label))]],2):_vm._e()],(_vm.horizontal)?_c('o-field-body',[_vm._t("default")],2):(_vm.hasInnerField)?_c('div',{class:_vm.bodyClasses},[_c('div',{class:_vm.innerFieldClasses},[_vm._t("default")],2)]):[_vm._t("default")],(_vm.hasMessage && !_vm.horizontal)?_c('p',{class:_vm.messageClasses},[(_vm.hasMessageSlot)?_vm._t("message"):[_vm._v(_vm._s(_vm.newMessage))]],2):_vm._e()],2)};
    var __vue_staticRenderFns__$g = [];

      /* style */
      const __vue_inject_styles__$i = undefined;
      /* scoped */
      const __vue_scope_id__$i = undefined;
      /* module identifier */
      const __vue_module_identifier__$i = undefined;
      /* functional template */
      const __vue_is_functional_template__$i = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$i = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$g, staticRenderFns: __vue_staticRenderFns__$g },
        __vue_inject_styles__$i,
        __vue_script__$i,
        __vue_scope_id__$i,
        __vue_is_functional_template__$i,
        __vue_module_identifier__$i,
        false,
        undefined,
        undefined,
        undefined
      );

    const Plugin$9 = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$i);
      }

    };
    use(Plugin$9);

    const Plugin$a = {
      install(Vue) {
        registerComponent(Vue, __vue_component__);
      }

    };
    use(Plugin$a);

    const Plugin$b = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$1);
      }

    };
    use(Plugin$b);

    //
    /**
     * A simple item input field that can have autocomplete functionality
     * @displayName Inputitems
     * @example ./examples/InputItems.md
     * @style _inputitems.scss
     */

    var script$j = {
      name: 'OInputitems',
      components: {
        [__vue_component__$2.name]: __vue_component__$2,
        [__vue_component__.name]: __vue_component__
      },
      mixins: [FormElementMixin, BaseComponentMixin],
      inheritAttrs: false,
      configField: 'inputitems',
      props: {
        /** @model */
        value: {
          type: Array,
          default: () => []
        },

        /** Items data */
        data: {
          type: Array,
          default: () => []
        },

        /**
         * Color of the each items, optional
         * @values primary, info, success, warning, danger, and any other custom color
         */
        variant: String,

        /** Limits the number of items, plus item counter */
        maxitems: {
          type: [Number, String],
          required: false
        },

        /** Show counter when maxlength or maxtags props are passed */
        hasCounter: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'inputitems.hasCounter', true);
          }
        },

        /** Property of the object (if data is array of objects) to use as display text */
        field: {
          type: String,
          default: 'value'
        },

        /** Add autocomplete feature (if true, any Autocomplete props may be used too) */
        allowAutocomplete: Boolean,

        /** Add autocomplete feature (if true, any Autocomplete props may be used too) */
        autocomplete: Boolean,

        /**  Property of the object (if data is array of objects) to use as display text of group */
        groupField: String,

        /**  Property of the object (if data is array of objects) to use as key to get items array of each group, optional */
        groupOptions: String,
        nativeAutocomplete: String,

        /**  Opens a dropdown with choices when the input field is focused */
        openOnFocus: Boolean,

        /** Input will be disabled */
        disabled: Boolean,

        /** Add close/delete button to the item */
        closable: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'inputitems.closable', true);
          }
        },

        /**
         * Array of keys
         * (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)
         * which will add a item when typing (default comma, tab and enter)
         */
        confirmKeys: {
          type: Array,
          default: () => {
            return getValueByPath(getOptions(), 'inputitems.confirmKeys', [',', 'Tab', 'Enter']);
          }
        },

        /** Allow removing last item when pressing given keys, if input is empty */
        removeOnKeys: {
          type: Array,
          default: () => {
            return getValueByPath(getOptions(), 'inputitems.removeOnKeys', ['Backspace']);
          }
        },

        /** When autocomplete, it allow to add new items */
        allowNew: Boolean,

        /** Array of chars used to split when pasting a new string */
        onPasteSeparators: {
          type: Array,
          default: () => {
            return getValueByPath(getOptions(), 'inputitems.onPasteSeparators', [',']);
          }
        },

        /** Function to validate the value of the item before adding */
        beforeAdding: {
          type: Function,
          default: () => true
        },

        /** Allows adding the same item multiple time */
        allowDuplicates: {
          type: Boolean,
          default: false
        },

        /** Makes the autocomplete component check if list reached scroll end and emit infinite-scroll event */
        checkInfiniteScroll: {
          type: Boolean,
          default: false
        },

        /** Function to create a new item to push into v-model (items) */
        createItem: {
          type: Function,
          default: item => item
        },

        /** Icon name of close icon on selected item */
        closeIcon: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'inputitems.closeIcon', 'close');
          }
        },

        /** The first option will always be pre-selected (easier to just hit enter or tab) */
        keepFirst: Boolean,

        /** Accessibility label for the close button */
        ariaCloseLabel: String,

        /** Append autocomplete content to body */
        appendToBody: Boolean,
        rootClass: [String, Array, Function],
        expandedClass: [String, Array, Function],
        variantClass: [String, Array, Function],
        closeClass: [String, Array, Function],
        itemClass: [String, Array, Function],
        counterClass: [String, Array, Function],
        autocompleteClasses: {
          type: Object,
          default: () => {
            return getValueByPath(getOptions(), 'inputitems.autocompleteClasses', {});
          }
        }
      },

      data() {
        return {
          items: Array.isArray(this.value) ? this.value.slice(0) : this.value || [],
          newItem: '',
          isComposing: false
        };
      },

      computed: {
        rootClasses() {
          return [this.computedClass('rootClass', 'o-inputit'), {
            [this.computedClass('expandedClass', 'o-inputit--expanded')]: this.expanded
          }];
        },

        containerClasses() {
          return [this.computedClass('containerClass', 'o-inputit__container'), {
            [this.computedClass('sizeClass', 'o-inputit__container--', this.size)]: this.size
          }];
        },

        itemClasses() {
          return [this.computedClass('itemClass', 'o-inputit__item'), {
            [this.computedClass('variantClass', 'o-inputit__item--', this.variant)]: this.variant
          }];
        },

        closeClasses() {
          return [this.computedClass('closeClass', 'o-inputit__item__close')];
        },

        counterClasses() {
          return [this.computedClass('counterClass', 'o-inputit__counter')];
        },

        autocompleteBind() {
          return { ...this.$attrs,
            'root-class': this.computedClass('autocompleteClasses.rootClass', 'o-inputit__autocomplete'),
            'input-classes': {
              'input-class': this.computedClass('autocompleteClasses.inputClasses.inputClass', 'o-inputit__input')
            },
            ...this.autocompleteClasses
          };
        },

        valueLength() {
          return this.newItem.trim().length;
        },

        hasDefaultSlot() {
          return !!this.$scopedSlots.default;
        },

        hasEmptySlot() {
          return !!this.$slots.empty;
        },

        hasHeaderSlot() {
          return !!this.$slots.header;
        },

        hasFooterSlot() {
          return !!this.$slots.footer;
        },

        /**
         * Show the input field if a maxitems hasn't been set or reached.
         */
        hasInput() {
          return this.maxitems == null || this.itemsLength < this.maxitems;
        },

        itemsLength() {
          return this.items.length;
        },

        /**
         * If input has onPasteSeparators prop,
         * returning new RegExp used to split pasted string.
         */
        separatorsAsRegExp() {
          const sep = this.onPasteSeparators;
          return sep.length ? new RegExp(sep.map(s => {
            return s ? s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&') : null;
          }).join('|'), 'g') : null;
        },

        $elementRef() {
          return 'autocomplete';
        }

      },
      watch: {
        /**
         * When v-model is changed set internal value.
         */
        value(value) {
          this.items = Array.isArray(value) ? value.slice(0) : value || [];
        },

        hasInput() {
          if (!this.hasInput) this.onBlur();
        }

      },
      methods: {
        addItem(item) {
          const itemToAdd = item || this.newItem.trim();

          if (itemToAdd) {
            if (!this.allowAutocomplete) {
              const reg = this.separatorsAsRegExp;

              if (reg && itemToAdd.match(reg)) {
                itemToAdd.split(reg).map(t => t.trim()).filter(t => t.length !== 0).map(this.addItem);
                return;
              }
            } // Add the item input if it is not blank
            // or previously added (if not allowDuplicates).


            const add = !this.allowDuplicates ? this.items.indexOf(this.createItem(itemToAdd)) === -1 : true;

            if (add && this.beforeAdding(itemToAdd)) {
              this.items.push(this.createItem(itemToAdd));
              this.$emit('input', this.items);
              this.$emit('add', itemToAdd);
            }
          } // after autocomplete events


          requestAnimationFrame(() => {
            this.newItem = '';
            this.$emit('typing', '');
          });
        },

        getNormalizedItemText(item) {
          if (typeof item === 'object') {
            item = getValueByPath(item, this.field);
          }

          return `${item}`;
        },

        customOnBlur(event) {
          // Add item on-blur if not select only
          if (!this.allowAutocomplete) this.addItem();
          this.onBlur(event);
        },

        onSelect(option) {
          if (!option) return;
          this.addItem(option);
          this.$nextTick(() => {
            this.newItem = '';
          });
        },

        removeItem(index, event) {
          const item = this.items.splice(index, 1)[0];
          this.$emit('input', this.items);
          this.$emit('remove', item);
          if (event) event.stopPropagation();

          if (this.openOnFocus && this.$refs.autocomplete) {
            this.$refs.autocomplete.focus();
          }

          return item;
        },

        removeLastItem() {
          if (this.itemsLength > 0) {
            this.removeItem(this.itemsLength - 1);
          }
        },

        keydown(event) {
          const {
            key
          } = event; // cannot destructure preventDefault (https://stackoverflow.com/a/49616808/2774496)

          if (this.removeOnKeys.indexOf(key) !== -1 && !this.newItem.length) {
            this.removeLastItem();
          } // Stop if is to accept select only


          if (this.allowAutocomplete && !this.allowNew) return;

          if (this.confirmKeys.indexOf(key) >= 0) {
            // Allow Tab to advance to next field regardless
            if (key !== 'Tab') event.preventDefault();
            if (key === 'Enter' && this.isComposing) return;
            this.addItem();
          }
        },

        onTyping(event) {
          this.$emit('typing', event.trim());
        }

      }
    };

    /* script */
    const __vue_script__$j = script$j;

    /* template */
    var __vue_render__$h = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.rootClasses},[_c('div',{class:_vm.containerClasses,on:{"click":function($event){_vm.hasInput && _vm.focus($event);}}},[_vm._t("selected",_vm._l((_vm.items),function(item,index){return _c('span',{key:_vm.getNormalizedItemText(item) + index,class:_vm.itemClasses},[_c('span',[_vm._v(_vm._s(_vm.getNormalizedItemText(item)))]),(_vm.closable)?_c('o-icon',{class:_vm.closeClasses,attrs:{"clickable":"","both":"","pack":_vm.iconPack,"icon":_vm.closeIcon,"aria-label":_vm.ariaCloseLabel},nativeOn:{"click":function($event){return _vm.removeItem(index, $event)}}}):_vm._e()],1)}),{"items":_vm.items}),(_vm.hasInput)?_c('o-autocomplete',_vm._b({ref:"autocomplete",attrs:{"data":_vm.data,"field":_vm.field,"icon":_vm.icon,"icon-pack":_vm.iconPack,"maxlength":_vm.maxlength,"has-counter":false,"size":_vm.size,"disabled":_vm.disabled,"loading":_vm.loading,"autocomplete":_vm.nativeAutocomplete,"open-on-focus":_vm.openOnFocus,"keep-first":_vm.keepFirst,"keep-open":_vm.openOnFocus,"group-field":_vm.groupField,"group-options":_vm.groupOptions,"use-html5-validation":_vm.useHtml5Validation,"check-infinite-scroll":_vm.checkInfiniteScroll,"append-to-body":_vm.appendToBody,"confirm-keys":_vm.confirmKeys},on:{"typing":_vm.onTyping,"focus":_vm.onFocus,"blur":_vm.customOnBlur,"invalid":_vm.onInvalid,"select":_vm.onSelect,"infinite-scroll":function($event){return _vm.$emit('infinite-scroll', $event)},"icon-right-click":function($event){return _vm.$emit('icon-right-click', $event)}},nativeOn:{"keydown":function($event){return _vm.keydown($event)},"compositionstart":function($event){_vm.isComposing = true;},"compositionend":function($event){_vm.isComposing = false;}},scopedSlots:_vm._u([(_vm.hasHeaderSlot)?{key:"header",fn:function(){return [_vm._t("header")]},proxy:true}:null,(_vm.hasDefaultSlot)?{key:"default",fn:function(props){return [_vm._t("default",null,{"option":props.option,"index":props.index})]}}:null,(_vm.hasEmptySlot)?{key:"empty",fn:function(){return [_vm._t("empty")]},proxy:true}:null,(_vm.hasFooterSlot)?{key:"footer",fn:function(){return [_vm._t("footer")]},proxy:true}:null],null,true),model:{value:(_vm.newItem),callback:function ($$v) {_vm.newItem=$$v;},expression:"newItem"}},'o-autocomplete',_vm.autocompleteBind,false)):_vm._e()],2),(_vm.hasCounter && (_vm.maxitems || _vm.maxlength))?_c('small',{class:_vm.counterClasses},[(_vm.maxlength && _vm.valueLength > 0)?[_vm._v(" "+_vm._s(_vm.valueLength)+" / "+_vm._s(_vm.maxlength)+" ")]:(_vm.maxitems)?[_vm._v(" "+_vm._s(_vm.itemsLength)+" / "+_vm._s(_vm.maxitems)+" ")]:_vm._e()],2):_vm._e()])};
    var __vue_staticRenderFns__$h = [];

      /* style */
      const __vue_inject_styles__$j = undefined;
      /* scoped */
      const __vue_scope_id__$j = undefined;
      /* module identifier */
      const __vue_module_identifier__$j = undefined;
      /* functional template */
      const __vue_is_functional_template__$j = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$j = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$h, staticRenderFns: __vue_staticRenderFns__$h },
        __vue_inject_styles__$j,
        __vue_script__$j,
        __vue_scope_id__$j,
        __vue_is_functional_template__$j,
        __vue_module_identifier__$j,
        false,
        undefined,
        undefined,
        undefined
      );

    const Plugin$c = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$j);
      }

    };
    use(Plugin$c);

    // Polyfills for SSR
    const isSSR = typeof window === 'undefined';
    const HTMLElement = isSSR ? Object : window.HTMLElement;
    const File = isSSR ? Object : window.File;

    //
    /**
     * A simple loading overlay
     * @displayName Loading
     * @example ./examples/Loading.md
     * @style _loading.scss
     */

    var script$k = {
      name: 'OLoading',
      components: {
        [__vue_component__.name]: __vue_component__
      },
      mixins: [BaseComponentMixin],
      configField: 'loading',
      props: {
        /** Whether modal is active or not,  use the .sync modifier (Vue 2.x) or v-model:active (Vue 3.x) to make it two-way binding */
        active: Boolean,

        /** @ignore */
        programmatic: Object,

        /** @ignore */
        promise: promiseObject(),
        container: [Object, Function, HTMLElement],

        /** Loader will overlay the full page */
        fullPage: {
          type: Boolean,
          default: true
        },

        /* Custom animation (transition name) */
        animation: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'loading.animation', 'fade');
          }
        },

        /** Can close Loading by pressing escape or clicking outside */
        canCancel: {
          type: Boolean,
          default: false
        },

        /** Callback function to call after user canceled (pressed escape / clicked outside) */
        onCancel: {
          type: Function,
          default: () => {}
        },

        /** Icon name */
        icon: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'loading.icon', 'loading');
          }
        },

        /** Enable spin effect on icon */
        iconSpin: {
          type: Boolean,
          default: true
        },
        iconSize: {
          type: String,
          default: 'medium'
        },
        overlay: {
          type: Boolean,
          default: true
        },
        rootClass: [String, Function, Array],
        overlayClass: [String, Function, Array],
        iconClass: [String, Function, Array],
        fullPageClass: [String, Function, Array]
      },

      data() {
        return {
          isActive: this.active || false,
          displayInFullPage: this.fullPage
        };
      },

      watch: {
        active(value) {
          this.isActive = value;
        },

        fullPage(value) {
          this.displayInFullPage = value;
        }

      },
      computed: {
        rootClasses() {
          return [this.computedClass('rootClass', 'o-load'), {
            [this.computedClass('fullPageClass', 'o-load--fullpage')]: this.displayInFullPage
          }];
        },

        overlayClasses() {
          return [{
            [this.computedClass('overlayClass', 'o-load__overlay')]: this.overlay
          }];
        },

        iconClasses() {
          return [this.computedClass('iconClass', 'o-load__icon')];
        }

      },
      methods: {
        /**
        * Close the Modal if canCancel.
        */
        cancel(method) {
          if (!this.canCancel || !this.isActive) return;
          this.close({
            action: 'cancel',
            method
          });
        },

        /**
        * Emit events, and destroy modal if it's programmatic.
        */
        close() {
          this.onCancel.apply(null, arguments);
          this.$emit('close');
          this.$emit('update:active', false); // Timeout for the animation complete before destroying

          if (this.programmatic) {
            if (this.programmatic.instances) {
              this.programmatic.instances.remove(this);
            }

            if (this.programmatic.resolve) {
              this.programmatic.resolve.apply(null, arguments);
            }

            this.isActive = false;
            window.requestAnimationFrame(() => {
              this.$destroy();
              removeElement(this.$el);
            });
          }
        },

        /**
        * Keypress event that is bound to the document.
        */
        keyPress({
          key
        }) {
          if (key === 'Escape' || key === 'Esc') this.cancel('escape');
        }

      },

      created() {
        if (typeof window !== 'undefined') {
          document.addEventListener('keyup', this.keyPress);
        }
      },

      beforeMount() {
        // Insert the Loading component in body tag
        // only if it's programmatic
        if (this.programmatic) {
          if (!this.container) {
            document.body.appendChild(this.$el);
          } else {
            this.displayInFullPage = false;
            this.$emit('update:full-page', false);
            this.container.appendChild(this.$el);
          }
        }
      },

      mounted() {
        if (this.programmatic) {
          if (this.programmatic.instances) {
            this.programmatic.instances.add(this);
          }

          this.isActive = true;
        }
      },

      beforeDestroy() {
        if (typeof window !== 'undefined') {
          document.removeEventListener('keyup', this.keyPress);
        }
      }

    };

    /* script */
    const __vue_script__$k = script$k;

    /* template */
    var __vue_render__$i = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":_vm.animation}},[(_vm.isActive)?_c('div',{class:_vm.rootClasses},[_c('div',{class:_vm.overlayClasses,on:{"click":function($event){return _vm.cancel('outside')}}}),_vm._t("default",[_c('o-icon',{class:_vm.iconClasses,attrs:{"icon":_vm.icon,"spin":_vm.iconSpin,"size":_vm.iconSize,"both":""}})])],2):_vm._e()])};
    var __vue_staticRenderFns__$i = [];

      /* style */
      const __vue_inject_styles__$k = undefined;
      /* scoped */
      const __vue_scope_id__$k = undefined;
      /* module identifier */
      const __vue_module_identifier__$k = undefined;
      /* functional template */
      const __vue_is_functional_template__$k = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$k = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$i, staticRenderFns: __vue_staticRenderFns__$i },
        __vue_inject_styles__$k,
        __vue_script__$k,
        __vue_scope_id__$k,
        __vue_is_functional_template__$k,
        __vue_module_identifier__$k,
        false,
        undefined,
        undefined,
        undefined
      );

    function InstanceRegistry() {
      this.entries = [];
    }

    InstanceRegistry.prototype = {
      add(entry) {
        this.entries.push(entry);
      },

      remove(entry) {
        let index = this.entries.indexOf(entry);
        this.entries.splice(index, 1);
      },

      walk(callback) {
        // Walk a copy of the array so that the callback is allowed to remove the instance
        this.entries = [...this.entries].filter(e => {
          const ret = callback(e);
          return !(ret === true);
        });
      }

    };

    let localVueInstance;
    let instances = new InstanceRegistry();
    const LoadingProgrammatic = {
      open(params) {
        let parent;
        const defaultParam = {
          programmatic: {
            instances
          }
        };

        if (params.parent) {
          parent = params.parent;
          delete params.parent;
        }

        const propsData = merge(defaultParam, params);

        if (window.Promise) {
          propsData.promise = new Promise((p1, p2) => {
            propsData.programmatic.resolve = p1;
            propsData.programmatic.reject = p2;
          });
        }

        const vm = typeof window !== 'undefined' && window.Vue ? window.Vue : localVueInstance || VueInstance;
        const LoadingComponent = vm.extend(__vue_component__$k);
        return new LoadingComponent({
          parent,
          el: document.createElement('div'),
          propsData
        });
      },

      closeAll() {
        instances.walk(entry => {
          entry.close(...arguments);
        });
      }

    };
    const Plugin$d = {
      install(Vue) {
        localVueInstance = Vue;
        registerComponent(Vue, __vue_component__$k);
        registerComponentProgrammatic(Vue, 'loading', LoadingProgrammatic);
      }

    };
    use(Plugin$d);

    var MessageMixin = {
      components: {
        [__vue_component__.name]: __vue_component__
      },
      props: {
        /** Whether modal is active or not, use the .sync modifier (Vue 2.x) or v-model:active (Vue 3.x) to make it two-way binding */
        active: {
          type: Boolean,
          default: true
        },

        /** Adds an 'X' button that closes the notification. */
        closable: {
          type: Boolean,
          default: false
        },

        /** Message text (can contain HTML). */
        message: String,

        /** Type (color) of the notification, optional. */
        type: String,

        /** Adds an icon on the left side depending on the type (or the icon prop if defined). */
        hasIcon: Boolean,

        /** Icon name to use with has-icon. */
        icon: String,

        /** Icon pack to use. */
        iconPack: String,

        /** Icon size */
        iconSize: {
          type: String,
          default: 'large'
        },

        /** Hide notification after duration only not programmatic. */
        autoClose: {
          type: Boolean,
          default: false
        },

        /** Visibility duration in miliseconds. */
        duration: {
          type: Number,
          default: 2000
        }
      },

      data() {
        return {
          isActive: this.active
        };
      },

      watch: {
        active(value) {
          this.isActive = value;
        },

        isActive(value) {
          if (value) {
            this.setAutoClose();
          } else {
            if (this.timer) {
              clearTimeout(this.timer);
            }
          }
        }

      },
      computed: {
        /**
         * Icon name (MDI) based on type.
         */
        computedIcon() {
          if (this.icon) {
            return this.icon;
          }

          switch (this.type) {
            case 'info':
              return 'information';

            case 'success':
              return 'check-circle';

            case 'warning':
              return 'alert';

            case 'danger':
              return 'alert-circle';

            default:
              return null;
          }
        }

      },
      methods: {
        /**
         * Close the Message and emit events.
         */
        close() {
          this.isActive = false;
          this.$emit('close', ...arguments);
          this.$emit('update:active', false);
        },

        /**
         * Set timer to auto close message
         */
        setAutoClose() {
          if (this.autoClose) {
            this.timer = setTimeout(() => {
              if (this.isActive) {
                this.close({
                  action: 'close',
                  method: 'timeout'
                });
              }
            }, this.duration);
          }
        }

      },

      mounted() {
        this.setAutoClose();
      }

    };

    //
    /**
     * Bold notification blocks to alert your users of something
     * @displayName Notification/Toast
     * @requires ./NotificationNotice.vue
     * @example ./examples/Notification.md
     * @style _notification.scss
     */

    var script$l = {
      name: 'ONotification',
      configField: 'notification',
      mixins: [BaseComponentMixin, MessageMixin],
      props: {
        /**
        * Which position the notification will appear when programmatically
        * @values top-right, top, top-left, bottom-right, bottom, bottom-left
        */
        position: String,

        /**
        * Color of the control, optional
        * @values primary, info, success, warning, danger, and any other custom color
        */
        variant: [String, Object],

        /**
         * Label for the close button, to be read by accessibility screenreaders.
         */
        ariaCloseLabel: String,

        /**
         * Size of close icon
         */
        closeIconSize: {
          type: String,
          default: 'small'
        },

        /**
         * Custom animation (transition name).
         */
        animation: {
          type: String,
          default: 'fade'
        },

        /** Component to be injected, used to open a component modal programmatically. Close modal within the component by emitting a 'close' event  this.$emit('close') */
        component: [Object, Function],

        /** Props to be binded to the injected component */
        props: Object,

        /** Events to be binded to the injected component */
        events: Object,

        /** Close icon name */
        closeIcon: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'notification.closeIcon', 'close');
          }
        },
        rootClass: [String, Function, Array],
        closeClass: [String, Function, Array],
        contentClass: [String, Function, Array],
        iconClass: [String, Function, Array],
        positionClass: [String, Function, Array],
        variantClass: [String, Function, Array],
        wrapperClass: [String, Function, Array]
      },
      computed: {
        rootClasses() {
          return [this.computedClass('rootClass', 'o-notification'), {
            [this.computedClass('variantClass', 'o-notification--', this.variant)]: this.variant
          }, {
            [this.computedClass('positionClass', 'o-notification--', this.position)]: this.position
          }];
        },

        wrapperClasses() {
          return [this.computedClass('wrapperClass', 'o-notification__wrapper')];
        },

        iconClasses() {
          return [this.computedClass('iconClass', 'o-notification__icon')];
        },

        contentClasses() {
          return [this.computedClass('contentClass', 'o-notification__content')];
        },

        closeClasses() {
          return [this.computedClass('closeClass', 'o-notification__close')];
        }

      }
    };

    /* script */
    const __vue_script__$l = script$l;

    /* template */
    var __vue_render__$j = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":_vm.animation}},[_c('article',{directives:[{name:"show",rawName:"v-show",value:(_vm.isActive),expression:"isActive"}],class:_vm.rootClasses},[(_vm.closable)?_c('button',{class:_vm.closeClasses,attrs:{"type":"button","aria-label":_vm.ariaCloseLabel},on:{"click":function($event){return _vm.close({action: 'close', method: 'x'})}}},[_c('o-icon',{attrs:{"clickable":"","pack":_vm.iconPack,"both":"","icon":_vm.closeIcon,"size":_vm.closeIconSize}})],1):_vm._e(),(_vm.component)?_c(_vm.component,_vm._g(_vm._b({tag:"component",on:{"close":_vm.close}},'component',_vm.props,false),_vm.events)):_vm._e(),(_vm.$scopedSlots.default || _vm.message)?_c('div',{class:_vm.wrapperClasses},[(_vm.computedIcon)?_c('o-icon',{class:_vm.iconClasses,attrs:{"icon":_vm.computedIcon,"pack":_vm.iconPack,"both":"","size":_vm.iconSize,"aria-hidden":""}}):_vm._e(),_c('div',{class:_vm.contentClasses},[(_vm.$scopedSlots.default)?[_vm._t("default",null,{"closeNotification":_vm.close})]:[_c('span',{domProps:{"innerHTML":_vm._s(_vm.message)}})]],2)],1):_vm._e()],1)])};
    var __vue_staticRenderFns__$j = [];

      /* style */
      const __vue_inject_styles__$l = undefined;
      /* scoped */
      const __vue_scope_id__$l = undefined;
      /* module identifier */
      const __vue_module_identifier__$l = undefined;
      /* functional template */
      const __vue_is_functional_template__$l = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$l = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$j, staticRenderFns: __vue_staticRenderFns__$j },
        __vue_inject_styles__$l,
        __vue_script__$l,
        __vue_scope_id__$l,
        __vue_is_functional_template__$l,
        __vue_module_identifier__$l,
        false,
        undefined,
        undefined,
        undefined
      );

    var NoticeMixin = {
      props: {
        /** Type (color) of the notification, optional. */
        type: {
          type: String
        },

        /** Message text (can contain HTML). */
        message: [String, Array],

        /** Visibility duration in miliseconds. */
        duration: {
          type: Number,
          default: () => {
            return getValueByPath(getOptions(), 'notification.duration', 1000);
          }
        },

        /** If should queue with others notices (snackbar/toast/notification). */
        queue: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'notification.noticeQueue', false);
          }
        },

        /** Show the Notification indefinitely until it is dismissed when programmatically. */
        indefinite: {
          type: Boolean,
          default: false
        },

        /** Which position the notification will appear when programmatically. */
        position: {
          type: String,
          default: 'top',

          validator(value) {
            return ['top-right', 'top', 'top-left', 'bottom-right', 'bottom', 'bottom-left'].indexOf(value) > -1;
          }

        },

        /** DOM element the toast will be created on. Note that this also changes the position of the toast from fixed to absolute. Meaning that the container should be fixed. */
        container: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'notification.containerElement', undefined);
          }
        },

        /** @ignore */
        programmatic: Object,

        /** @ignore */
        promise: promiseObject(),

        /** Callback function to call after close (programmatically close or user canceled) */
        onClose: {
          type: Function,
          default: () => {}
        }
      },

      data() {
        return {
          isActive: false,
          parentTop: null,
          parentBottom: null,
          newDuration: this.duration,
          newContainer: this.container
        };
      },

      computed: {
        correctParent() {
          switch (this.position) {
            case 'top-right':
            case 'top':
            case 'top-left':
              return this.parentTop;

            case 'bottom-right':
            case 'bottom':
            case 'bottom-left':
              return this.parentBottom;
          }
        },

        transition() {
          switch (this.position) {
            case 'top-right':
            case 'top':
            case 'top-left':
              return {
                enter: 'fadeInDown',
                leave: 'fadeOut'
              };

            case 'bottom-right':
            case 'bottom':
            case 'bottom-left':
              return {
                enter: 'fadeInUp',
                leave: 'fadeOut'
              };
          }
        }

      },
      methods: {
        shouldQueue() {
          if (!this.queue) return false;
          return this.parentTop.childElementCount > 0 || this.parentBottom.childElementCount > 0;
        },

        close() {
          clearTimeout(this.timer);
          this.$emit('close');
          this.onClose.apply(null, arguments);

          if (this.programmatic) {
            if (this.programmatic.instances) {
              this.programmatic.instances.remove(this);
            }

            if (this.programmatic.resolve) {
              this.programmatic.resolve.apply(null, arguments);
            }
          } // Timeout for the animation complete before destroying


          setTimeout(() => {
            this.isActive = false;
            this.$destroy();
            removeElement(this.$el);
          }, 150);
        },

        showNotice() {
          if (this.shouldQueue()) this.correctParent.innerHTML = '';
          this.correctParent.insertAdjacentElement('afterbegin', this.$el);
          this.isActive = true;

          if (!this.indefinite) {
            this.timer = setTimeout(() => this.timeoutCallback(), this.newDuration);
          }
        },

        setupContainer() {
          if (this.rootClasses() && this.positionClasses('top') && this.positionClasses('bottom')) {
            this.parentTop = document.querySelector((this.newContainer ? this.newContainer : 'body') + `>.${this.rootClasses().join('.')}.${this.positionClasses('top').join('.')}`);
            this.parentBottom = document.querySelector((this.newContainer ? this.newContainer : 'body') + `>.${this.rootClasses().join('.')}.${this.positionClasses('bottom').join('.')}`);
            if (this.parentTop && this.parentBottom) return;

            if (!this.parentTop) {
              this.parentTop = document.createElement('div');
              this.parentTop.className = `${this.rootClasses().join(' ')} ${this.positionClasses('top').join(' ')}`;
            }

            if (!this.parentBottom) {
              this.parentBottom = document.createElement('div');
              this.parentBottom.className = `${this.rootClasses().join(' ')} ${this.positionClasses('bottom').join(' ')}`;
            }

            const container = document.querySelector(this.newContainer) || document.body;
            container.appendChild(this.parentTop);
            container.appendChild(this.parentBottom);

            if (this.newContainer) {
              const classes = this.noticeCustomContainerClasses();

              if (classes && classes.length) {
                classes.filter(c => !!c).forEach(c => {
                  this.parentTop.classList.add(c);
                  this.parentBottom.classList.add(c);
                });
              }
            }
          }
        },

        timeoutCallback() {
          return this.close({
            action: 'close',
            method: 'timeout'
          });
        }

      },

      beforeMount() {
        this.setupContainer();
      },

      mounted() {
        if (this.programmatic && this.programmatic.instances) {
          this.programmatic.instances.add(this);
        }

        this.showNotice();
      }

    };

    //
    /**
     * @displayName Notification Notice
     */

    var script$m = {
      name: 'ONotificationNotice',
      configField: 'notification',
      mixins: [BaseComponentMixin, NoticeMixin],
      props: {
        noticeClass: [String, Function, Array],
        noticePositionClass: [String, Function, Array],
        noticeCustomContainerClass: [String, Function, Array]
      },
      methods: {
        rootClasses() {
          return [this.computedClass('noticeClass', 'o-notices')];
        },

        positionClasses(position) {
          return [this.computedClass('noticePositionClass', 'o-notices--', position)];
        },

        noticeCustomContainerClasses() {
          return [this.computedClass('noticeCustomContainerClass', 'o-notices__custom-container')];
        },

        timeoutCallback() {
          return this.$refs.notification.close({
            action: 'close',
            method: 'timeout'
          });
        }

      }
    };

    /* script */
    const __vue_script__$m = script$m;

    /* template */
    var __vue_render__$k = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('o-notification',_vm._b({ref:"notification",on:{"close":_vm.close}},'o-notification',_vm.$options.propsData,false),[_vm._t("default")],2)};
    var __vue_staticRenderFns__$k = [];

      /* style */
      const __vue_inject_styles__$m = undefined;
      /* scoped */
      const __vue_scope_id__$m = undefined;
      /* module identifier */
      const __vue_module_identifier__$m = undefined;
      /* functional template */
      const __vue_is_functional_template__$m = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$m = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$k, staticRenderFns: __vue_staticRenderFns__$k },
        __vue_inject_styles__$m,
        __vue_script__$m,
        __vue_scope_id__$m,
        __vue_is_functional_template__$m,
        __vue_module_identifier__$m,
        false,
        undefined,
        undefined,
        undefined
      );

    let localVueInstance$1;
    let instances$1 = new InstanceRegistry();
    const NotificationProgrammatic = {
      open(params) {
        let parent;

        if (typeof params === 'string') {
          params = {
            message: params
          };
        }

        const defaultParam = {
          programmatic: {
            instances: instances$1
          },
          position: getValueByPath(getOptions(), 'notification.position', 'top-right'),
          closable: params.closable || getValueByPath(getOptions(), 'notification.closable', false)
        };

        if (params.parent) {
          parent = params.parent;
          delete params.parent;
        }

        let slot;

        if (Array.isArray(params.message)) {
          slot = params.message;
          delete params.message;
        } // fix animation


        params.active = false;
        const propsData = merge(defaultParam, params);

        if (window.Promise) {
          propsData.promise = new Promise((p1, p2) => {
            propsData.programmatic.resolve = p1;
            propsData.programmatic.reject = p2;
          });
        }

        const vm = typeof window !== 'undefined' && window.Vue ? window.Vue : localVueInstance$1 || VueInstance;
        const NotificationNoticeComponent = vm.extend(__vue_component__$m);
        const component = new NotificationNoticeComponent({
          parent,
          el: document.createElement('div'),
          propsData
        });

        if (slot) {
          component.$slots.default = slot;
          component.$forceUpdate();
        } // fix animation


        component.$children[0].isActive = true;
        return component;
      },

      closeAll() {
        instances$1.walk(entry => {
          entry.close(...arguments);
        });
      }

    };
    const Plugin$e = {
      install(Vue) {
        localVueInstance$1 = Vue;
        registerComponent(Vue, __vue_component__$l);
        registerComponentProgrammatic(Vue, 'notification', NotificationProgrammatic);
      }

    };
    use(Plugin$e);

    //
    /**
     * Classic modal overlay to include any content you may need
     * @displayName Modal
     * @example ./examples/Modal.md
     * @style _modal.scss
     */

    var script$n = {
      name: 'OModal',
      components: {
        [__vue_component__.name]: __vue_component__
      },
      configField: 'modal',
      directives: {
        trapFocus: directive
      },
      mixins: [BaseComponentMixin, MatchMediaMixin],
      props: {
        /** Whether modal is active or not, use the .sync modifier (Vue 2.x) or v-model:active (Vue 3.x) to make it two-way binding */
        active: Boolean,

        /** Component to be injected, used to open a component modal programmatically. Close modal within the component by emitting a 'close' event  this.$emit('close') */
        component: [Object, Function],

        /** Text content */
        content: String,

        /** @ignore */
        programmatic: Object,

        /** @ignore */
        promise: promiseObject(),

        /** Props to be binded to the injected component */
        props: Object,

        /** Events to be binded to the injected component */
        events: Object,

        /** Width of the Modal */
        width: {
          type: [String, Number],
          default: () => {
            return getValueByPath(getOptions(), 'modal.width', 960);
          }
        },

        /** Custom animation (transition name) */
        animation: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'modal.animation', 'zoom-out');
          }
        },

        /**
         * Can close Modal by clicking 'X', pressing escape or clicking outside
         * @values escape, x, outside, button
         */
        canCancel: {
          type: [Array, Boolean],
          default: () => {
            return getValueByPath(getOptions(), 'modal.canCancel', ['escape', 'x', 'outside', 'button']);
          }
        },

        /** Callback function to call after user canceled (clicked 'X' / pressed escape / clicked outside) */
        onCancel: {
          type: Function,
          default: () => {}
        },

        /** Callback function to call after close (programmatically close or user canceled) */
        onClose: {
          type: Function,
          default: () => {}
        },

        /**
         * clip to remove the body scrollbar, keep to have a non scrollable scrollbar to avoid shifting background, but will set body to position fixed, might break some layouts
         * @values keep, clip
         */
        scroll: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'modal.scroll', 'keep');
          }
        },

        /** Display modal as full screen */
        fullScreen: Boolean,

        /** Trap focus inside the modal. */
        trapFocus: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'modal.trapFocus', true);
          }
        },
        ariaRole: {
          type: String,
          validator: value => {
            return ['dialog', 'alertdialog'].indexOf(value) >= 0;
          }
        },
        ariaModal: Boolean,
        ariaLabel: String,

        /** Destroy modal on hide */
        destroyOnHide: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'modal.destroyOnHide', true);
          }
        },

        /** Automatically focus modal when active */
        autoFocus: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'modal.autoFocus', true);
          }
        },

        /** Icon name */
        closeIcon: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'modal.closeIcon', 'close');
          }
        },
        closeIconSize: {
          type: String,
          default: 'medium'
        },
        rootClass: [String, Function, Array],
        overlayClass: [String, Function, Array],
        contentClass: [String, Function, Array],
        closeClass: [String, Function, Array],
        fullScreenClass: [String, Function, Array],
        mobileClass: [String, Function, Array],
        scrollClipClass: [String, Function, Array],
        noScrollClass: [String, Function, Array]
      },

      data() {
        return {
          isActive: this.active || false,
          savedScrollTop: null,
          newWidth: toCssDimension(this.width),
          animating: !this.active,
          destroyed: !this.active
        };
      },

      computed: {
        rootClasses() {
          return [this.computedClass('rootClass', 'o-modal'), {
            [this.computedClass('mobileClass', 'o-modal--mobile')]: this.isMatchMedia
          }];
        },

        overlayClasses() {
          return [this.computedClass('overlayClass', 'o-modal__overlay')];
        },

        contentClasses() {
          return [this.computedClass('contentClass', 'o-modal__content'), {
            [this.computedClass('fullScreenClass', 'o-modal__content--full-screen')]: this.fullScreen
          }];
        },

        closeClasses() {
          return [this.computedClass('closeClass', 'o-modal__close')];
        },

        scrollClass() {
          if (this.scroll === 'clip') {
            return this.computedClass('scrollClipClass', 'o-clipped');
          }

          return this.computedClass('noScrollClass', 'o-noscroll');
        },

        cancelOptions() {
          return typeof this.canCancel === 'boolean' ? this.canCancel ? getValueByPath(getOptions(), 'modal.canCancel', ['escape', 'x', 'outside', 'button']) : [] : this.canCancel;
        },

        showX() {
          return this.cancelOptions.indexOf('x') >= 0;
        },

        customStyle() {
          if (!this.fullScreen) {
            return {
              maxWidth: this.newWidth
            };
          }

          return null;
        }

      },
      watch: {
        active(value) {
          this.isActive = value;
        },

        isActive(value) {
          if (value) this.destroyed = false;
          this.handleScroll();
          this.$nextTick(() => {
            if (value && this.$el && this.$el.focus && this.autoFocus) {
              this.$el.focus();
            }
          });
        }

      },
      methods: {
        handleScroll() {
          if (typeof window === 'undefined') return;

          if (this.scroll === 'clip') {
            if (this.scrollClass) {
              if (this.isActive) {
                document.documentElement.classList.add(this.scrollClass);
              } else {
                document.documentElement.classList.remove(this.scrollClass);
              }

              return;
            }
          }

          this.savedScrollTop = !this.savedScrollTop ? document.documentElement.scrollTop : this.savedScrollTop;

          if (this.scrollClass) {
            if (this.isActive) {
              document.body.classList.add(this.scrollClass);
            } else {
              document.body.classList.remove(this.scrollClass);
            }
          }

          if (this.isActive) {
            document.body.style.top = `-${this.savedScrollTop}px`;
            return;
          }

          document.documentElement.scrollTop = this.savedScrollTop;
          document.body.style.top = null;
          this.savedScrollTop = null;
        },

        /**
        * Close the Modal if canCancel and call the onCancel prop (function).
        */
        cancel(method) {
          if (this.cancelOptions.indexOf(method) < 0) return;
          this.onCancel.apply(null, arguments);
          this.close({
            action: 'cancel',
            method
          });
        },

        /**
        * Call the onCancel prop (function).
        * Emit events, and destroy modal if it's programmatic.
        */
        close() {
          this.isActive = false;
          this.$emit('close');
          this.$emit('update:active', false);
          this.onClose.apply(null, arguments); // Waiting for the animation complete before destroying

          if (this.programmatic) {
            if (this.programmatic.instances) {
              this.programmatic.instances.remove(this);
            }

            if (this.programmatic.resolve) {
              this.programmatic.resolve.apply(null, arguments);
            }

            window.requestAnimationFrame(() => {
              this.$destroy();
              removeElement(this.$el);
            });
          }
        },

        /**
        * Keypress event that is bound to the document.
        */
        keyPress({
          key
        }) {
          if (this.isActive && (key === 'Escape' || key === 'Esc')) this.cancel('escape');
        },

        /**
        * Transition after-enter hook
        */
        afterEnter() {
          this.animating = false;
        },

        /**
        * Transition before-leave hook
        */
        beforeLeave() {
          this.animating = true;
        },

        /**
        * Transition after-leave hook
        */
        afterLeave() {
          if (this.destroyOnHide) {
            this.destroyed = true;
          }
        }

      },

      created() {
        if (typeof window !== 'undefined') {
          document.addEventListener('keyup', this.keyPress);
        }
      },

      beforeMount() {
        // Insert the Modal component in body tag
        // only if it's programmatic
        this.programmatic && document.body.appendChild(this.$el);
      },

      mounted() {
        if (this.programmatic) {
          if (this.programmatic.instances) {
            this.programmatic.instances.add(this);
          }

          this.isActive = true;
        } else if (this.isActive) this.handleScroll();
      },

      beforeDestroy() {
        if (typeof window !== 'undefined') {
          document.removeEventListener('keyup', this.keyPress); // reset scroll

          const savedScrollTop = !this.savedScrollTop ? document.documentElement.scrollTop : this.savedScrollTop;

          if (this.scrollClass) {
            document.body.classList.remove(this.scrollClass);
            document.documentElement.classList.remove(this.scrollClass);
          }

          document.documentElement.scrollTop = savedScrollTop;
          document.body.style.top = null;
        }
      }

    };

    /* script */
    const __vue_script__$n = script$n;

    /* template */
    var __vue_render__$l = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('transition',{attrs:{"name":_vm.animation},on:{"after-enter":_vm.afterEnter,"before-leave":_vm.beforeLeave,"after-leave":_vm.afterLeave}},[(!_vm.destroyed)?_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.isActive),expression:"isActive"},{name:"trap-focus",rawName:"v-trap-focus",value:(_vm.trapFocus),expression:"trapFocus"}],class:_vm.rootClasses,attrs:{"tabindex":"-1","role":_vm.ariaRole,"aria-label":_vm.ariaLabel,"aria-modal":_vm.ariaModal}},[_c('div',{class:_vm.overlayClasses,on:{"click":function($event){return _vm.cancel('outside')}}}),_c('div',{class:_vm.contentClasses,style:(_vm.customStyle)},[(_vm.component)?_c(_vm.component,_vm._g(_vm._b({tag:"component",on:{"close":_vm.close}},'component',_vm.props,false),_vm.events)):(_vm.content)?_c('div',[_vm._v(" "+_vm._s(_vm.content)+" ")]):_vm._t("default"),(_vm.showX)?_c('o-icon',{directives:[{name:"show",rawName:"v-show",value:(!_vm.animating),expression:"!animating"}],class:_vm.closeClasses,attrs:{"clickable":"","both":"","icon":_vm.closeIcon,"size":_vm.closeIconSize},nativeOn:{"click":function($event){return _vm.cancel('x')}}}):_vm._e()],2)]):_vm._e()])};
    var __vue_staticRenderFns__$l = [];

      /* style */
      const __vue_inject_styles__$n = undefined;
      /* scoped */
      const __vue_scope_id__$n = undefined;
      /* module identifier */
      const __vue_module_identifier__$n = undefined;
      /* functional template */
      const __vue_is_functional_template__$n = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$n = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$l, staticRenderFns: __vue_staticRenderFns__$l },
        __vue_inject_styles__$n,
        __vue_script__$n,
        __vue_scope_id__$n,
        __vue_is_functional_template__$n,
        __vue_module_identifier__$n,
        false,
        undefined,
        undefined,
        undefined
      );

    let localVueInstance$2;
    let instances$2 = new InstanceRegistry();
    const ModalProgrammatic = {
      open(params) {
        let parent;

        if (typeof params === 'string') {
          params = {
            content: params
          };
        }

        const defaultParam = {
          programmatic: {
            instances: instances$2
          }
        };

        if (params.parent) {
          parent = params.parent;
          delete params.parent;
        }

        let slot;

        if (Array.isArray(params.content)) {
          slot = params.content;
          delete params.content;
        }

        const propsData = merge(defaultParam, params);

        if (window.Promise) {
          propsData.promise = new Promise((p1, p2) => {
            propsData.programmatic.resolve = p1;
            propsData.programmatic.reject = p2;
          });
        }

        const vm = typeof window !== 'undefined' && window.Vue ? window.Vue : localVueInstance$2 || VueInstance;
        const ModalComponent = vm.extend(__vue_component__$n);
        const instance = new ModalComponent({
          parent,
          el: document.createElement('div'),
          propsData
        });

        if (slot) {
          instance.$slots.default = slot;
        }

        return instance;
      },

      closeAll() {
        instances$2.walk(entry => {
          entry.close(...arguments);
        });
      }

    };
    const Plugin$f = {
      install(Vue) {
        localVueInstance$2 = Vue;
        registerComponent(Vue, __vue_component__$n);
        registerComponentProgrammatic(Vue, 'modal', ModalProgrammatic);
      }

    };
    use(Plugin$f);

    //
    /**
     * A simple menu
     * @displayName M
     * @style _menu.scss
     */

    var script$o = {
      name: 'OMenu',
      configField: 'menu',
      mixins: [BaseComponentMixin],
      props: {
        accordion: {
          type: Boolean,
          default: true
        },
        activable: {
          type: Boolean,
          default: true
        },
        rootClass: [String, Array, Function]
      },

      data() {
        return {
          isMenu: true // Used by MenuItem

        };
      },

      computed: {
        rootClasses() {
          return this.computedClass('rootClass', 'o-menu');
        }

      }
    };

    /* script */
    const __vue_script__$o = script$o;

    /* template */
    var __vue_render__$m = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.rootClasses},[_vm._t("default")],2)};
    var __vue_staticRenderFns__$m = [];

      /* style */
      const __vue_inject_styles__$o = undefined;
      /* scoped */
      const __vue_scope_id__$o = undefined;
      /* module identifier */
      const __vue_module_identifier__$o = undefined;
      /* functional template */
      const __vue_is_functional_template__$o = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$o = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$m, staticRenderFns: __vue_staticRenderFns__$m },
        __vue_inject_styles__$o,
        __vue_script__$o,
        __vue_scope_id__$o,
        __vue_is_functional_template__$o,
        __vue_module_identifier__$o,
        false,
        undefined,
        undefined,
        undefined
      );

    //
    var script$p = {
      name: 'OMenuList',
      configField: 'menu',
      mixins: [BaseComponentMixin],
      props: {
        ariaRole: String,
        label: String,
        icon: String,
        iconPack: String,

        /**
         * Icon size, optional
         * @values small, medium, large
         */
        size: String,
        listClass: [String, Array, Function],
        listLabelClass: [String, Array, Function]
      },
      computed: {
        listClasses() {
          return this.computedClass('listClass', 'o-menu-list');
        },

        labelClasses() {
          return this.computedClass('listLabelClass', 'o-menu-label');
        },

        computedAriaRole() {
          return this.ariaRole === 'menu' ? this.ariaRole : null;
        }

      }
    };

    /* script */
    const __vue_script__$p = script$p;

    /* template */
    var __vue_render__$n = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[(_vm.label || _vm.$slots.label)?_c('div',{class:_vm.labelClasses},[(_vm.label && _vm.icon)?_c('o-icon',{attrs:{"icon":_vm.icon,"pack":_vm.iconPack,"size":_vm.size}}):_vm._e(),(_vm.label)?_c('span',[_vm._v(_vm._s(_vm.label))]):_vm._t("label")],2):_vm._e(),_c('ul',{class:_vm.listClasses,attrs:{"role":_vm.computedAriaRole}},[_vm._t("default")],2)])};
    var __vue_staticRenderFns__$n = [];

      /* style */
      const __vue_inject_styles__$p = undefined;
      /* scoped */
      const __vue_scope_id__$p = undefined;
      /* module identifier */
      const __vue_module_identifier__$p = undefined;
      /* functional template */
      const __vue_is_functional_template__$p = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$p = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$n, staticRenderFns: __vue_staticRenderFns__$n },
        __vue_inject_styles__$p,
        __vue_script__$p,
        __vue_scope_id__$p,
        __vue_is_functional_template__$p,
        __vue_module_identifier__$p,
        false,
        undefined,
        undefined,
        undefined
      );

    //
    var script$q = {
      name: 'OMenuItem',
      components: {
        [__vue_component__.name]: __vue_component__
      },
      mixins: [BaseComponentMixin],
      configField: 'menu',
      inheritAttrs: false,
      props: {
        label: String,
        active: Boolean,
        expanded: Boolean,
        disabled: Boolean,
        iconPack: String,
        icon: String,
        animation: {
          type: String,
          default: 'slide'
        },
        tag: {
          type: String,
          default: 'a'
        },
        ariaRole: {
          type: String,
          default: ''
        },

        /**
         * Icon size, optional
         * @values small, medium, large
         */
        size: String,
        itemClass: [String, Array, Function],
        itemActiveClass: [String, Array, Function],
        itemDisabledClass: [String, Array, Function],
        itemIconTextClass: [String, Array, Function],
        itemSubmenuClass: [String, Array, Function],
        itemWrapperClass: [String, Array, Function]
      },

      data() {
        return {
          newActive: this.active,
          newExpanded: this.expanded
        };
      },

      computed: {
        ariaRoleMenu() {
          return this.ariaRole === 'menuitem' ? this.ariaRole : null;
        },

        itemClasses() {
          return {
            [this.computedClass('itemClass', 'o-menu-item')]: true,
            [this.computedClass('itemActiveClass', 'o-menu-item--active')]: this.newActive,
            [this.computedClass('itemDisabledClass', 'o-menu-item--disabled')]: this.disabled,
            [this.computedClass('itemIconTextClass', 'o-menu-item--icon-text')]: this.icon
          };
        },

        submenuClasses() {
          return this.computedClass('itemSubmenuClass', 'o-menu-item__submenu');
        },

        wrapperClasses() {
          return this.computedClass('itemWrapperClass', 'o-menu-item__wrapper');
        }

      },
      watch: {
        active(value) {
          this.newActive = value;
        },

        expanded(value) {
          this.newExpanded = value;
        }

      },
      methods: {
        onClick() {
          if (this.disabled) return;
          const menu = this.getMenu();
          this.reset(this.$parent, menu);
          this.newExpanded = this.$props.expanded || !this.newExpanded;
          this.$emit('update:expanded', this.newExpanded);

          if (menu && menu.activable) {
            this.newActive = true;
            this.$emit('update:active', this.newActive);
          }
        },

        reset(parent, menu) {
          const items = parent.$children.filter(c => c.name === this.name);
          items.forEach(item => {
            if (item !== this) {
              this.reset(item, menu);

              if (!parent.$data.isMenu || parent.$data.isMenu && parent.accordion) {
                item.newExpanded = false;
                item.$emit('update:expanded', item.newActive);
              }

              if (menu && menu.activable) {
                item.newActive = false;
                item.$emit('update:active', item.newActive);
              }
            }
          });
        },

        getMenu() {
          let parent = this.$parent;

          while (parent && !parent.$data.isMenu) {
            parent = parent.$parent;
          }

          return parent;
        }

      }
    };

    /* script */
    const __vue_script__$q = script$q;

    /* template */
    var __vue_render__$o = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('li',{class:_vm.wrapperClasses,attrs:{"role":_vm.ariaRoleMenu}},[_c(_vm.tag,_vm._g(_vm._b({tag:"component",class:_vm.itemClasses,on:{"click":function($event){return _vm.onClick()}}},'component',_vm.$attrs,false),_vm.$listeners),[(_vm.icon)?_c('o-icon',{attrs:{"icon":_vm.icon,"pack":_vm.iconPack,"size":_vm.size}}):_vm._e(),(_vm.label)?_c('span',[_vm._v(" "+_vm._s(_vm.label)+" ")]):_vm._t("label",null,{"expanded":_vm.newExpanded,"active":_vm.newActive})],2),(_vm.$slots.default)?[_c('transition',{attrs:{"name":_vm.animation}},[_c('ul',{directives:[{name:"show",rawName:"v-show",value:(_vm.newExpanded),expression:"newExpanded"}],class:_vm.submenuClasses},[_vm._t("default")],2)])]:_vm._e()],2)};
    var __vue_staticRenderFns__$o = [];

      /* style */
      const __vue_inject_styles__$q = undefined;
      /* scoped */
      const __vue_scope_id__$q = undefined;
      /* module identifier */
      const __vue_module_identifier__$q = undefined;
      /* functional template */
      const __vue_is_functional_template__$q = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$q = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$o, staticRenderFns: __vue_staticRenderFns__$o },
        __vue_inject_styles__$q,
        __vue_script__$q,
        __vue_scope_id__$q,
        __vue_is_functional_template__$q,
        __vue_module_identifier__$q,
        false,
        undefined,
        undefined,
        undefined
      );

    const Plugin$g = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$o);
        registerComponent(Vue, __vue_component__$p);
        registerComponent(Vue, __vue_component__$q);
      }

    };
    use(Plugin$g);

    //
    var script$r = {
      name: 'OPaginationButton',
      inject: {
        $pagination: {
          name: '$pagination'
        }
      },
      configField: 'pagination',
      props: {
        page: {
          type: Object,
          required: true
        },
        tag: {
          type: String,
          default: 'a',
          validator: value => getValueByPath(getOptions(), 'linkTags', ['a', 'button', 'input', 'router-link', 'nuxt-link']).indexOf(value) >= 0
        },
        disabled: {
          type: Boolean,
          default: false
        },
        linkClass: [String, Array, Object],
        linkCurrentClass: [String, Array, Object]
      },
      computed: {
        linkClasses() {
          return [this.linkClass || [...this.$pagination.linkClasses], this.page.class, {
            [this.linkCurrentClass || this.$pagination.linkCurrentClasses]: this.page.isCurrent
          }];
        },

        href() {
          if (this.tag === 'a') {
            return '#';
          }

          return '';
        },

        isDisabled() {
          return this.disabled || this.page.disabled;
        }

      }
    };

    /* script */
    const __vue_script__$r = script$r;

    /* template */
    var __vue_render__$p = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(_vm.tag,_vm._b({tag:"component",class:_vm.linkClasses,attrs:{"role":"button","href":_vm.href,"disabled":_vm.isDisabled,"aria-label":_vm.page['aria-label'],"aria-current":_vm.page.isCurrent},on:{"click":function($event){$event.preventDefault();return _vm.page.click($event)}}},'component',_vm.$attrs,false),[_vm._t("default",[_vm._v(_vm._s(_vm.page.number))])],2)};
    var __vue_staticRenderFns__$p = [];

      /* style */
      const __vue_inject_styles__$r = undefined;
      /* scoped */
      const __vue_scope_id__$r = undefined;
      /* module identifier */
      const __vue_module_identifier__$r = undefined;
      /* functional template */
      const __vue_is_functional_template__$r = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$r = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$p, staticRenderFns: __vue_staticRenderFns__$p },
        __vue_inject_styles__$r,
        __vue_script__$r,
        __vue_scope_id__$r,
        __vue_is_functional_template__$r,
        __vue_module_identifier__$r,
        false,
        undefined,
        undefined,
        undefined
      );

    //
    /**
     * A responsive and flexible pagination
     * @displayName Pagination
     * @example ./examples/Pagination.md
     * @style _pagination.scss
     */

    var script$s = {
      name: 'OPagination',
      components: {
        [__vue_component__.name]: __vue_component__,
        [__vue_component__$r.name]: __vue_component__$r
      },
      configField: 'pagination',
      mixins: [BaseComponentMixin, MatchMediaMixin],

      provide() {
        return {
          $pagination: this
        };
      },

      props: {
        /** Total count of items */
        total: [Number, String],

        /** Items count for each page */
        perPage: {
          type: [Number, String],
          default: () => {
            return getValueByPath(getOptions(), 'pagination.perPage', 20);
          }
        },

        /** Current page number, use the .sync modifier (Vue 2.x) or v-model:current (Vue 3.x) to make it two-way binding */
        current: {
          type: [Number, String],
          default: 1
        },

        /** Number of pagination items to show before current page */
        rangeBefore: {
          type: [Number, String],
          default: 1
        },

        /** Number of pagination items to show after current page */
        rangeAfter: {
          type: [Number, String],
          default: 1
        },

        /**
         * Pagination size, optional
         * @values small, medium, large
         */
        size: String,

        /** Simple style */
        simple: Boolean,

        /** Rounded button styles */
        rounded: Boolean,

        /**
         * Buttons order, optional
         * @values centered, right, left
         */
        order: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'pagination.order', 'right');
          }
        },

        /**
         * Icon pack to use
         * @values mdi, fa, fas and any other custom icon pack
         */
        iconPack: String,

        /** Icon to use for previous button */
        iconPrev: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'pagination.iconPrev', 'chevron-left');
          }
        },

        /** Icon to use for next button */
        iconNext: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'pagination.iconNext', 'chevron-right');
          }
        },
        ariaNextLabel: String,
        ariaPreviousLabel: String,
        ariaPageLabel: String,
        ariaCurrentLabel: String,
        rootClass: [String, Function, Array],
        prevBtnClass: [String, Function, Array],
        nextBtnClass: [String, Function, Array],
        listClass: [String, Function, Array],
        linkClass: [String, Function, Array],
        linkCurrentClass: [String, Function, Array],
        ellipsisClass: [String, Function, Array],
        infoClass: [String, Function, Array],
        orderClass: [String, Function, Array],
        simpleClass: [String, Function, Array],
        roundedClass: [String, Function, Array],
        linkDisabledClass: [String, Function, Array],
        sizeClass: [String, Function, Array],
        mobileClass: [String, Function, Array]
      },
      computed: {
        rootClasses() {
          return [this.computedClass('rootClass', 'o-pag'), {
            [this.computedClass('orderClass', 'o-pag--', this.order)]: this.order
          }, {
            [this.computedClass('sizeClass', 'o-pag--', this.size)]: this.size
          }, {
            [this.computedClass('simpleClass', 'o-pag--simple')]: this.simple
          }, {
            [this.computedClass('mobileClass', 'o-pag--mobile')]: this.isMatchMedia
          }];
        },

        prevBtnClasses() {
          return [this.computedClass('prevBtnClass', 'o-pag__previous'), {
            [this.computedClass('linkDisabledClass', 'o-pag__link--disabled')]: !this.hasPrev
          }];
        },

        nextBtnClasses() {
          return [this.computedClass('nextBtnClass', 'o-pag__next'), {
            [this.computedClass('linkDisabledClass', 'o-pag__link--disabled')]: !this.hasNext
          }];
        },

        infoClasses() {
          return [this.computedClass('infoClass', 'o-pag__info')];
        },

        ellipsisClasses() {
          return [this.computedClass('ellipsisClass', 'o-pag__ellipsis')];
        },

        listClasses() {
          return [this.computedClass('listClass', 'o-pag__list')];
        },

        linkClasses() {
          return [this.computedClass('linkClass', 'o-pag__link'), {
            [this.computedClass('roundedClass', 'o-pag__link--rounded')]: this.rounded
          }];
        },

        linkCurrentClasses() {
          return [this.computedClass('linkCurrentClass', 'o-pag__link--current')];
        },

        beforeCurrent() {
          return parseInt(this.rangeBefore);
        },

        afterCurrent() {
          return parseInt(this.rangeAfter);
        },

        /**
        * Total page size (count).
        */
        pageCount() {
          return Math.ceil(this.total / this.perPage);
        },

        /**
        * First item of the page (count).
        */
        firstItem() {
          const firstItem = this.current * this.perPage - this.perPage + 1;
          return firstItem >= 0 ? firstItem : 0;
        },

        /**
        * Check if previous button is available.
        */
        hasPrev() {
          return this.current > 1;
        },

        /**
        * Check if first page button should be visible.
        */
        hasFirst() {
          return this.current >= 2 + this.beforeCurrent;
        },

        /**
        * Check if first ellipsis should be visible.
        */
        hasFirstEllipsis() {
          return this.current >= this.beforeCurrent + 4;
        },

        /**
        * Check if last page button should be visible.
        */
        hasLast() {
          return this.current <= this.pageCount - (1 + this.afterCurrent);
        },

        /**
        * Check if last ellipsis should be visible.
        */
        hasLastEllipsis() {
          return this.current < this.pageCount - (2 + this.afterCurrent);
        },

        /**
        * Check if next button is available.
        */
        hasNext() {
          return this.current < this.pageCount;
        },

        /**
        * Get near pages, 1 before and 1 after the current.
        * Also add the click event to the array.
        */
        pagesInRange() {
          if (this.simple) return;
          let left = Math.max(1, this.current - this.beforeCurrent);

          if (left - 1 === 2) {
            left--; // Do not show the ellipsis if there is only one to hide
          }

          let right = Math.min(this.current + this.afterCurrent, this.pageCount);

          if (this.pageCount - right === 2) {
            right++; // Do not show the ellipsis if there is only one to hide
          }

          const pages = [];

          for (let i = left; i <= right; i++) {
            pages.push(this.getPage(i));
          }

          return pages;
        },

        hasDefaultSlot() {
          return this.$scopedSlots.default;
        },

        hasPreviousSlot() {
          return this.$scopedSlots.previous;
        },

        hasNextSlot() {
          return this.$scopedSlots.next;
        }

      },
      watch: {
        /**
        * If current page is trying to be greater than page count, set to last.
        */
        pageCount(value) {
          if (this.current > value) this.last();
        }

      },
      methods: {
        /**
        * Previous button click listener.
        */
        prev(event) {
          this.changePage(this.current - 1, event);
        },

        /**
        * Next button click listener.
        */
        next(event) {
          this.changePage(this.current + 1, event);
        },

        /**
        * First button click listener.
        */
        first(event) {
          this.changePage(1, event);
        },

        /**
        * Last button click listener.
        */
        last(event) {
          this.changePage(this.pageCount, event);
        },

        changePage(num, event) {
          if (this.current === num || num < 1 || num > this.pageCount) return;
          this.$emit('change', num);
          this.$emit('update:current', num); // Set focus on element to keep tab order

          if (event && event.target) {
            this.$nextTick(() => event.target.focus());
          }
        },

        getPage(num, options = {}) {
          return {
            number: num,
            isCurrent: this.current === num,
            click: event => this.changePage(num, event),
            disabled: options.disabled || false,
            class: options.class || '',
            'aria-label': options['aria-label'] || this.getAriaPageLabel(num, this.current === num)
          };
        },

        /**
        * Get text for aria-label according to page number.
        */
        getAriaPageLabel(pageNumber, isCurrent) {
          if (this.ariaPageLabel && (!isCurrent || !this.ariaCurrentLabel)) {
            return this.ariaPageLabel + ' ' + pageNumber + '.';
          } else if (this.ariaPageLabel && isCurrent && this.ariaCurrentLabel) {
            return this.ariaCurrentLabel + ', ' + this.ariaPageLabel + ' ' + pageNumber + '.';
          }

          return null;
        }

      }
    };

    /* script */
    const __vue_script__$s = script$s;

    /* template */
    var __vue_render__$q = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('nav',{class:_vm.rootClasses},[(_vm.hasPreviousSlot)?_vm._t("previous",[_c('o-icon',{attrs:{"icon":_vm.iconPrev,"pack":_vm.iconPack,"both":"","aria-hidden":"true"}})],{"linkClass":_vm.linkClasses,"linkCurrentClass":_vm.linkCurrentClasses,"page":_vm.getPage(_vm.current - 1, {
                class: _vm.prevBtnClasses,
                'aria-label': _vm.ariaPreviousLabel
        })}):_c('o-pagination-button',{class:_vm.prevBtnClasses,attrs:{"linkClass":_vm.linkClasses,"linkCurrentClass":_vm.linkCurrentClasses,"page":_vm.getPage(_vm.current - 1)}},[_c('o-icon',{attrs:{"icon":_vm.iconPrev,"pack":_vm.iconPack,"both":"","aria-hidden":"true"}})],1),(_vm.hasNextSlot)?_vm._t("next",[_c('o-icon',{attrs:{"icon":_vm.iconNext,"pack":_vm.iconPack,"both":"","aria-hidden":"true"}})],{"linkClass":_vm.linkClasses,"linkCurrentClass":_vm.linkCurrentClasses,"page":_vm.getPage(_vm.current + 1, {
                class: _vm.nextBtnClasses,
                'aria-label': _vm.ariaNextLabel,
        })}):_c('o-pagination-button',{class:_vm.nextBtnClasses,attrs:{"linkClass":_vm.linkClasses,"linkCurrentClass":_vm.linkCurrentClasses,"page":_vm.getPage(_vm.current + 1)}},[_c('o-icon',{attrs:{"icon":_vm.iconNext,"pack":_vm.iconPack,"both":"","aria-hidden":"true"}})],1),(_vm.simple)?_c('small',{class:_vm.infoClasses},[(_vm.perPage == 1)?[_vm._v(" "+_vm._s(_vm.firstItem)+" / "+_vm._s(_vm.total)+" ")]:[_vm._v(" "+_vm._s(_vm.firstItem)+"-"+_vm._s(Math.min(_vm.current * _vm.perPage, _vm.total))+" / "+_vm._s(_vm.total)+" ")]],2):_c('ul',{class:_vm.listClasses},[(_vm.hasFirst)?_c('li',[(_vm.hasDefaultSlot)?_vm._t("default",null,{"page":_vm.getPage(1),"linkClass":_vm.linkClasses,"linkCurrentClass":_vm.linkCurrentClasses}):_c('o-pagination-button',{attrs:{"linkClass":_vm.linkClasses,"linkCurrentClass":_vm.linkCurrentClasses,"page":_vm.getPage(1)}})],2):_vm._e(),(_vm.hasFirstEllipsis)?_c('li',[_c('span',{class:_vm.ellipsisClasses},[_vm._v("")])]):_vm._e(),_vm._l((_vm.pagesInRange),function(page){return _c('li',{key:page.number},[(_vm.hasDefaultSlot)?_vm._t("default",null,{"page":page,"linkClass":_vm.linkClasses,"linkCurrentClass":_vm.linkCurrentClasses}):_c('o-pagination-button',{attrs:{"linkClass":_vm.linkClasses,"linkCurrentClass":_vm.linkCurrentClasses,"page":page}})],2)}),(_vm.hasLastEllipsis)?_c('li',[_c('span',{class:_vm.ellipsisClasses},[_vm._v("")])]):_vm._e(),(_vm.hasLast)?_c('li',[(_vm.hasDefaultSlot)?_vm._t("default",null,{"page":_vm.getPage(_vm.pageCount),"linkClass":_vm.linkClasses,"linkCurrentClass":_vm.linkCurrentClasses}):_c('o-pagination-button',{attrs:{"linkClass":_vm.linkClasses,"linkCurrentClass":_vm.linkCurrentClasses,"page":_vm.getPage(_vm.pageCount)}})],2):_vm._e()],2)],2)};
    var __vue_staticRenderFns__$q = [];

      /* style */
      const __vue_inject_styles__$s = undefined;
      /* scoped */
      const __vue_scope_id__$s = undefined;
      /* module identifier */
      const __vue_module_identifier__$s = undefined;
      /* functional template */
      const __vue_is_functional_template__$s = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$s = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$q, staticRenderFns: __vue_staticRenderFns__$q },
        __vue_inject_styles__$s,
        __vue_script__$s,
        __vue_scope_id__$s,
        __vue_is_functional_template__$s,
        __vue_module_identifier__$s,
        false,
        undefined,
        undefined,
        undefined
      );

    const Plugin$h = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$s);
        registerComponent(Vue, __vue_component__$r);
      }

    };
    use(Plugin$h);

    //
    /**
     * Select an option from a set
     * @displayName Radio
     * @example ./examples/Radio.md
     * @style _radio.scss
     */

    var script$t = {
      name: 'ORadio',
      mixins: [BaseComponentMixin, CheckRadioMixin],
      configField: 'radio',
      props: {
        rootClass: [String, Function, Array],
        disabledClass: [String, Function, Array],
        checkedClass: [String, Function, Array],
        checkCheckedClass: [String, Function, Array],
        checkClass: [String, Function, Array],
        labelClass: [String, Function, Array],
        sizeClass: [String, Function, Array],
        variantClass: [String, Function, Array]
      },
      computed: {
        isChecked() {
          return this.value === this.nativeValue;
        },

        rootClasses() {
          return [this.computedClass('rootClass', 'o-radio'), {
            [this.computedClass('sizeClass', 'o-radio--', this.size)]: this.size
          }, {
            [this.computedClass('checkedClass', 'o-radio--checked')]: this.isChecked
          }, {
            [this.computedClass('disabledClass', 'o-radio--disabled')]: this.disabled
          }, {
            [this.computedClass('variantClass', 'o-radio--', this.variant)]: this.variant
          }];
        },

        checkClasses() {
          return [this.computedClass('checkClass', 'o-radio__check'), {
            [this.computedClass('checkCheckedClass', 'o-radio__check--checked')]: this.isChecked
          }];
        },

        labelClasses() {
          return [this.computedClass('labelClass', 'o-radio__label')];
        }

      }
    };

    /* script */
    const __vue_script__$t = script$t;

    /* template */
    var __vue_render__$r = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{ref:"label",class:_vm.rootClasses,attrs:{"disabled":_vm.disabled},on:{"click":function($event){$event.stopPropagation();return _vm.focus($event)},"keydown":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }$event.preventDefault();return _vm.$refs.label.click()}}},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.computedValue),expression:"computedValue"}],ref:"input",class:_vm.checkClasses,attrs:{"type":"radio","disabled":_vm.disabled,"required":_vm.required,"name":_vm.name},domProps:{"value":_vm.nativeValue,"checked":_vm._q(_vm.computedValue,_vm.nativeValue)},on:{"click":function($event){$event.stopPropagation();},"change":function($event){_vm.computedValue=_vm.nativeValue;}}}),_c('span',{class:_vm.labelClasses},[_vm._t("default")],2)])};
    var __vue_staticRenderFns__$r = [];

      /* style */
      const __vue_inject_styles__$t = undefined;
      /* scoped */
      const __vue_scope_id__$t = undefined;
      /* module identifier */
      const __vue_module_identifier__$t = undefined;
      /* functional template */
      const __vue_is_functional_template__$t = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$t = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$r, staticRenderFns: __vue_staticRenderFns__$r },
        __vue_inject_styles__$t,
        __vue_script__$t,
        __vue_scope_id__$t,
        __vue_is_functional_template__$t,
        __vue_module_identifier__$t,
        false,
        undefined,
        undefined,
        undefined
      );

    const Plugin$i = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$t);
      }

    };
    use(Plugin$i);

    const Plugin$j = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$a);
      }

    };
    use(Plugin$j);

    /**
     * A placeholder for content to load
     * @displayName Skeleton
     * @example ./examples/Skeleton.md
     * @style _skeleton.scss
     */

    var script$u = {
      name: 'OSkeleton',
      mixins: [BaseComponentMixin],
      configField: 'skeleton',
      props: {
        /** Show or hide loader	 */
        active: {
          type: Boolean,
          default: true
        },

        /** Show a loading animation */
        animated: {
          type: Boolean,
          default: true
        },

        /** Custom width */
        width: [Number, String],

        /** Custom height */
        height: [Number, String],

        /** Show a circle shape */
        circle: Boolean,

        /** Rounded style */
        rounded: {
          type: Boolean,
          default: true
        },

        /** Number of shapes to display */
        count: {
          type: Number,
          default: 1
        },

        /**
         * Skeleton position in relation to the element
         * @values left, centered, right
         */
        position: {
          type: String,
          default: 'left',

          validator(value) {
            return ['left', 'centered', 'right'].indexOf(value) > -1;
          }

        },

        /**
         * Size of skeleton
         * @values small, medium, large
         */
        size: String,
        rootClass: [String, Function, Array],
        animationClass: [String, Function, Array],
        positionClass: [String, Function, Array],
        itemClass: [String, Function, Array],
        itemRoundedClass: [String, Function, Array],
        sizeClass: [String, Function, Array]
      },

      render(h) {
        if (!this.active) return;
        const items = [];
        const width = this.width;
        const height = this.height;

        for (let i = 0; i < this.count; i++) {
          items.push(h('div', {
            staticClass: this.computedClass('itemClass', 'o-sklt__item'),
            class: [{
              [this.computedClass('itemRoundedClass', 'o-sklt__item--rounded')]: this.rounded
            }, {
              [this.computedClass('animationClass', 'o-sklt__item--animated')]: this.animated
            }, {
              [this.computedClass('sizeClass', 'o-sklt__item--', this.size)]: this.size
            }],
            key: i,
            style: {
              height: toCssDimension(height),
              width: toCssDimension(width),
              borderRadius: this.circle ? '50%' : null
            }
          }));
        }

        return h('div', {
          staticClass: this.computedClass('rootClass', 'o-sklt'),
          class: [{
            [this.computedClass('positionClass', 'o-sklt--', this.position)]: this.position
          }]
        }, items);
      }

    };

    /* script */
    const __vue_script__$u = script$u;

    /* template */

      /* style */
      const __vue_inject_styles__$u = undefined;
      /* scoped */
      const __vue_scope_id__$u = undefined;
      /* module identifier */
      const __vue_module_identifier__$u = undefined;
      /* functional template */
      const __vue_is_functional_template__$u = undefined;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$u = /*#__PURE__*/normalizeComponent(
        {},
        __vue_inject_styles__$u,
        __vue_script__$u,
        __vue_scope_id__$u,
        __vue_is_functional_template__$u,
        __vue_module_identifier__$u,
        false,
        undefined,
        undefined,
        undefined
      );

    const Plugin$k = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$u);
      }

    };
    use(Plugin$k);

    //
    /**
     * A sidebar to use as left/right overlay or static
     * @displayName Sidebar
     * @example ./examples/Sidebar.md
     * @style _sidebar.scss
     */

    var script$v = {
      name: 'OSidebar',
      mixins: [BaseComponentMixin, MatchMediaMixin],
      configField: 'sidebar',
      props: {
        /** To control the behaviour of the sidebar programmatically, use the .sync modifier (Vue 2.x) or v-model:open (Vue 3.x) to make it two-way binding */
        open: Boolean,

        /**
        * Color of the sidebar, optional
        * @values primary, info, success, warning, danger, and any other custom color
        */
        variant: [String, Object],

        /** Show an overlay like modal */
        overlay: Boolean,

        /**
         * Skeleton position in relation to the window
         * @values fixed, absolute, static
         */
        position: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'sidebar.position', 'fixed');
          },
          validator: value => {
            return ['fixed', 'absolute', 'static'].indexOf(value) >= 0;
          }
        },

        /** Show sidebar in fullheight */
        fullheight: Boolean,

        /** Show sidebar in fullwidth */
        fullwidth: Boolean,

        /** Show the sidebar on right */
        right: Boolean,

        /**
         * Custom layout on mobile
         * @values fullwidth, reduced, hidden
         */
        mobile: {
          type: String,
          validator: value => {
            return ['', 'fullwidth', 'reduced', 'hidden'].indexOf(value) >= 0;
          }
        },

        /** Show a small sidebar */
        reduce: Boolean,

        /** Expand sidebar on hover when reduced or mobile is reduce */
        expandOnHover: Boolean,

        /** Expand sidebar on hover with fixed position when reduced or mobile is reduce */
        expandOnHoverFixed: Boolean,

        /**
         * Sidebar cancel options
         * @values true, false, 'escape', 'outside'
         */
        canCancel: {
          type: [Array, Boolean],
          default: () => {
            return getValueByPath(getOptions(), 'sidebar.canCancel', ['escape', 'outside']);
          }
        },

        /**
         * Callback on cancel
         */
        onCancel: {
          type: Function,
          default: () => {}
        },
        scroll: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'sidebar.scroll', 'clip');
          },
          validator: value => {
            return ['clip', 'keep'].indexOf(value) >= 0;
          }
        },
        rootClass: [String, Function, Array],
        overlayClass: [String, Function, Array],
        contentClass: [String, Function, Array],
        fixedClass: [String, Function, Array],
        staticClass: [String, Function, Array],
        absoluteClass: [String, Function, Array],
        fullheightClass: [String, Function, Array],
        fullwidthClass: [String, Function, Array],
        rightClass: [String, Function, Array],
        reduceClass: [String, Function, Array],
        expandOnHoverClass: [String, Function, Array],
        expandOnHoverFixedClass: [String, Function, Array],
        variantClass: [String, Function, Array],
        mobileClass: [String, Function, Array],
        scrollClipClass: [String, Function, Array],
        noScrollClass: [String, Function, Array],
        hiddenClass: [String, Function, Array],
        visibleClass: [String, Function, Array]
      },

      data() {
        return {
          isOpen: this.open,
          transitionName: null,
          animating: true,
          savedScrollTop: null
        };
      },

      computed: {
        rootClasses() {
          return [this.computedClass('rootClass', 'o-side'), {
            [this.computedClass('mobileClass', 'o-side--mobile')]: this.isMatchMedia
          }];
        },

        overlayClasses() {
          return [this.computedClass('overlayClass', 'o-side__overlay')];
        },

        contentClasses() {
          return [this.computedClass('contentClass', 'o-side__content'), {
            [this.computedClass('variantClass', 'o-side__content--', this.variant)]: this.variant
          }, {
            [this.computedClass('fixedClass', 'o-side__content--fixed')]: this.isFixed
          }, {
            [this.computedClass('staticClass', 'o-side__content--static')]: this.isStatic
          }, {
            [this.computedClass('absoluteClass', 'o-side__content--absolute')]: this.isAbsolute
          }, {
            [this.computedClass('fullheightClass', 'o-side__content--fullheight')]: this.fullheight
          }, {
            [this.computedClass('fullwidthClass', 'o-side__content--fullwidth')]: this.fullwidth || this.mobile === 'fullwidth' && this.isMatchMedia
          }, {
            [this.computedClass('rightClass', 'o-side__content--right')]: this.right
          }, {
            [this.computedClass('reduceClass', 'o-side__content--mini')]: this.reduce || this.mobile === 'reduced' && this.isMatchMedia
          }, {
            [this.computedClass('expandOnHoverClass', 'o-side__content--mini-expand')]: this.expandOnHover && this.mobile !== 'fullwidth'
          }, {
            [this.computedClass('expandOnHoverFixedClass', 'o-side__content--expand-mini-hover-fixed')]: this.expandOnHover && this.expandOnHoverFixed && this.mobile !== 'fullwidth'
          }, {
            [this.computedClass('visibleClass', 'o-side__content--visible')]: this.isOpen
          }, {
            [this.computedClass('hiddenClass', 'o-side__content--hidden')]: !this.isOpen
          }];
        },

        scrollClass() {
          if (this.scroll === 'clip') {
            return this.computedClass('scrollClipClass', 'o-clipped');
          }

          return this.computedClass('noScrollClass', 'o-noscroll');
        },

        cancelOptions() {
          return typeof this.canCancel === 'boolean' ? this.canCancel ? getValueByPath(getOptions(), 'sidebar.canCancel', ['escape', 'outside']) : [] : this.canCancel;
        },

        isStatic() {
          return this.position === 'static';
        },

        isFixed() {
          return this.position === 'fixed';
        },

        isAbsolute() {
          return this.position === 'absolute';
        },

        hideOnMobile() {
          return this.mobile === 'hidden' && this.isMatchMedia;
        }

      },
      watch: {
        open: {
          handler(value) {
            this.isOpen = value;

            if (this.overlay) {
              this.handleScroll();
            }

            const open = this.right ? !value : value;
            this.transitionName = !open ? 'slide-prev' : 'slide-next';
          },

          immediate: true
        }
      },
      methods: {
        /**
         * White-listed items to not close when clicked.
         * Add sidebar content and all children.
         */
        whiteList() {
          const whiteList = [];
          whiteList.push(this.$refs.sidebarContent); // Add all chidren from dropdown

          if (this.$refs.sidebarContent !== undefined) {
            const children = this.$refs.sidebarContent.querySelectorAll('*');

            for (const child of children) {
              whiteList.push(child);
            }
          }

          return whiteList;
        },

        /**
        * Keypress event that is bound to the document.
        */
        keyPress({
          key
        }) {
          if (this.isFixed) {
            if (this.isOpen && (key === 'Escape' || key === 'Esc')) this.cancel('escape');
          }
        },

        /**
        * Close the Sidebar if canCancel and call the onCancel prop (function).
        */
        cancel(method) {
          if (this.cancelOptions.indexOf(method) < 0) return;
          if (this.isStatic) return;
          this.onCancel.apply(null, arguments);
          this.close();
        },

        /**
        * Call the onCancel prop (function) and emit events
        */
        close() {
          this.isOpen = false;
          this.$emit('close');
          this.$emit('update:open', false);
        },

        /**
         * Close fixed sidebar if clicked outside.
         */
        clickedOutside(event) {
          if (this.isFixed) {
            if (this.isOpen && !this.animating) {
              if (this.whiteList().indexOf(event.target) < 0) {
                this.cancel('outside');
              }
            }
          }
        },

        /**
        * Transition before-enter hook
        */
        beforeEnter() {
          this.animating = true;
        },

        /**
        * Transition after-leave hook
        */
        afterEnter() {
          this.animating = false;
        },

        handleScroll() {
          if (typeof window === 'undefined') return;

          if (this.scroll === 'clip') {
            if (this.scrollClass) {
              if (this.open) {
                document.documentElement.classList.add(this.scrollClass);
              } else {
                document.documentElement.classList.remove(this.scrollClass);
              }

              return;
            }
          }

          this.savedScrollTop = !this.savedScrollTop ? document.documentElement.scrollTop : this.savedScrollTop;

          if (this.scrollClass) {
            if (this.open) {
              document.body.classList.add(this.scrollClass);
            } else {
              document.body.classList.remove(this.scrollClass);
            }
          }

          if (this.open) {
            document.body.style.top = `-${this.savedScrollTop}px`;
            return;
          }

          document.documentElement.scrollTop = this.savedScrollTop;
          document.body.style.top = null;
          this.savedScrollTop = null;
        }

      },

      created() {
        if (typeof window !== 'undefined') {
          document.addEventListener('keyup', this.keyPress);
          document.addEventListener('click', this.clickedOutside);
        }
      },

      mounted() {
        if (typeof window !== 'undefined') {
          if (this.isFixed) {
            document.body.appendChild(this.$el);
          }

          if (this.overlay && this.open) {
            this.handleScroll();
          }
        }
      },

      beforeDestroy() {
        if (typeof window !== 'undefined') {
          document.removeEventListener('keyup', this.keyPress);
          document.removeEventListener('click', this.clickedOutside);

          if (this.overlay) {
            // reset scroll
            const savedScrollTop = !this.savedScrollTop ? document.documentElement.scrollTop : this.savedScrollTop;

            if (this.scrollClass) {
              document.body.classList.remove(this.scrollClass);
              document.documentElement.classList.remove(this.scrollClass);
            }

            document.documentElement.scrollTop = savedScrollTop;
            document.body.style.top = null;
          }
        }

        if (this.isFixed) {
          removeElement(this.$el);
        }
      }

    };

    /* script */
    const __vue_script__$v = script$v;

    /* template */
    var __vue_render__$s = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{directives:[{name:"show",rawName:"v-show",value:(!_vm.hideOnMobile),expression:"!hideOnMobile"}],class:_vm.rootClasses},[(_vm.overlay && _vm.isOpen)?_c('div',{class:_vm.overlayClasses}):_vm._e(),_c('transition',{attrs:{"name":_vm.transitionName},on:{"before-enter":_vm.beforeEnter,"after-enter":_vm.afterEnter}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.isOpen),expression:"isOpen"}],ref:"sidebarContent",class:_vm.contentClasses},[_vm._t("default")],2)])],1)};
    var __vue_staticRenderFns__$s = [];

      /* style */
      const __vue_inject_styles__$v = undefined;
      /* scoped */
      const __vue_scope_id__$v = undefined;
      /* module identifier */
      const __vue_module_identifier__$v = undefined;
      /* functional template */
      const __vue_is_functional_template__$v = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$v = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$s, staticRenderFns: __vue_staticRenderFns__$s },
        __vue_inject_styles__$v,
        __vue_script__$v,
        __vue_scope_id__$v,
        __vue_is_functional_template__$v,
        __vue_module_identifier__$v,
        false,
        undefined,
        undefined,
        undefined
      );

    const Plugin$l = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$v);
      }

    };
    use(Plugin$l);

    //
    const opposites = {
      top: 'bottom',
      bottom: 'top',
      right: 'left',
      left: 'right'
    };

    function intersectionArea(a, b) {
      const left = Math.max(a.left, b.left);
      const right = Math.min(a.right, b.right);
      const top = Math.max(a.top, b.top);
      const bottom = Math.min(a.bottom, b.bottom);
      return Math.max(right - left, 0) * Math.max(bottom - top, 0);
    }
    /**
     * @param rect the bounding rectangle of the trigger element
     * @return the "anchor points" (points where the arrow attaches) for each side of the tooltip
     */


    const anchors = rect => ({
      top: {
        x: (rect.left + rect.right) * 0.5,
        y: rect.top
      },
      bottom: {
        x: (rect.left + rect.right) * 0.5,
        y: rect.bottom
      },
      left: {
        x: rect.left,
        y: (rect.top + rect.bottom) * 0.5
      },
      right: {
        x: rect.right,
        y: (rect.top + rect.bottom) * 0.5
      }
    });
    /**
     * Display a brief helper text to your user
     * @displayName Tooltip
     * @example ./examples/Tooltip.md
     * @style _tooltip.scss
     */


    var script$w = {
      name: 'OTooltip',
      mixins: [BaseComponentMixin],
      configField: 'tooltip',
      props: {
        /** Whether tooltip is active or not, use the .sync modifier (Vue 2.x) or v-model:active (Vue 3.x) to make it two-way binding */
        active: {
          type: Boolean,
          default: true
        },

        /** Tooltip text */
        label: String,

        /** Tooltip delay before it appears (number in ms) */
        delay: Number,

        /**
         * Tooltip position in relation to the element
         * @values top, bottom, left, right
         */
        position: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'tooltip.position', 'top');
          },

          validator(value) {
            return ['top', 'bottom', 'left', 'right', 'auto'].indexOf(value) > -1;
          }

        },

        /**
         * Tooltip trigger events
         * @values hover, click, focus, contextmenu
         */
        triggers: {
          type: Array,
          default: () => {
            return getValueByPath(getOptions(), 'tooltip.triggers', ['hover']);
          }
        },

        /** Tooltip will be always active */
        always: Boolean,

        /** Tooltip will have an animation */
        animated: {
          type: Boolean,
          default: true
        },

        /** Tooltip default animation */
        animation: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'tooltip.animation', 'fade');
          }
        },

        /**
         * Tooltip auto close options
         * @values true, false, 'inside', 'outside'
         */
        autoClose: {
          type: [Array, Boolean],
          default: true
        },

        /** Tooltip will be multilined */
        multiline: Boolean,

        /** Append tooltip content to body */
        appendToBody: Boolean,

        /**
        * Color of the tooltip
        * @values primary, info, success, warning, danger, and any other custom color
        */
        variant: [String, Function, Array],
        rootClass: [String, Function, Array],
        contentClass: [String, Function, Array],
        orderClass: [String, Function, Array],
        triggerClass: [String, Function, Array],
        multilineClass: [String, Function, Array],
        alwaysClass: [String, Function, Array],
        variantClass: [String, Function, Array],
        arrowClass: [String, Function, Array],
        arrowOrderClass: [String, Function, Array]
      },

      data() {
        return {
          isActive: false,
          triggerStyle: {},
          bodyEl: undefined,
          // Used to append to body
          metrics: null // Used for automatic tooltip positioning

        };
      },

      computed: {
        rootClasses() {
          return [this.computedClass('rootClass', 'o-tip')];
        },

        triggerClasses() {
          return [this.computedClass('triggerClass', 'o-tip__trigger')];
        },

        arrowClasses() {
          return [this.computedClass('arrowClass', 'o-tip__arrow'), {
            [this.computedClass('arrowOrderClass', 'o-tip__arrow--', this.newPosition)]: this.newPosition
          }, {
            [this.computedClass('variantArrowClass', 'o-tip__arrow--', this.variant)]: this.variant
          }];
        },

        contentClasses() {
          return [this.computedClass('contentClass', 'o-tip__content'), {
            [this.computedClass('orderClass', 'o-tip__content--', this.newPosition)]: this.newPosition
          }, {
            [this.computedClass('variantClass', 'o-tip__content--', this.variant)]: this.variant
          }, {
            [this.computedClass('multilineClass', 'o-tip__content--multiline')]: this.multiline
          }, {
            [this.computedClass('alwaysClass', 'o-tip__content--always')]: this.always
          }];
        },

        newAnimation() {
          return this.animated ? this.animation : undefined;
        },

        newPosition() {
          if (this.position !== 'auto') {
            return this.position;
          }

          const defaultPosition = getValueByPath(getOptions(), 'tooltip.position', 'top');
          let bestPosition = defaultPosition;

          if (this.metrics != null) {
            let viewRect;
            const viewport = window.visualViewport;

            if (viewport != undefined) {
              if (isWebKit()) {
                // On WebKit, getBoundingClientRect offsets relative to the the visual viewport's origin, not the layout viewport's.
                // See https://bugs.webkit.org/show_bug.cgi?id=170981
                viewRect = new DOMRect(0, 0, viewport.width, viewport.height);
              } else {
                viewRect = new DOMRect(viewport.offsetLeft, viewport.offsetTop, viewport.width, viewport.height);
              }
            } else {
              viewRect = new DOMRect(0, 0, document.documentElement.clientWidth, document.documentElement.clientHeight);
            }

            const triggerAnchors = anchors(this.metrics.trigger);
            const contentRect = this.metrics.content;
            const contentAnchors = anchors(contentRect);

            const contentRectAtAnchor = pos => {
              const triggerAnchor = triggerAnchors[pos];
              const contentAnchor = contentAnchors[opposites[pos]]; // Translates contentRect so contentAnchor is on top of triggerAnchor
              // NOTE: this doesn't account for the extra offset that the tooltip arrow provides.
              // That offset should be small, and it's tricky to get it from the CSS.

              return new DOMRect(contentRect.x + (triggerAnchor.x - contentAnchor.x), contentRect.y + (triggerAnchor.y - contentAnchor.y), contentRect.width, contentRect.height);
            };

            const defaultOpposite = opposites[defaultPosition];
            const crossPosition = defaultPosition === 'top' || defaultPosition === 'bottom' ? 'left' : 'top';
            const crossOpposite = opposites[crossPosition]; // In descending order of priority

            const positions = [defaultPosition, defaultOpposite, crossPosition, crossOpposite];
            let maxOverlap = 0;

            for (const position of positions) {
              const overlap = intersectionArea(viewRect, contentRectAtAnchor(position));

              if (overlap > maxOverlap) {
                maxOverlap = overlap;
                bestPosition = position;
              }
            }
          }

          return bestPosition;
        }

      },
      watch: {
        isActive(value) {
          this.$emit(value ? 'open' : 'close');

          if (value && this.position === 'auto') {
            this.$nextTick(() => {
              this.metrics = {
                content: this.$refs.content.getBoundingClientRect(),
                trigger: this.$refs.trigger.getBoundingClientRect()
              };
            });
          }

          if (value && this.appendToBody) {
            this.updateAppendToBody();
          }
        }

      },
      methods: {
        updateAppendToBody() {
          const tooltip = this.$refs.tooltip;
          const trigger = this.$refs.trigger;

          if (tooltip && trigger) {
            // update wrapper tooltip
            const tooltipEl = this.$data.bodyEl.children[0];
            tooltipEl.classList.forEach(item => tooltipEl.classList.remove(...item.split(' ')));

            if (this.$vnode && this.$vnode.data && this.$vnode.data.staticClass) {
              tooltipEl.classList.add(this.$vnode.data.staticClass);
            }

            this.rootClasses.forEach(item => {
              if (typeof item === 'object') {
                Object.keys(item).filter(key => key && item[key]).forEach(key => tooltipEl.classList.add(key));
              } else {
                tooltipEl.classList.add(...item.split(' '));
              }
            });
            tooltipEl.style.width = `${trigger.clientWidth}px`;
            tooltipEl.style.height = `${trigger.clientHeight}px`;
            const rect = trigger.getBoundingClientRect();
            const top = rect.top + window.scrollY;
            const left = rect.left + window.scrollX;
            const wrapper = this.$data.bodyEl;
            wrapper.style.position = 'absolute';
            wrapper.style.top = `${top}px`;
            wrapper.style.left = `${left}px`;
            wrapper.style.zIndex = this.isActive || this.always ? '99' : '-1';
            this.triggerStyle = {
              zIndex: this.isActive || this.always ? '100' : undefined
            };
          }
        },

        onClick() {
          if (this.triggers.indexOf('click') < 0) return; // if not active, toggle after clickOutside event
          // this fixes toggling programmatic

          this.$nextTick(() => {
            setTimeout(() => this.open());
          });
        },

        onHover() {
          if (this.triggers.indexOf('hover') < 0) return;
          this.open();
        },

        onFocus() {
          if (this.triggers.indexOf('focus') < 0) return;
          this.open();
        },

        onContextMenu(event) {
          if (this.triggers.indexOf('contextmenu') < 0) return;
          event.preventDefault();
          this.open();
        },

        open() {
          if (this.delay) {
            this.timer = setTimeout(() => {
              this.isActive = true;
              this.timer = null;
            }, this.delay);
          } else {
            this.isActive = true;
          }
        },

        close() {
          if (typeof this.autoClose === 'boolean') {
            this.isActive = !this.autoClose;
          }

          if (this.autoClose && this.timer) clearTimeout(this.timer);
        },

        /**
        * Close tooltip if clicked outside.
        */
        clickedOutside(event) {
          if (this.isActive) {
            if (Array.isArray(this.autoClose)) {
              if (this.autoClose.indexOf('outside') >= 0) {
                if (!this.isInWhiteList(event.target)) this.isActive = false;
              }

              if (this.autoClose.indexOf('inside') >= 0) {
                if (this.isInWhiteList(event.target)) this.isActive = false;
              }
            }
          }
        },

        /**
         * Keypress event that is bound to the document
         */
        keyPress({
          key
        }) {
          if (this.isActive && (key === 'Escape' || key === 'Esc')) {
            if (Array.isArray(this.autoClose)) {
              if (this.autoClose.indexOf('escape') >= 0) this.isActive = false;
            }
          }
        },

        /**
        * White-listed items to not close when clicked.
        */
        isInWhiteList(el) {
          if (el === this.$refs.content) return true; // All chidren from content

          if (this.$refs.content !== undefined) {
            const children = this.$refs.content.querySelectorAll('*');

            for (const child of children) {
              if (el === child) {
                return true;
              }
            }
          }

          return false;
        }

      },

      mounted() {
        if (this.appendToBody) {
          this.$data.bodyEl = createAbsoluteElement(this.$refs.content);
          this.updateAppendToBody();
        }
      },

      created() {
        if (typeof window !== 'undefined') {
          document.addEventListener('click', this.clickedOutside);
          document.addEventListener('keyup', this.keyPress);
        }
      },

      beforeDestroy() {
        if (typeof window !== 'undefined') {
          document.removeEventListener('click', this.clickedOutside);
          document.removeEventListener('keyup', this.keyPress);
        }

        if (this.appendToBody) {
          removeElement(this.$data.bodyEl);
        }
      }

    };

    /* script */
    const __vue_script__$w = script$w;

    /* template */
    var __vue_render__$t = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{ref:"tooltip",class:_vm.rootClasses},[_c('transition',{attrs:{"name":_vm.newAnimation},on:{"after-leave":function($event){_vm.metrics = null;},"enter-cancelled":function($event){_vm.metrics = null;}}},[_c('div',{directives:[{name:"show",rawName:"v-show",value:(_vm.active && (_vm.isActive || _vm.always)),expression:"active && (isActive || always)"}],ref:"content",class:_vm.contentClasses},[_c('span',{class:_vm.arrowClasses}),(_vm.label)?[_vm._v(_vm._s(_vm.label))]:(_vm.$slots.default)?[_vm._t("content")]:_vm._e()],2)]),_c('div',{ref:"trigger",class:_vm.triggerClasses,style:(_vm.triggerStyle),on:{"click":_vm.onClick,"contextmenu":_vm.onContextMenu,"mouseenter":_vm.onHover,"!focus":function($event){return _vm.onFocus($event)},"!blur":function($event){return _vm.close($event)},"mouseleave":_vm.close}},[_vm._t("default")],2)],1)};
    var __vue_staticRenderFns__$t = [];

      /* style */
      const __vue_inject_styles__$w = undefined;
      /* scoped */
      const __vue_scope_id__$w = undefined;
      /* module identifier */
      const __vue_module_identifier__$w = undefined;
      /* functional template */
      const __vue_is_functional_template__$w = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$w = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$t, staticRenderFns: __vue_staticRenderFns__$t },
        __vue_inject_styles__$w,
        __vue_script__$w,
        __vue_scope_id__$w,
        __vue_is_functional_template__$w,
        __vue_module_identifier__$w,
        false,
        undefined,
        undefined,
        undefined
      );

    //
    var script$x = {
      name: 'OSliderThumb',
      components: {
        [__vue_component__$w.name]: __vue_component__$w
      },
      configField: 'slider',
      inheritAttrs: false,
      inject: {
        $slider: {
          name: '$slider'
        }
      },
      props: {
        value: {
          type: Number,
          default: 0
        },
        variant: {
          type: String,
          default: ''
        },
        tooltip: {
          type: Boolean,
          default: true
        },
        indicator: {
          type: Boolean,
          default: false
        },
        customFormatter: Function,
        format: {
          type: String,
          default: 'raw',
          validator: value => {
            return ['raw', 'percent'].indexOf(value) >= 0;
          }
        },
        locale: {
          type: [String, Array],
          default: () => {
            return getValueByPath(getOptions(), 'locale');
          }
        },
        tooltipAlways: {
          type: Boolean,
          default: false
        }
      },

      data() {
        return {
          isFocused: false,
          dragging: false,
          startX: 0,
          startPosition: 0,
          newPosition: null,
          oldValue: this.value
        };
      },

      computed: {
        disabled() {
          return this.$parent.disabled;
        },

        max() {
          return this.$parent.max;
        },

        min() {
          return this.$parent.min;
        },

        step() {
          return this.$parent.step;
        },

        precision() {
          return this.$parent.precision;
        },

        currentPosition() {
          return `${(this.value - this.min) / (this.max - this.min) * 100}%`;
        },

        wrapperStyle() {
          return {
            left: this.currentPosition
          };
        },

        formattedValue() {
          if (typeof this.customFormatter !== 'undefined') {
            return this.customFormatter(this.value);
          }

          if (this.format === 'percent') {
            return new Intl.NumberFormat(this.locale, {
              style: 'percent'
            }).format((this.value - this.min) / (this.max - this.min));
          }

          return new Intl.NumberFormat(this.locale).format(this.value);
        }

      },
      methods: {
        onFocus() {
          this.isFocused = true;
        },

        onBlur() {
          this.isFocused = false;
        },

        onButtonDown(event) {
          if (this.disabled) return;
          event.preventDefault();
          this.onDragStart(event);

          if (typeof window !== 'undefined') {
            document.addEventListener('mousemove', this.onDragging);
            document.addEventListener('touchmove', this.onDragging);
            document.addEventListener('mouseup', this.onDragEnd);
            document.addEventListener('touchend', this.onDragEnd);
            document.addEventListener('contextmenu', this.onDragEnd);
          }
        },

        onLeftKeyDown() {
          if (this.disabled || this.value === this.min) return;
          this.newPosition = parseFloat(this.currentPosition) - this.step / (this.max - this.min) * 100;
          this.setPosition(this.newPosition);
          this.$parent.emitValue('change');
        },

        onRightKeyDown() {
          if (this.disabled || this.value === this.max) return;
          this.newPosition = parseFloat(this.currentPosition) + this.step / (this.max - this.min) * 100;
          this.setPosition(this.newPosition);
          this.$parent.emitValue('change');
        },

        onHomeKeyDown() {
          if (this.disabled || this.value === this.min) return;
          this.newPosition = 0;
          this.setPosition(this.newPosition);
          this.$parent.emitValue('change');
        },

        onEndKeyDown() {
          if (this.disabled || this.value === this.max) return;
          this.newPosition = 100;
          this.setPosition(this.newPosition);
          this.$parent.emitValue('change');
        },

        onDragStart(event) {
          this.dragging = true;
          this.$emit('dragstart');

          if (event.type === 'touchstart') {
            event.clientX = event.touches[0].clientX;
          }

          this.startX = event.clientX;
          this.startPosition = parseFloat(this.currentPosition);
          this.newPosition = this.startPosition;
        },

        onDragging(event) {
          if (this.dragging) {
            if (event.type === 'touchmove') {
              event.clientX = event.touches[0].clientX;
            }

            const diff = (event.clientX - this.startX) / this.$parent.sliderSize() * 100;
            this.newPosition = this.startPosition + diff;
            this.setPosition(this.newPosition);
          }
        },

        onDragEnd() {
          this.dragging = false;
          this.$emit('dragend');

          if (this.value !== this.oldValue) {
            this.$parent.emitValue('change');
          }

          this.setPosition(this.newPosition);

          if (typeof window !== 'undefined') {
            document.removeEventListener('mousemove', this.onDragging);
            document.removeEventListener('touchmove', this.onDragging);
            document.removeEventListener('mouseup', this.onDragEnd);
            document.removeEventListener('touchend', this.onDragEnd);
            document.removeEventListener('contextmenu', this.onDragEnd);
          }
        },

        setPosition(percent) {
          if (percent === null || isNaN(percent)) return;

          if (percent < 0) {
            percent = 0;
          } else if (percent > 100) {
            percent = 100;
          }

          const stepLength = 100 / ((this.max - this.min) / this.step);
          const steps = Math.round(percent / stepLength);
          let value = steps * stepLength / 100 * (this.max - this.min) + this.min;
          value = parseFloat(value.toFixed(this.precision));
          this.$emit('input', value);

          if (!this.dragging && value !== this.oldValue) {
            this.oldValue = value;
          }
        }

      }
    };

    /* script */
    const __vue_script__$x = script$x;

    /* template */
    var __vue_render__$u = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.$slider.thumbWrapperClasses,style:(_vm.wrapperStyle)},[_c('o-tooltip',{attrs:{"label":_vm.formattedValue,"variant":_vm.variant,"always":_vm.dragging || _vm.isFocused || _vm.tooltipAlways,"active":!_vm.disabled && _vm.tooltip}},[_c('div',_vm._b({class:_vm.$slider.thumbClasses,attrs:{"tabindex":_vm.disabled ? false : 0},on:{"mousedown":_vm.onButtonDown,"touchstart":_vm.onButtonDown,"focus":_vm.onFocus,"blur":_vm.onBlur,"keydown":[function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"left",37,$event.key,["Left","ArrowLeft"])){ return null; }if('button' in $event && $event.button !== 0){ return null; }$event.preventDefault();return _vm.onLeftKeyDown($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"right",39,$event.key,["Right","ArrowRight"])){ return null; }if('button' in $event && $event.button !== 2){ return null; }$event.preventDefault();return _vm.onRightKeyDown($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"down",40,$event.key,["Down","ArrowDown"])){ return null; }$event.preventDefault();return _vm.onLeftKeyDown($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"up",38,$event.key,["Up","ArrowUp"])){ return null; }$event.preventDefault();return _vm.onRightKeyDown($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"home",undefined,$event.key,undefined)){ return null; }$event.preventDefault();return _vm.onHomeKeyDown($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"end",undefined,$event.key,undefined)){ return null; }$event.preventDefault();return _vm.onEndKeyDown($event)}]}},'div',_vm.$attrs,false),[(_vm.indicator)?_c('span',[_vm._v(_vm._s(_vm.formattedValue))]):_vm._e()])])],1)};
    var __vue_staticRenderFns__$u = [];

      /* style */
      const __vue_inject_styles__$x = undefined;
      /* scoped */
      const __vue_scope_id__$x = undefined;
      /* module identifier */
      const __vue_module_identifier__$x = undefined;
      /* functional template */
      const __vue_is_functional_template__$x = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$x = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$u, staticRenderFns: __vue_staticRenderFns__$u },
        __vue_inject_styles__$x,
        __vue_script__$x,
        __vue_scope_id__$x,
        __vue_is_functional_template__$x,
        __vue_module_identifier__$x,
        false,
        undefined,
        undefined,
        undefined
      );

    //
    /**
     * @displayName Slider Tick
     */

    var script$y = {
      name: 'OSliderTick',
      mixins: [BaseComponentMixin],
      configField: 'slider',
      inject: {
        $slider: {
          name: '$slider'
        }
      },
      props: {
        /** Value of single tick */
        value: {
          variant: Number,
          default: 0
        },
        tickClass: [String, Function, Array],
        tickHiddenClass: [String, Function, Array],
        tickLabelClass: [String, Function, Array]
      },
      computed: {
        rootClasses() {
          return [this.computedClass('tickClass', 'o-slide__tick'), {
            [this.computedClass('tickHiddenClass', 'o-slide__tick--hidden')]: this.hidden
          }];
        },

        tickLabelClasses() {
          return [this.computedClass('tickLabelClass', 'o-slide__tick-label')];
        },

        position() {
          const pos = (this.value - this.$parent.min) / (this.$parent.max - this.$parent.min) * 100;
          return pos >= 0 && pos <= 100 ? pos : 0;
        },

        hidden() {
          return this.value === this.$parent.min || this.value === this.$parent.max;
        },

        tickStyle() {
          return {
            'left': this.position + '%'
          };
        }

      },

      created() {
        if (!this.$slider) {
          throw new Error('You should wrap oSliderTick on a oSlider');
        }
      }

    };

    /* script */
    const __vue_script__$y = script$y;

    /* template */
    var __vue_render__$v = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.rootClasses,style:(_vm.tickStyle)},[(_vm.$slots.default)?_c('span',{class:_vm.tickLabelClasses},[_vm._t("default")],2):_vm._e()])};
    var __vue_staticRenderFns__$v = [];

      /* style */
      const __vue_inject_styles__$y = undefined;
      /* scoped */
      const __vue_scope_id__$y = undefined;
      /* module identifier */
      const __vue_module_identifier__$y = undefined;
      /* functional template */
      const __vue_is_functional_template__$y = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$y = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$v, staticRenderFns: __vue_staticRenderFns__$v },
        __vue_inject_styles__$y,
        __vue_script__$y,
        __vue_scope_id__$y,
        __vue_is_functional_template__$y,
        __vue_module_identifier__$y,
        false,
        undefined,
        undefined,
        undefined
      );

    //
    /**
     * A slider to select a value or range from a given range
     * @displayName Slider
     * @requires ./SliderTick.vue
     * @example ./examples/Slider.md
     * @style _slider.scss
     */

    var script$z = {
      name: 'OSlider',
      components: {
        [__vue_component__$x.name]: __vue_component__$x,
        [__vue_component__$y.name]: __vue_component__$y
      },
      configField: 'slider',
      mixins: [BaseComponentMixin],

      provide() {
        return {
          $slider: this
        };
      },

      props: {
        /** @model */
        value: {
          type: [Number, Array],
          default: 0
        },

        /** Minimum value */
        min: {
          type: Number,
          default: 0
        },

        /** Maximum  value */
        max: {
          type: Number,
          default: 100
        },

        /** Step interval of ticks */
        step: {
          type: Number,
          default: 1
        },

        /**
         * Color of the slider
         * @values primary, info, success, warning, danger, and any other custom color
         */
        variant: {
          type: String
        },

        /**
         * Vertical size of slider, optional
         * @values small, medium, large
         */
        size: String,

        /** Show tick marks */
        ticks: {
          type: Boolean,
          default: false
        },

        /** Show tooltip when thumb is being dragged */
        tooltip: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'slider.tooltip', true);
          }
        },

        /**
         * Color of the tooltip
         * @values primary, info, success, warning, danger, and any other custom color
         */
        tooltipVariant: String,

        /** Rounded thumb */
        rounded: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'slider.rounded', false);
          }
        },
        disabled: {
          type: Boolean,
          default: false
        },

        /** Update v-model only when dragging is finished */
        lazy: {
          type: Boolean,
          default: false
        },

        /** Function to format the tooltip label for display */
        customFormatter: Function,
        ariaLabel: [String, Array],

        /** Increases slider size on focus */
        biggerSliderFocus: {
          type: Boolean,
          default: false
        },
        indicator: {
          type: Boolean,
          default: false
        },
        format: {
          type: String,
          default: 'raw',
          validator: value => {
            return ['raw', 'percent'].indexOf(value) >= 0;
          }
        },
        locale: {
          type: [String, Array],
          default: () => {
            return getValueByPath(getOptions(), 'locale');
          }
        },

        /** Tooltip displays always */
        tooltipAlways: {
          type: Boolean,
          default: false
        },
        rootClass: [String, Function, Array],
        sizeClass: [String, Function, Array],
        trackClass: [String, Function, Array],
        fillClass: [String, Function, Array],
        thumbRoundedClass: [String, Function, Array],
        thumbDraggingClass: [String, Function, Array],
        disabledClass: [String, Function, Array],
        thumbWrapperClass: [String, Function, Array],
        thumbClass: [String, Function, Array],
        variantClass: [String, Function, Array]
      },

      data() {
        return {
          value1: null,
          value2: null,
          dragging: false,
          isRange: false
        };
      },

      computed: {
        rootClasses() {
          return [this.computedClass('rootClass', 'o-slide'), {
            [this.computedClass('sizeClass', 'o-slide--', this.size)]: this.size
          }, {
            [this.computedClass('disabledClass', 'o-slide--disabled')]: this.disabled
          }];
        },

        trackClasses() {
          return [this.computedClass('trackClass', 'o-slide__track')];
        },

        fillClasses() {
          return [this.computedClass('fillClass', 'o-slide__fill'), {
            [this.computedClass('variantClass', 'o-slide__fill--', this.variant)]: this.variant
          }];
        },

        thumbClasses() {
          return [this.computedClass('thumbClass', 'o-slide__thumb'), {
            [this.computedClass('thumbDraggingClass', 'o-slide__thumb--dragging')]: this.dragging
          }, {
            [this.computedClass('thumbRoundedClass', 'o-slide__thumb--rounded')]: this.rounded
          }];
        },

        thumbWrapperClasses() {
          return [this.computedClass('thumbWrapperClass', 'o-slide__thumb-wrapper')];
        },

        newTooltipVariant() {
          return this.tooltipVariant ? this.tooltipVariant : this.variant;
        },

        tickValues() {
          if (!this.ticks || this.min > this.max || this.step === 0) return [];
          const result = [];

          for (let i = this.min + this.step; i < this.max; i = i + this.step) {
            result.push(i);
          }

          return result;
        },

        minValue() {
          return Math.min(this.value1, this.value2);
        },

        maxValue() {
          return Math.max(this.value1, this.value2);
        },

        barSize() {
          return this.isRange ? `${100 * (this.maxValue - this.minValue) / (this.max - this.min)}%` : `${100 * (this.value1 - this.min) / (this.max - this.min)}%`;
        },

        barStart() {
          return this.isRange ? `${100 * (this.minValue - this.min) / (this.max - this.min)}%` : '0%';
        },

        precision() {
          const precisions = [this.min, this.max, this.step].map(item => {
            const decimal = ('' + item).split('.')[1];
            return decimal ? decimal.length : 0;
          });
          return Math.max(...precisions);
        },

        barStyle() {
          return {
            width: this.barSize,
            left: this.barStart
          };
        }

      },
      watch: {
        value1() {
          this.onInternalValueUpdate();
        },

        value2() {
          this.onInternalValueUpdate();
        },

        min() {
          this.setValues(this.value);
        },

        max() {
          this.setValues(this.value);
        },

        /**
        * When v-model is changed set the new active step.
        */
        value(value) {
          this.setValues(value);
        }

      },
      methods: {
        setValues(newValue) {
          if (this.min > this.max) {
            return;
          }

          if (Array.isArray(newValue)) {
            this.isRange = true;
            const smallValue = typeof newValue[0] !== 'number' || isNaN(newValue[0]) ? this.min : Math.min(Math.max(this.min, newValue[0]), this.max);
            const largeValue = typeof newValue[1] !== 'number' || isNaN(newValue[1]) ? this.max : Math.max(Math.min(this.max, newValue[1]), this.min);
            this.value1 = this.isThumbReversed ? largeValue : smallValue;
            this.value2 = this.isThumbReversed ? smallValue : largeValue;
          } else {
            this.isRange = false;
            this.value1 = isNaN(newValue) ? this.min : Math.min(this.max, Math.max(this.min, newValue));
            this.value2 = null;
          }
        },

        onInternalValueUpdate() {
          if (this.isRange) {
            this.isThumbReversed = this.value1 > this.value2;
          }

          if (!this.lazy || !this.dragging) {
            this.emitValue('input');
          }

          if (this.dragging) {
            this.emitValue('dragging');
          }
        },

        sliderSize() {
          return this.$refs.slider.getBoundingClientRect().width;
        },

        onSliderClick(event) {
          if (this.disabled || this.isTrackClickDisabled) return;
          const sliderOffsetLeft = this.$refs.slider.getBoundingClientRect().left;
          const percent = (event.clientX - sliderOffsetLeft) / this.sliderSize() * 100;
          const targetValue = this.min + percent * (this.max - this.min) / 100;
          const diffFirst = Math.abs(targetValue - this.value1);

          if (!this.isRange) {
            if (diffFirst < this.step / 2) return;
            this.$refs.button1.setPosition(percent);
          } else {
            const diffSecond = Math.abs(targetValue - this.value2);

            if (diffFirst <= diffSecond) {
              if (diffFirst < this.step / 2) return;
              this.$refs['button1'].setPosition(percent);
            } else {
              if (diffSecond < this.step / 2) return;
              this.$refs['button2'].setPosition(percent);
            }
          }

          this.emitValue('change');
        },

        onDragStart() {
          this.dragging = true;
          this.$emit('dragstart');
        },

        onDragEnd() {
          this.isTrackClickDisabled = true;
          setTimeout(() => {
            // avoid triggering onSliderClick after dragend
            this.isTrackClickDisabled = false;
          }, 0);
          this.dragging = false;
          this.$emit('dragend');

          if (this.lazy) {
            this.emitValue('input');
          }
        },

        emitValue(event) {
          const val = this.isRange ? [this.minValue, this.maxValue] : this.value1;
          this.$emit(event, val);
        }

      },

      created() {
        this.isThumbReversed = false;
        this.isTrackClickDisabled = false;
        this.setValues(this.value);
      }

    };

    /* script */
    const __vue_script__$z = script$z;

    /* template */
    var __vue_render__$w = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.rootClasses,on:{"click":_vm.onSliderClick}},[_c('div',{ref:"slider",class:_vm.trackClasses},[_c('div',{class:_vm.fillClasses,style:(_vm.barStyle)}),(_vm.ticks)?_vm._l((_vm.tickValues),function(val,key){return _c('o-slider-tick',{key:key,attrs:{"value":val}})}):_vm._e(),_vm._t("default"),_c('o-slider-thumb',{ref:"button1",attrs:{"variant":_vm.newTooltipVariant,"tooltip":_vm.tooltip,"custom-formatter":_vm.customFormatter,"indicator":_vm.indicator,"role":"slider","format":_vm.format,"locale":_vm.locale,"tooltip-always":_vm.tooltipAlways,"aria-valuenow":_vm.value1,"aria-valuemin":_vm.min,"aria-valuemax":_vm.max,"aria-orientation":"horizontal","aria-label":Array.isArray(_vm.ariaLabel) ? _vm.ariaLabel[0] : _vm.ariaLabel,"aria-disabled":_vm.disabled},on:{"dragstart":_vm.onDragStart,"dragend":_vm.onDragEnd},model:{value:(_vm.value1),callback:function ($$v) {_vm.value1=$$v;},expression:"value1"}}),(_vm.isRange)?_c('o-slider-thumb',{ref:"button2",attrs:{"variant":_vm.newTooltipVariant,"tooltip":_vm.tooltip,"custom-formatter":_vm.customFormatter,"indicator":_vm.indicator,"role":"slider","format":_vm.format,"locale":_vm.locale,"tooltip-always":_vm.tooltipAlways,"aria-valuenow":_vm.value2,"aria-valuemin":_vm.min,"aria-valuemax":_vm.max,"aria-orientation":"horizontal","aria-label":Array.isArray(_vm.ariaLabel) ? _vm.ariaLabel[1] : '',"aria-disabled":_vm.disabled},on:{"dragstart":_vm.onDragStart,"dragend":_vm.onDragEnd},model:{value:(_vm.value2),callback:function ($$v) {_vm.value2=$$v;},expression:"value2"}}):_vm._e()],2)])};
    var __vue_staticRenderFns__$w = [];

      /* style */
      const __vue_inject_styles__$z = undefined;
      /* scoped */
      const __vue_scope_id__$z = undefined;
      /* module identifier */
      const __vue_module_identifier__$z = undefined;
      /* functional template */
      const __vue_is_functional_template__$z = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$z = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$w, staticRenderFns: __vue_staticRenderFns__$w },
        __vue_inject_styles__$z,
        __vue_script__$z,
        __vue_scope_id__$z,
        __vue_is_functional_template__$z,
        __vue_module_identifier__$z,
        false,
        undefined,
        undefined,
        undefined
      );

    const Plugin$m = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$z);
        registerComponent(Vue, __vue_component__$y);
      }

    };
    use(Plugin$m);

    var SlotComponent = {
      name: 'OSlotComponent',
      props: {
        component: {
          type: Object,
          required: true
        },
        name: {
          type: String,
          default: 'default'
        },
        scoped: {
          type: Boolean
        },
        props: {
          type: Object
        },
        tag: {
          type: String,
          default: 'div'
        },
        event: {
          type: String,
          default: 'hook:updated'
        }
      },
      methods: {
        refresh() {
          this.$forceUpdate();
        }

      },

      created() {
        this.component.$on(this.event, this.refresh);
      },

      beforeDestroy() {
        this.component.$off(this.event, this.refresh);
      },

      render(h) {
        const slot = this.scoped ? this.component.$scopedSlots[this.name](this.props) : this.component.$slots[this.name];
        return h(this.tag, {}, slot);
      }

    };

    var TabbedMixin = (cmp => ({
      mixins: [ProviderParentMixin(cmp, Sorted)],
      components: {
        [__vue_component__.name]: __vue_component__,
        [SlotComponent.name]: SlotComponent
      },
      props: {
        /** @model */
        value: [String, Number],

        /**
        * Color of the control, optional
        * @values primary, info, success, warning, danger, and any other custom color
        */
        variant: [String, Object],

        /**
         * Tab size, optional
         * @values small, medium, large
         */
        size: String,
        animated: {
          type: Boolean,
          default: true
        },

        /** Show tab in vertical layout */
        vertical: {
          type: Boolean,
          default: false
        },

        /**
         * Position of the tab, optional
         * @values centered, right
         */
        position: String,

        /** Destroy tab on hide */
        destroyOnHide: {
          type: Boolean,
          default: false
        }
      },

      data() {
        return {
          activeId: this.value,
          contentHeight: 0,
          isTransitioning: false
        };
      },

      computed: {
        activeItem() {
          return this.activeId !== undefined && this.activeId !== null ? this.childItems.filter(i => i.newValue === this.activeId)[0] : this.items[0];
        },

        activeIndex() {
          return this.childItems.findIndex(item => item.newValue === this.activeId);
        },

        items() {
          return this.sortedItems;
        }

      },
      watch: {
        /**
         * When v-model is changed set the new active tab.
         */
        value(value) {
          if (this.activeId !== value) {
            this.performAction(value);
          }
        }

      },
      methods: {
        /**
        * Child click listener, emit input event and change active child.
        */
        childClick(child) {
          if (this.activeId !== child.newValue) {
            this.performAction(child.newValue);
            this.$emit('input', this.activeId);
          }
        },

        /**
         * Select the first 'viable' child, starting at startingIndex and in the direction specified
         * by the boolean parameter forward. In other words, first try to select the child at index 
         * startingIndex, and if it is not visible or it is disabled, then go to the index in the
         * specified direction until either returning to startIndex or finding a viable child item.
        */
        clickFirstViableChild(startingIndex, forward) {
          let direction = forward ? 1 : -1;
          let newIndex = startingIndex;

          for (; newIndex !== this.activeIndex; newIndex = mod(newIndex + direction, this.childItems.length)) {
            // Break if the item at this index is viable (not disabled and is visible)
            if (this.childItems[newIndex].visible && !this.childItems[newIndex].disabled) {
              break;
            }
          }

          this.childClick(this.childItems[newIndex]);
        },

        /**
         * Go to the next item or wrap around
        */
        next() {
          let newIndex = mod(this.activeIndex + 1, this.childItems.length);
          this.clickFirstViableChild(newIndex, true);
        },

        /**
         * Go to the previous item or wrap around
        */
        prev() {
          let newIndex = mod(this.activeIndex - 1, this.childItems.length);
          this.clickFirstViableChild(newIndex, false);
        },

        /**
         * Go to the first viable item
        */
        homePressed() {
          if (this.childItems.length < 1) {
            return;
          }

          this.clickFirstViableChild(0, true);
        },

        /**
         * Go to the last viable item
        */
        endPressed() {
          if (this.childItems.length < 1) {
            return;
          }

          this.clickFirstViableChild(this.childItems.length - 1, false);
        },

        /**
        * Activate next child and deactivate prev child
        */
        performAction(newId) {
          const oldValue = this.activeId;
          const oldTab = oldValue !== undefined && oldValue !== null ? this.childItems.filter(i => i.newValue === oldValue)[0] : this.items[0];
          this.activeId = newId;

          if (oldTab && this.activeItem) {
            oldTab.deactivate(this.activeItem.index);
            this.activeItem.activate(oldTab.index);
          }
        }

      }
    }));

    //
    /**
     * Responsive horizontal process steps
     * @displayName Steps
     * @requires ./StepItem.vue
     * @example ./examples/Steps.md
     * @style _steps.scss
     */

    var script$A = {
      name: 'OSteps',
      components: {
        [__vue_component__$3.name]: __vue_component__$3,
        [__vue_component__.name]: __vue_component__
      },
      configField: 'steps',
      mixins: [BaseComponentMixin, MatchMediaMixin, TabbedMixin('step')],
      props: {
        /**
         * Icon pack to use for the navigation
         * @values mdi, fa, fas and any other custom icon pack
         */
        iconPack: String,

        /** Icon to use for navigation button */
        iconPrev: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'steps.iconPrev', 'chevron-left');
          }
        },

        /** Icon to use for navigation button */
        iconNext: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'steps.iconNext', 'chevron-right');
          }
        },

        /**
         * Next and previous buttons below the component. You can use this property if you want to use your own custom navigation items.
         */
        hasNavigation: {
          type: Boolean,
          default: true
        },

        /**
         * Step navigation is animated
         */
        animated: {
          type: Boolean,
          default: true
        },

        /**
         * Position of the marker label, optional
         * @values bottom, right, left
         */
        labelPosition: {
          type: String,

          validator(value) {
            return ['bottom', 'right', 'left'].indexOf(value) > -1;
          },

          default: 'bottom'
        },

        /** Rounded step markers */
        rounded: {
          type: Boolean,
          default: true
        },
        ariaNextLabel: String,
        ariaPreviousLabel: String,
        rootClass: [String, Function, Array],
        sizeClass: [String, Function, Array],
        verticalClass: [String, Function, Array],
        positionClass: [String, Function, Array],
        stepsClass: [String, Function, Array],
        variantClass: [String, Function, Array],
        animatedClass: [String, Function, Array],
        stepMarkerRoundedClass: [String, Function, Array],
        stepDividerClass: [String, Function, Array],
        stepMarkerClass: [String, Function, Array],
        stepContentClass: [String, Function, Array],
        stepContentTransitioningClass: [String, Function, Array],
        stepNavigationClass: [String, Function, Array],
        stepLinkClass: [String, Function, Array],
        stepLinkClickableClass: [String, Function, Array],
        stepLinkLabelClass: [String, Function, Array],
        stepLinkLabelPositionClass: [String, Function, Array],
        mobileClass: [String, Function, Array]
      },
      computed: {
        wrapperClasses() {
          return [this.computedClass('rootClass', 'o-steps__wrapper'), {
            [this.computedClass('sizeClass', 'o-steps--', this.size)]: this.size
          }, {
            [this.computedClass('verticalClass', 'o-steps__wrapper-vertical')]: this.vertical
          }, {
            [this.computedClass('positionClass', 'o-steps__wrapper-position-', this.position)]: this.position && this.vertical
          }, {
            [this.computedClass('mobileClass', 'o-steps--mobile')]: this.isMatchMedia
          }];
        },

        mainClasses() {
          return [this.computedClass('stepsClass', 'o-steps'), {
            [this.computedClass('animatedClass', 'o-steps--animated')]: this.animated
          }];
        },

        stepDividerClasses() {
          return [this.computedClass('stepDividerClass', 'o-steps__divider')];
        },

        stepMarkerClasses() {
          return [this.computedClass('stepMarkerClass', 'o-steps__marker'), {
            [this.computedClass('stepMarkerRoundedClass', 'o-steps__marker--rounded')]: this.rounded
          }];
        },

        stepContentClasses() {
          return [this.computedClass('stepContentClass', 'o-steps__content'), {
            [this.computedClass('stepContentTransitioningClass', 'o-steps__content-transitioning')]: this.isTransitioning
          }];
        },

        stepNavigationClasses() {
          return [this.computedClass('stepNavigationClass', 'o-steps__navigation')];
        },

        stepLinkLabelClasses() {
          return [this.computedClass('stepLinkLabelClass', 'o-steps__title')];
        },

        // Override mixin implementation to always have a value
        activeItem() {
          return this.childItems.filter(i => i.newValue === this.activeId)[0] || this.items[0];
        },

        /**
         * Check if previous button is available.
         */
        hasPrev() {
          return !!this.prevItem;
        },

        /**
         * Retrieves the next visible item
         */
        nextItem() {
          let nextItem = null;
          let idx = this.activeItem ? this.items.indexOf(this.activeItem) + 1 : 0;

          for (; idx < this.items.length; idx++) {
            if (this.items[idx].visible) {
              nextItem = this.items[idx];
              break;
            }
          }

          return nextItem;
        },

        /**
         * Retrieves the previous visible item
         */
        prevItem() {
          if (!this.activeItem) {
            return null;
          }

          let prevItem = null;

          for (let idx = this.items.indexOf(this.activeItem) - 1; idx >= 0; idx--) {
            if (this.items[idx].visible) {
              prevItem = this.items[idx];
              break;
            }
          }

          return prevItem;
        },

        /**
         * Check if next button is available.
         */
        hasNext() {
          return !!this.nextItem;
        },

        navigationProps() {
          return {
            previous: {
              disabled: !this.hasPrev,
              action: this.prev
            },
            next: {
              disabled: !this.hasNext,
              action: this.next
            }
          };
        }

      },
      methods: {
        stepLinkClasses(childItem) {
          return [this.computedClass('stepLinkClass', 'o-steps__link'), {
            [this.computedClass('stepLinkLabelPositionClass', 'o-steps__link-label-', this.labelPosition)]: this.labelPosition
          }, {
            [this.computedClass('stepLinkClickableClass', 'o-steps__link-clickable')]: this.isItemClickable(childItem)
          }];
        },

        /**
         * Return if the step should be clickable or not.
         */
        isItemClickable(stepItem) {
          if (stepItem.clickable === undefined) {
            return stepItem.index < this.activeItem.index;
          }

          return stepItem.clickable;
        },

        /**
         * Previous button click listener.
         */
        prev() {
          if (this.hasPrev) {
            this.childClick(this.prevItem);
          }
        },

        /**
         * Previous button click listener.
         */
        next() {
          if (this.hasNext) {
            this.childClick(this.nextItem);
          }
        }

      }
    };

    /* script */
    const __vue_script__$A = script$A;

    /* template */
    var __vue_render__$x = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.wrapperClasses},[_c('nav',{class:_vm.mainClasses},_vm._l((_vm.items),function(childItem,index){return _c('div',{directives:[{name:"show",rawName:"v-show",value:(childItem.visible),expression:"childItem.visible"}],key:childItem.newValue,class:childItem.itemClasses},[(index > 0)?_c('span',{class:_vm.stepDividerClasses}):_vm._e(),_c('a',{class:_vm.stepLinkClasses(childItem),on:{"click":function($event){_vm.isItemClickable(childItem) && _vm.childClick(childItem);}}},[_c('div',{class:_vm.stepMarkerClasses},[(childItem.icon)?_c('o-icon',{attrs:{"icon":childItem.icon,"pack":childItem.iconPack,"size":_vm.size}}):(childItem.step)?_c('span',[_vm._v(_vm._s(childItem.step))]):_vm._e()],1),_c('div',{class:_vm.stepLinkLabelClasses},[_vm._v(_vm._s(childItem.label))])])])}),0),_c('section',{class:_vm.stepContentClasses},[_vm._t("default")],2),_vm._t("navigation",[(_vm.hasNavigation)?_c('nav',{class:_vm.stepNavigationClasses},[_c('o-button',{attrs:{"role":"button","icon-left":_vm.iconPrev,"icon-pack":_vm.iconPack,"icon-both":"","disabled":_vm.navigationProps.previous.disabled,"aria-label":_vm.ariaPreviousLabel},on:{"click":function($event){$event.preventDefault();return _vm.navigationProps.previous.action($event)}}}),_c('o-button',{attrs:{"role":"button","icon-left":_vm.iconNext,"icon-pack":_vm.iconPack,"icon-both":"","disabled":_vm.navigationProps.next.disabled,"aria-label":_vm.ariaNextLabel},on:{"click":function($event){$event.preventDefault();return _vm.navigationProps.next.action($event)}}})],1):_vm._e()],{"previous":_vm.navigationProps.previous,"next":_vm.navigationProps.next})],2)};
    var __vue_staticRenderFns__$x = [];

      /* style */
      const __vue_inject_styles__$A = undefined;
      /* scoped */
      const __vue_scope_id__$A = undefined;
      /* module identifier */
      const __vue_module_identifier__$A = undefined;
      /* functional template */
      const __vue_is_functional_template__$A = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$A = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$x, staticRenderFns: __vue_staticRenderFns__$x },
        __vue_inject_styles__$A,
        __vue_script__$A,
        __vue_scope_id__$A,
        __vue_is_functional_template__$A,
        __vue_module_identifier__$A,
        false,
        undefined,
        undefined,
        undefined
      );

    var TabbedChildMixin = (parentCmp => ({
      mixins: [InjectedChildMixin(parentCmp, Sorted$1)],
      props: {
        /**
         * Item value (it will be used as v-model of wrapper component)
         */
        value: [String, Number],

        /**
         * Item label
         */
        label: String,

        /**
         * Icon on the left
         */
        icon: String,

        /**
         * Icon pack
         */
        iconPack: String,

        /**
         * Show/hide item
         */
        visible: {
          type: Boolean,
          default: true
        },

        /**
         * Header class of the item
         */
        headerClass: [String, Array, Object]
      },

      data() {
        return {
          transitionName: undefined,
          newValue: this.value
        };
      },

      computed: {
        isActive() {
          return this.parent.activeItem === this;
        },

        elementClasses() {
          return [];
        }

      },
      methods: {
        /**
         * Activate element, alter animation name based on the index.
         */
        activate(oldIndex) {
          this.transitionName = this.index < oldIndex ? this.parent.vertical ? 'slide-down' : 'slide-next' : this.parent.vertical ? 'slide-up' : 'slide-prev';
          this.$emit("activate");
        },

        /**
         * Deactivate element, alter animation name based on the index.
         */
        deactivate(newIndex) {
          this.transitionName = newIndex < this.index ? this.parent.vertical ? 'slide-down' : 'slide-next' : this.parent.vertical ? 'slide-up' : 'slide-prev';
        }

      },

      render(h) {
        // if destroy apply v-if
        if (this.parent.destroyOnHide) {
          if (!this.isActive || !this.visible) return;
        }

        const vnode = h('div', {
          directives: [{
            name: 'show',
            value: this.isActive && this.visible
          }],
          attrs: {
            'class': this.elementClasses,
            'id': `${parentCmp}-${this.newValue}`,
            'tabindex': this.isActive ? 0 : -1
          }
        }, this.$slots.default); // check animated prop

        if (this.parent.animated) {
          return h('transition', {
            props: {
              'name': this.transitionName
            },
            on: {
              'before-enter': () => {
                this.parent.isTransitioning = true;
              },
              'after-enter': () => {
                this.parent.isTransitioning = false;
              }
            }
          }, [vnode]);
        }

        return vnode;
      }

    }));

    /**
     * @displayName Step Item
     */

    var script$B = {
      name: 'OStepItem',
      mixins: [BaseComponentMixin, TabbedChildMixin('step')],
      configField: 'steps',
      props: {
        /** Step marker content (when there is no icon) */
        step: [String, Number],

        /** Default style for the step, optional This will override parent type. Could be used to set a completed step to "success" for example */
        variant: [String, Object],

        /** Item can be used directly to navigate. If undefined, previous steps are clickable while the others are not */
        clickable: {
          type: Boolean,
          default: undefined
        },
        itemClass: [String, Function, Array],
        itemHeaderClass: [String, Function, Array],
        itemHeaderActiveClass: [String, Function, Array],
        itemHeaderPreviousClass: [String, Function, Array],
        itemHeaderVariantClass: [String, Function, Array]
      },
      computed: {
        elementClasses() {
          return [this.computedClass('itemClass', 'o-steps__item')];
        },

        itemClasses() {
          return [this.headerClass, this.computedClass('itemHeaderClass', 'o-steps__nav-item'), {
            [this.computedClass('itemHeaderVariantClass', 'o-steps__nav-item--', this.variant || this.parent.variant)]: this.variant || this.parent.variant
          }, {
            [this.computedClass('itemHeaderActiveClass', 'o-steps__nav-item-active')]: this.isActive
          }, {
            [this.computedClass('itemHeaderPreviousClass', 'o-steps__nav-item-previous')]: this.parent.activeItem.index > this.index
          }];
        }

      }
    };

    /* script */
    const __vue_script__$B = script$B;

    /* template */

      /* style */
      const __vue_inject_styles__$B = undefined;
      /* scoped */
      const __vue_scope_id__$B = undefined;
      /* module identifier */
      const __vue_module_identifier__$B = undefined;
      /* functional template */
      const __vue_is_functional_template__$B = undefined;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$B = /*#__PURE__*/normalizeComponent(
        {},
        __vue_inject_styles__$B,
        __vue_script__$B,
        __vue_scope_id__$B,
        __vue_is_functional_template__$B,
        __vue_module_identifier__$B,
        false,
        undefined,
        undefined,
        undefined
      );

    const Plugin$n = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$A);
        registerComponent(Vue, __vue_component__$B);
      }

    };
    use(Plugin$n);

    //
    /**
     * Switch between two opposing states
     * @displayName Switch
     * @example ./examples/Switch.md
     * @style _switch.scss
     */

    var script$C = {
      name: 'OSwitch',
      mixins: [BaseComponentMixin],
      configField: 'switch',
      props: {
        /** @model */
        value: [String, Number, Boolean],

        /**
         * Same as native value
         */
        nativeValue: [String, Number, Boolean],
        disabled: Boolean,

        /**
         * Color of the switch, optional
         * @values primary, info, success, warning, danger, and any other custom color
         */
        variant: String,

        /**
        * Color of the switch when is passive, optional
        * @values primary, info, success, warning, danger, and any other custom color
        */
        passiveVariant: String,

        /** Name attribute on native checkbox */
        name: String,
        required: Boolean,

        /**
         * Vertical size of switch, optional
         * @values small, medium, large
         */
        size: String,

        /**
         * Overrides the returned value when it's checked
         */
        trueValue: {
          type: [String, Number, Boolean],
          default: true
        },

        /**
         * Overrides the returned value when it's not checked
         */
        falseValue: {
          type: [String, Number, Boolean],
          default: false
        },

        /** Rounded style */
        rounded: {
          type: Boolean,
          default: true
        },

        /** Label position */
        position: {
          type: String,
          default: 'right'
        },

        /** Accessibility label to establish relationship between the switch and control label' */
        ariaLabelledby: String,
        rootClass: [String, Function, Array],
        disabledClass: [String, Function, Array],
        checkClass: [String, Function, Array],
        checkCheckedClass: [String, Function, Array],
        checkSwitchClass: [String, Function, Array],
        roundedClass: [String, Function, Array],
        labelClass: [String, Function, Array],
        sizeClass: [String, Function, Array],
        variantClass: [String, Function, Array],
        passiveVariantClass: [String, Function, Array],
        positionClass: [String, Function, Array],
        inputClass: [String, Function, Array]
      },

      data() {
        return {
          newValue: this.value,
          isMouseDown: false
        };
      },

      computed: {
        rootClasses() {
          return [this.computedClass('rootClass', 'o-switch'), {
            [this.computedClass('sizeClass', 'o-switch--', this.size)]: this.size
          }, {
            [this.computedClass('disabledClass', 'o-switch--disabled')]: this.disabled
          }, {
            [this.computedClass('variantClass', 'o-switch--', this.variant)]: this.variant
          }, {
            [this.computedClass('positionClass', 'o-switch--', this.position)]: this.position
          }, {
            [this.computedClass('passiveVariantClass', 'o-switch--', this.passiveVariant + '-passive')]: this.passiveVariant
          }];
        },

        inputClasses() {
          return [this.computedClass('inputClass', 'o-switch__input')];
        },

        checkClasses() {
          return [this.computedClass('checkClass', 'o-switch__check'), {
            [this.computedClass('checkCheckedClass', 'o-switch__check--checked')]: this.newValue === this.trueValue
          }, {
            [this.computedClass('roundedClass', 'o-switch--rounded')]: this.rounded
          }];
        },

        checkSwitchClasses() {
          return [this.computedClass('checkSwitchClass', 'o-switch__check-switch'), {
            [this.computedClass('roundedClass', 'o-switch--rounded')]: this.rounded
          }];
        },

        labelClasses() {
          return [this.computedClass('labelClass', 'o-switch__label')];
        },

        computedValue: {
          get() {
            return this.newValue;
          },

          set(value) {
            this.newValue = value;
            this.$emit('input', this.newValue);
          }

        }
      },
      watch: {
        /**
        * When v-model change, set internal value.
        */
        value(value) {
          this.newValue = value;
        }

      },
      methods: {
        focus() {
          // MacOS FireFox and Safari do not focus when clicked
          this.$refs.input.focus();
        }

      }
    };

    /* script */
    const __vue_script__$C = script$C;

    /* template */
    var __vue_render__$y = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{ref:"label",class:_vm.rootClasses,attrs:{"disabled":_vm.disabled},on:{"click":_vm.focus,"keydown":function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"enter",13,$event.key,"Enter")){ return null; }$event.preventDefault();return _vm.$refs.label.click()},"mousedown":function($event){_vm.isMouseDown = true;},"mouseup":function($event){_vm.isMouseDown = false;},"mouseout":function($event){_vm.isMouseDown = false;},"blur":function($event){_vm.isMouseDown = false;}}},[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.computedValue),expression:"computedValue"}],ref:"input",class:_vm.inputClasses,attrs:{"type":"checkbox","role":"switch","disabled":_vm.disabled,"name":_vm.name,"required":_vm.required,"true-value":_vm.trueValue,"false-value":_vm.falseValue,"aria-labelledby":_vm.ariaLabelledby},domProps:{"value":_vm.nativeValue,"checked":Array.isArray(_vm.computedValue)?_vm._i(_vm.computedValue,_vm.nativeValue)>-1:_vm._q(_vm.computedValue,_vm.trueValue)},on:{"click":function($event){$event.stopPropagation();},"change":function($event){var $$a=_vm.computedValue,$$el=$event.target,$$c=$$el.checked?(_vm.trueValue):(_vm.falseValue);if(Array.isArray($$a)){var $$v=_vm.nativeValue,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.computedValue=$$a.concat([$$v]));}else {$$i>-1&&(_vm.computedValue=$$a.slice(0,$$i).concat($$a.slice($$i+1)));}}else {_vm.computedValue=$$c;}}}}),_c('span',{class:_vm.checkClasses},[_c('span',{class:_vm.checkSwitchClasses})]),_c('span',{class:_vm.labelClasses,attrs:{"id":_vm.ariaLabelledby}},[_vm._t("default")],2)])};
    var __vue_staticRenderFns__$y = [];

      /* style */
      const __vue_inject_styles__$C = undefined;
      /* scoped */
      const __vue_scope_id__$C = undefined;
      /* module identifier */
      const __vue_module_identifier__$C = undefined;
      /* functional template */
      const __vue_is_functional_template__$C = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$C = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$y, staticRenderFns: __vue_staticRenderFns__$y },
        __vue_inject_styles__$C,
        __vue_script__$C,
        __vue_scope_id__$C,
        __vue_is_functional_template__$C,
        __vue_module_identifier__$C,
        false,
        undefined,
        undefined,
        undefined
      );

    const Plugin$o = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$C);
      }

    };
    use(Plugin$o);

    //
    var script$D = {
      name: 'OTableMobileSort',
      components: {
        [__vue_component__$3.name]: __vue_component__$3,
        [__vue_component__$a.name]: __vue_component__$a,
        [__vue_component__.name]: __vue_component__,
        [__vue_component__$i.name]: __vue_component__$i
      },
      inject: ['$table'],
      props: {
        currentSortColumn: Object,
        columns: Array,
        placeholder: String,
        iconPack: String,
        sortIcon: {
          type: String,
          default: 'arrow-up'
        },
        sortIconSize: {
          type: String,
          default: 'small'
        },
        isAsc: Boolean
      },

      data() {
        return {
          mobileSort: this.currentSortColumn,
          defaultEvent: {
            shiftKey: true,
            altKey: true,
            ctrlKey: true
          },
          ignoreSort: false
        };
      },

      computed: {
        showPlaceholder() {
          return !this.columns || !this.columns.some(column => column === this.mobileSort);
        },

        sortableColumns() {
          if (!this.columns) return [];
          return this.columns.filter(c => c.sortable);
        }

      },
      watch: {
        mobileSort(column) {
          if (this.currentSortColumn === column) return;
          this.$emit('sort', column, this.defaultEvent);
        },

        currentSortColumn(column) {
          this.mobileSort = column;
        }

      },
      methods: {
        sort() {
          this.$emit('sort', this.mobileSort, this.defaultEvent);
        }

      }
    };

    /* script */
    const __vue_script__$D = script$D;

    /* template */
    var __vue_render__$z = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.$table.mobileSortClasses},[_c('o-field',[_c('o-select',{attrs:{"expanded":""},model:{value:(_vm.mobileSort),callback:function ($$v) {_vm.mobileSort=$$v;},expression:"mobileSort"}},[(_vm.placeholder)?[_c('option',{directives:[{name:"show",rawName:"v-show",value:(_vm.showPlaceholder),expression:"showPlaceholder"}],attrs:{"selected":"","disabled":"","hidden":""},domProps:{"value":{}}},[_vm._v(" "+_vm._s(_vm.placeholder)+" ")])]:_vm._e(),_vm._l((_vm.sortableColumns),function(column,index){return _c('option',{key:index,domProps:{"value":column}},[_vm._v(" "+_vm._s(column.label)+" ")])})],2),_c('o-button',{on:{"click":_vm.sort}},[_c('o-icon',{directives:[{name:"show",rawName:"v-show",value:(_vm.currentSortColumn === _vm.mobileSort),expression:"currentSortColumn === mobileSort"}],attrs:{"icon":_vm.sortIcon,"pack":_vm.iconPack,"size":_vm.sortIconSize,"both":"","rotation":!_vm.isAsc ? 180 : 0}})],1)],1)],1)};
    var __vue_staticRenderFns__$z = [];

      /* style */
      const __vue_inject_styles__$D = undefined;
      /* scoped */
      const __vue_scope_id__$D = undefined;
      /* module identifier */
      const __vue_module_identifier__$D = undefined;
      /* functional template */
      const __vue_is_functional_template__$D = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$D = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$z, staticRenderFns: __vue_staticRenderFns__$z },
        __vue_inject_styles__$D,
        __vue_script__$D,
        __vue_scope_id__$D,
        __vue_is_functional_template__$D,
        __vue_module_identifier__$D,
        false,
        undefined,
        undefined,
        undefined
      );

    /**
     * @displayName Table Column
     */

    var script$E = {
      name: 'OTableColumn',
      inject: ['$table'],
      props: {
        label: String,
        customKey: [String, Number],
        field: String,
        meta: [String, Number, Boolean, Function, Object, Array],
        width: [Number, String],
        numeric: Boolean,

        /**
         * Optional, position of column content
         * @values centered, right
         */
        position: {
          type: String,

          validator(value) {
            return ['left', 'centered', 'right'].indexOf(value) > -1;
          }

        },
        searchable: Boolean,
        sortable: Boolean,
        visible: {
          type: Boolean,
          default: true
        },
        customSort: Function,
        customSearch: Function,
        sticky: Boolean,
        headerSelectable: Boolean,

        /** Adds native attributes to th :th-attrs="(column)" => ({})" */
        thAttrs: {
          type: Function,
          default: () => ({})
        },

        /** Adds native attributes to td :td-attrs="(row, column)" => ({})" */
        tdAttrs: {
          type: Function,
          default: () => ({})
        },
        subheading: String
      },

      data() {
        return {
          newKey: this.$table._nextSequence(),
          _isTableColumn: true
        };
      },

      computed: {
        style() {
          return {
            width: toCssDimension(this.width)
          };
        },

        hasDefaultSlot() {
          return this.$scopedSlots.default;
        },

        hasSearchableSlot() {
          return this.$scopedSlots.searchable;
        },

        hasHeaderSlot() {
          return this.$scopedSlots.header;
        },

        isHeaderUnselectable() {
          return !this.headerSelectable && this.sortable;
        }

      },

      created() {
        if (!this.$table) {
          throw new Error('You should wrap oTableColumn on a oTable');
        }

        this.$table._addColumn(this);
      },

      beforeDestroy() {
        this.$table._removeColumn(this);
      },

      render() {
        // renderless
        return this.$createElement('span', {
          domProps: {
            'data-id': this.newKey
          }
        }, this.label);
      }

    };

    /* script */
    const __vue_script__$E = script$E;

    /* template */

      /* style */
      const __vue_inject_styles__$E = undefined;
      /* scoped */
      const __vue_scope_id__$E = undefined;
      /* module identifier */
      const __vue_module_identifier__$E = undefined;
      /* functional template */
      const __vue_is_functional_template__$E = undefined;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$E = /*#__PURE__*/normalizeComponent(
        {},
        __vue_inject_styles__$E,
        __vue_script__$E,
        __vue_scope_id__$E,
        __vue_is_functional_template__$E,
        __vue_module_identifier__$E,
        false,
        undefined,
        undefined,
        undefined
      );

    //
    var script$F = {
      name: 'OTablePagination',
      components: {
        [__vue_component__$s.name]: __vue_component__$s
      },
      props: {
        paginated: Boolean,
        total: [Number, String],
        perPage: [Number, String],
        currentPage: [Number, String],
        paginationSimple: Boolean,
        paginationSize: String,
        rounded: Boolean,
        iconPack: String,
        rootClass: [String, Array, Object],
        ariaNextLabel: String,
        ariaPreviousLabel: String,
        ariaPageLabel: String,
        ariaCurrentLabel: String
      },

      data() {
        return {
          newCurrentPage: this.currentPage
        };
      },

      watch: {
        currentPage(newVal) {
          this.newCurrentPage = newVal;
        }

      },
      methods: {
        /**
        * Paginator change listener.
        */
        pageChanged(page) {
          this.newCurrentPage = page > 0 ? page : 1;
          this.$emit('update:currentPage', this.newCurrentPage);
          this.$emit('page-change', this.newCurrentPage);
        }

      }
    };

    /* script */
    const __vue_script__$F = script$F;

    /* template */
    var __vue_render__$A = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.rootClass},[_c('div',[_vm._t("default")],2),_c('div',[(_vm.paginated)?_c('div',[_c('o-pagination',{attrs:{"icon-pack":_vm.iconPack,"total":_vm.total,"per-page":_vm.perPage,"simple":_vm.paginationSimple,"size":_vm.paginationSize,"current":_vm.newCurrentPage,"rounded":_vm.rounded,"aria-next-label":_vm.ariaNextLabel,"aria-previous-label":_vm.ariaPreviousLabel,"aria-page-label":_vm.ariaPageLabel,"aria-current-label":_vm.ariaCurrentLabel},on:{"change":_vm.pageChanged}})],1):_vm._e()])])};
    var __vue_staticRenderFns__$A = [];

      /* style */
      const __vue_inject_styles__$F = undefined;
      /* scoped */
      const __vue_scope_id__$F = undefined;
      /* module identifier */
      const __vue_module_identifier__$F = undefined;
      /* functional template */
      const __vue_is_functional_template__$F = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$F = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$A, staticRenderFns: __vue_staticRenderFns__$A },
        __vue_inject_styles__$F,
        __vue_script__$F,
        __vue_scope_id__$F,
        __vue_is_functional_template__$F,
        __vue_module_identifier__$F,
        false,
        undefined,
        undefined,
        undefined
      );

    //
    /**
     * Tabulated data are sometimes needed, it's even better when it's responsive
     * @displayName Table
     * @requires ./TableColumn.vue
     * @example ./examples/Table.md
     * @style _table.scss
     */

    var script$G = {
      name: 'OTable',
      components: {
        [__vue_component__$3.name]: __vue_component__$3,
        [__vue_component__$6.name]: __vue_component__$6,
        [__vue_component__.name]: __vue_component__,
        [__vue_component__$1.name]: __vue_component__$1,
        [__vue_component__$k.name]: __vue_component__$k,
        [SlotComponent.name]: SlotComponent,
        [__vue_component__$D.name]: __vue_component__$D,
        [__vue_component__$E.name]: __vue_component__$E,
        [__vue_component__$F.name]: __vue_component__$F
      },
      mixins: [BaseComponentMixin, MatchMediaMixin],
      configField: 'table',
      inheritAttrs: false,

      provide() {
        return {
          $table: this
        };
      },

      mounted() {
        this.refreshSlots();
        this.checkSort();
      },

      props: {
        /** Table data */
        data: {
          type: Array,
          default: () => []
        },

        /** Table columns */
        columns: {
          type: Array,
          default: () => []
        },

        /** Border to all cells */
        bordered: Boolean,

        /** Whether table is striped */
        striped: Boolean,

        /** Makes the cells narrower */
        narrowed: Boolean,

        /** Rows are highlighted when hovering */
        hoverable: Boolean,

        /** Loading state */
        loading: Boolean,

        /** Allow row details  */
        detailed: Boolean,

        /** Rows can be checked (multiple) */
        checkable: Boolean,

        /** Show check/uncheck all checkbox in table header when checkable */
        headerCheckable: {
          type: Boolean,
          default: true
        },

        /**
         * Position of the checkbox (if checkable is true)
         * @values left, right
         */
        checkboxPosition: {
          type: String,
          default: 'left',
          validator: value => {
            return ['left', 'right'].indexOf(value) >= 0;
          }
        },

        /** Set which row is selected, use the .sync modifier (Vue 2.x) or v-model:selected (Vue 3.x) to make it two-way binding */
        selected: Object,

        /** Custom method to verify if a row is selectable, works when is selected. */
        isRowSelectable: {
          type: Function,
          default: () => true
        },

        /** Table can be focused and user can navigate with keyboard arrows (require selected) and rows are highlighted when hovering */
        focusable: Boolean,

        /** Custom method to verify if row is checked, works when is checkable. Useful for backend pagination */
        customIsChecked: Function,

        /** Custom method to verify if a row is checkable, works when is checkable */
        isRowCheckable: {
          type: Function,
          default: () => true
        },

        /** Set which rows are checked, use the .sync modifier (Vue 2.x) or v-model:checkedRows (Vue 3.x) to make it two-way binding */
        checkedRows: {
          type: Array,
          default: () => []
        },

        /** Rows appears as cards on mobile (collapse rows) */
        mobileCards: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'table.mobileCards', true);
          }
        },

        /** Sets the default sort column and order  e.g. ['first_name', 'desc']	 */
        defaultSort: [String, Array],

        /**
         * Sets the default sort column direction on the first click
         * @values asc, desc
         */
        defaultSortDirection: {
          type: String,
          default: 'asc'
        },

        /** Sets the header sorting icon */
        sortIcon: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'table.sortIcon', 'arrow-up');
          }
        },

        /**
         * Sets the size of the sorting icon
         * @values small, medium, large
         */
        sortIconSize: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'table.sortIconSize', 'small');
          }
        },

        /** Adds pagination to the table */
        paginated: Boolean,

        /** Current page of table data (if paginated), use the .sync modifier (Vue 2.x) or v-model:currentPage (Vue 3.x) to make it two-way binding */
        currentPage: {
          type: Number,
          default: 1
        },

        /** How many rows per page (if paginated) */
        perPage: {
          type: [Number, String],
          default: () => {
            return getValueByPath(getOptions(), 'table.perPage', 20);
          }
        },

        /** Allow icon and column to be visible */
        showDetailIcon: {
          type: Boolean,
          default: true
        },

        /** Icon name of detail action */
        detailIcon: {
          type: String,
          default: 'chevron-right'
        },

        /**
         * Pagination position (if paginated)
         * @values bottom, top, bot
         */
        paginationPosition: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'table.paginationPosition', 'bottom');
          },
          validator: value => {
            return ['bottom', 'top', 'both'].indexOf(value) >= 0;
          }
        },

        /** Columns won't be sorted with Javascript, use with sort event to sort in your backend */
        backendSorting: Boolean,

        /** Columns won't be filtered with Javascript, use with searchable prop to the columns to filter in your backend */
        backendFiltering: Boolean,

        /** Add a class to row based on the return */
        rowClass: {
          type: Function,
          default: () => ''
        },

        /** Allow pre-defined opened details. Ideal to open details via vue-router. (A unique key is required; check detail-key prop) */
        openedDetailed: {
          type: Array,
          default: () => []
        },

        /** Controls the visibility of the trigger that toggles the detailed rows. */
        hasDetailedVisible: {
          type: Function,
          default: () => true
        },

        /** Use a unique key of your data Object when use detailed or opened detailed. (id recommended) */
        detailKey: {
          type: String,
          default: ''
        },

        /** Custom style on details */
        customDetailRow: {
          type: Boolean,
          default: false
        },

        /* Transition name to use when toggling row details. */
        detailTransition: {
          type: String,
          default: ''
        },

        /** Rows won't be paginated with Javascript, use with page-change event to paginate in your backend */
        backendPagination: Boolean,

        /** Total number of table data if backend-pagination is enabled */
        total: {
          type: [Number, String],
          default: 0
        },

        /** Icon pack to use */
        iconPack: String,

        /** Text when nothing is selected */
        mobileSortPlaceholder: String,

        /** Use a unique key of your data Object for each row. Useful if your data prop has dynamic indices. (id recommended) */
        customRowKey: String,

        /** Allows rows to be draggable */
        draggable: {
          type: Boolean,
          default: false
        },

        /** Allows columns to be draggable */
        draggableColumn: {
          type: Boolean,
          default: false
        },

        /** Add a horizontal scrollbar when table is too wide */
        scrollable: Boolean,
        ariaNextLabel: String,
        ariaPreviousLabel: String,
        ariaPageLabel: String,
        ariaCurrentLabel: String,

        /** Show a sticky table header */
        stickyHeader: Boolean,

        /** Table fixed height */
        height: [Number, String],

        /** Add a native event to filter */
        filtersEvent: {
          type: String,
          default: ''
        },

        /** Filtering debounce time (in milliseconds) */
        debounceSearch: Number,

        /** Show header */
        showHeader: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'table.showHeader', true);
          }
        },

        /** Make the checkbox column sticky when checkable */
        stickyCheckbox: {
          type: Boolean,
          default: false
        },

        /** Rounded pagination if paginated */
        paginationRounded: Boolean,

        /** Size of pagination if paginated */
        paginationSize: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'table.paginationSize', 'small');
          }
        },
        rootClass: [String, Function, Array],
        tableClass: [String, Function, Array],
        wrapperClass: [String, Function, Array],
        footerClass: [String, Function, Array],
        emptyClass: [String, Function, Array],
        detailedClass: [String, Function, Array],
        borderedClass: [String, Function, Array],
        stripedClass: [String, Function, Array],
        narrowedClass: [String, Function, Array],
        hoverableClass: [String, Function, Array],
        thClass: [String, Function, Array],
        tdClass: [String, Function, Array],
        thPositionClass: [String, Function, Array],
        thStickyClass: [String, Function, Array],
        thCheckboxClass: [String, Function, Array],
        thCurrentSortClass: [String, Function, Array],
        thSortableClass: [String, Function, Array],
        thUnselectableClass: [String, Function, Array],
        thSortIconClass: [String, Function, Array],
        thDetailedClass: [String, Function, Array],
        tdPositionClass: [String, Function, Array],
        tdStickyClass: [String, Function, Array],
        tdCheckboxClass: [String, Function, Array],
        tdDetailedChevronClass: [String, Function, Array],
        trSelectedClass: [String, Function, Array],
        trCheckedClass: [String, Function, Array],
        stickyHeaderClass: [String, Function, Array],
        scrollableClass: [String, Function, Array],
        mobileSortClass: [String, Function, Array],
        paginationWrapperClass: [String, Function, Array],
        mobileClass: [String, Function, Array],
        thSubheadingClass: [String, Function, Array]
      },

      data() {
        return {
          visibleDetailRows: this.openedDetailed,
          newData: this.data,
          newDataTotal: this.backendPagination ? this.total : this.data.length,
          newCheckedRows: [...this.checkedRows],
          lastCheckedRowIndex: null,
          newCurrentPage: this.currentPage,
          currentSortColumn: {},
          isAsc: true,
          filters: {},
          defaultSlots: [],
          firstTimeSort: true,
          sequence: 1,
          isDraggingRow: false,
          isDraggingColumn: false
        };
      },

      computed: {
        rootClasses() {
          return [this.computedClass('rootClass', 'o-table__root'), {
            [this.computedClass('mobileClass', 'o-table__wrapper--mobile')]: this.isMobile
          }];
        },

        tableClasses() {
          return [this.computedClass('tableClass', 'o-table'), {
            [this.computedClass('borderedClass', 'o-table--bordered')]: this.bordered
          }, {
            [this.computedClass('stripedClass', 'o-table--striped')]: this.striped
          }, {
            [this.computedClass('narrowedClass', 'o-table--narrowed')]: this.narrowed
          }, {
            [this.computedClass('hoverableClass', 'o-table--hoverable')]: (this.hoverable || this.focusable) && this.visibleData.length
          }, {
            [this.computedClass('emptyClass', 'o-table--table__empty')]: !this.visibleData.length
          }];
        },

        tableWrapperClasses() {
          return [this.computedClass('wrapperClass', 'o-table__wrapper'), {
            [this.computedClass('stickyHeaderClass', 'o-table__wrapper--sticky-header')]: this.stickyHeader
          }, {
            [this.computedClass('scrollableClass', 'o-table__wrapper--scrollable')]: this.isScrollable
          }];
        },

        footerClasses() {
          return [this.computedClass('footerClass', 'o-table__footer')];
        },

        thBaseClasses() {
          return [this.computedClass('thClass', 'o-table__th')];
        },

        tdBaseClasses() {
          return [this.computedClass('tdClass', 'o-table__td')];
        },

        thCheckboxClasses() {
          return [...this.thBaseClasses, this.computedClass('thCheckboxClass', 'o-table__th-checkbox')];
        },

        thDetailedClasses() {
          return [...this.thBaseClasses, this.computedClass('thDetailedClass', 'o-table__th--detailed')];
        },

        thSubheadingClasses() {
          return [...this.thBaseClasses, this.computedClass('thSubheadingClass', 'o-table__th')];
        },

        tdCheckboxClasses() {
          return [...this.tdBaseClasses, this.computedClass('tdCheckboxClass', 'o-table__td-checkbox'), ...this.thStickyClasses({
            sticky: this.stickyCheckbox
          })];
        },

        detailedClasses() {
          return [this.computedClass('detailedClass', 'o-table__detail')];
        },

        tdDetailedChevronClasses() {
          return [...this.tdBaseClasses, this.computedClass('tdDetailedChevronClass', 'o-table__td-chevron')];
        },

        mobileSortClasses() {
          return [this.computedClass('mobileSortClass', 'o-table__mobile-sort')];
        },

        paginationWrapperClasses() {
          return [this.computedClass('paginationWrapperClass', 'o-table__pagination')];
        },

        tableWrapperStyle() {
          return {
            height: toCssDimension(this.height)
          };
        },

        /**
        * Splitted data based on the pagination.
        */
        visibleData() {
          if (!this.paginated) return this.newData;
          const currentPage = this.newCurrentPage;
          const perPage = this.perPage;

          if (this.newData.length <= perPage) {
            return this.newData;
          } else {
            const start = (currentPage - 1) * perPage;
            const end = parseInt(start, 10) + parseInt(perPage, 10);
            return this.newData.slice(start, end);
          }
        },

        visibleColumns() {
          if (!this.newColumns) return this.newColumns;
          return this.newColumns.filter(column => {
            return column.visible || column.visible === undefined;
          });
        },

        /**
        * Check if all rows in the page are checked.
        */
        isAllChecked() {
          const validVisibleData = this.visibleData.filter(row => this.isRowCheckable(row));
          if (validVisibleData.length === 0) return false;
          const isAllChecked = validVisibleData.some(currentVisibleRow => {
            return indexOf(this.newCheckedRows, currentVisibleRow, this.customIsChecked) < 0;
          });
          return !isAllChecked;
        },

        /**
        * Check if all rows in the page are checkable.
        */
        isAllUncheckable() {
          const validVisibleData = this.visibleData.filter(row => this.isRowCheckable(row));
          return validVisibleData.length === 0;
        },

        /**
        * Check if has any sortable column.
        */
        hasSortablenewColumns() {
          return this.newColumns.some(column => {
            return column.sortable;
          });
        },

        /**
        * Check if has any searchable column.
        */
        hasSearchablenewColumns() {
          return this.newColumns.some(column => {
            return column.searchable;
          });
        },

        /**
        * Return total column count based if it's checkable or expanded
        */
        columnCount() {
          let count = this.visibleColumns.length;
          count += this.checkable ? 1 : 0;
          count += this.detailed && this.showDetailIcon ? 1 : 0;
          return count;
        },

        /**
        * return if detailed row tabled
        * will be with chevron column & icon or not
        */
        showDetailRowIcon() {
          return this.detailed && this.showDetailIcon;
        },

        /**
        * return if scrollable table
        */
        isScrollable() {
          if (this.scrollable) return true;
          if (!this.newColumns) return false;
          return this.newColumns.some(column => {
            return column.sticky;
          });
        },

        newColumns() {
          if (this.columns && this.columns.length) {
            return this.columns.map(column => {
              const TableColumnComponent = VueInstance.extend(__vue_component__$E);
              const component = new TableColumnComponent({
                parent: this,
                propsData: column
              });
              component.$scopedSlots = {
                'default': props => {
                  const vnode = component.$createElement('span', {
                    domProps: {
                      innerHTML: getValueByPath(props.row, column.field)
                    }
                  });
                  return [vnode];
                }
              };
              return component;
            });
          }

          return this.defaultSlots.filter(vnode => vnode.componentInstance && vnode.componentInstance.$data && vnode.componentInstance.$data._isTableColumn).map(vnode => vnode.componentInstance);
        },

        isMobile() {
          return this.mobileCards && this.isMatchMedia;
        },

        hasCustomSubheadings() {
          if (this.$scopedSlots && this.$scopedSlots.subheading) return true;
          return this.newColumns.some(column => {
            return column.subheading || column.$scopedSlots && column.$scopedSlots.subheading;
          });
        },

        canDragRow() {
          return this.draggable && !this.isDraggingColumn;
        },

        canDragColumn() {
          return this.draggableColumn && !this.isDraggingRow;
        }

      },
      watch: {
        /**
        * When data prop change:
        *   1. Update internal value.
        *   2. Filter data if it's not backend-filtered.
        *   3. Sort again if it's not backend-sorted.
        *   4. Set new total if it's not backend-paginated.
        */
        data(value) {
          this.newData = value;

          if (!this.backendFiltering) {
            this.newData = value.filter(row => this.isRowFiltered(row));
          }

          if (!this.backendSorting) {
            this.sort(this.currentSortColumn, true);
          }

          if (!this.backendPagination) {
            this.newDataTotal = this.newData.length;
          }
        },

        /**
        * When Pagination total change, update internal total
        * only if it's backend-paginated.
        */
        total(newTotal) {
          if (!this.backendPagination) return;
          this.newDataTotal = newTotal;
        },

        currentPage(newValue) {
          this.newCurrentPage = newValue;
        },

        /**
        * When checkedRows prop change, update internal value without
        * mutating original data.
        */
        checkedRows(rows) {
          this.newCheckedRows = [...rows];
        },

        debounceSearch: {
          handler(value) {
            this.debouncedHandleFiltersChange = debounce(this.handleFiltersChange, value);
          },

          immediate: true
        },
        filters: {
          handler(value) {
            if (this.debounceSearch) {
              this.debouncedHandleFiltersChange(value);
            } else {
              this.handleFiltersChange(value);
            }
          },

          deep: true
        },

        /**
        * When the user wants to control the detailed rows via props.
        * Or wants to open the details of certain row with the router for example.
        */
        openedDetailed(expandedRows) {
          this.visibleDetailRows = expandedRows;
        },

        newCurrentPage(newVal) {
          this.$emit('update:currentPage', newVal);
        }

      },
      methods: {
        refreshSlots() {
          this.defaultSlots = this.$slots.default || [];
        },

        thClasses(column) {
          return [...this.thBaseClasses, ...this.thStickyClasses(column), getValueByPath(column.thAttrs(column), 'class'), {
            [this.computedClass('thCurrentSortClass', 'o-table__th-current-sort')]: this.currentSortColumn === column
          }, {
            [this.computedClass('thSortableClass', 'o-table__th--sortable')]: column.sortable
          }, {
            [this.computedClass('thUnselectableClass', 'o-table__th--unselectable')]: column.isHeaderUnselectable
          }, {
            [this.computedClass('thPositionClass', 'o-table__th--', column.position)]: column.position
          }];
        },

        thStickyClasses(column) {
          return [{
            [this.computedClass('thStickyClass', 'o-table__th--sticky')]: column.sticky
          }];
        },

        rowClasses(row, index) {
          return [this.rowClass(row, index), {
            [this.computedClass('trSelectedClass', 'o-table__tr--selected')]: this.isRowSelected(row, this.selected)
          }, {
            [this.computedClass('trCheckedClass', 'o-table__tr--checked')]: this.isRowChecked(row)
          }];
        },

        thSortIconClasses() {
          return [this.computedClass('thSortIconClass', 'o-table__th__sort-icon')];
        },

        tdClasses(row, column) {
          return [...this.tdBaseClasses, getValueByPath(column.tdAttrs(row, column), 'class'), {
            [this.computedClass('tdPositionClass', 'o-table__td--', column.position)]: column.position
          }, {
            [this.computedClass('tdStickyClass', 'o-table__td--sticky')]: column.sticky
          }];
        },

        onFiltersEvent(event) {
          this.$emit(`filters-event-${this.filtersEvent}`, {
            event,
            filters: this.filters
          });
        },

        handleFiltersChange(value) {
          if (this.backendFiltering) {
            this.$emit('filters-change', value);
          } else {
            this.newData = this.data.filter(row => this.isRowFiltered(row));

            if (!this.backendPagination) {
              this.newDataTotal = this.newData.length;
            }

            if (!this.backendSorting) {
              if (Object.keys(this.currentSortColumn).length > 0) {
                this.doSortSingleColumn(this.currentSortColumn);
              }
            }
          }
        },

        /**
        * Sort an array by key without mutating original data.
        * Call the user sort function if it was passed.
        */
        sortBy(array, key, fn, isAsc) {
          let sorted = []; // Sorting without mutating original data

          if (fn && typeof fn === 'function') {
            sorted = [...array].sort((a, b) => fn(a, b, isAsc));
          } else {
            sorted = [...array].sort((a, b) => {
              // Get nested values from objects
              let newA = getValueByPath(a, key);
              let newB = getValueByPath(b, key); // sort boolean type

              if (typeof newA === 'boolean' && typeof newB === 'boolean') {
                return isAsc ? newA - newB : newB - newA;
              }

              if (!newA && newA !== 0) return 1;
              if (!newB && newB !== 0) return -1;
              if (newA === newB) return 0;
              newA = typeof newA === 'string' ? newA.toUpperCase() : newA;
              newB = typeof newB === 'string' ? newB.toUpperCase() : newB;
              return isAsc ? newA > newB ? 1 : -1 : newA > newB ? -1 : 1;
            });
          }

          return sorted;
        },

        /**
        * Sort the column.
        * Toggle current direction on column if it's sortable
        * and not just updating the prop.
        */
        sort(column, updatingData = false, event = null) {
          if (!column || !column.sortable) return;

          if (!updatingData) {
            this.isAsc = column === this.currentSortColumn ? !this.isAsc : this.defaultSortDirection.toLowerCase() !== 'desc';
          }

          if (!this.firstTimeSort) {
            /**
             * @property {string} field column field
             * @property {boolean} direction 'asc' or 'desc'
             * @property {Event} event native event
            */
            this.$emit('sort', column.field, this.isAsc ? 'asc' : 'desc', event);
          }

          if (!this.backendSorting) {
            this.doSortSingleColumn(column);
          }

          this.currentSortColumn = column;
        },

        doSortSingleColumn(column) {
          this.newData = this.sortBy(this.newData, column.field, column.customSort, this.isAsc);
        },

        isRowSelected(row, selected) {
          if (!selected) {
            return false;
          }

          if (this.customRowKey) {
            return row[this.customRowKey] === selected[this.customRowKey];
          }

          return row === selected;
        },

        /**
        * Check if the row is checked (is added to the array).
        */
        isRowChecked(row) {
          return indexOf(this.newCheckedRows, row, this.customIsChecked) >= 0;
        },

        /**
        * Remove a checked row from the array.
        */
        removeCheckedRow(row) {
          const index = indexOf(this.newCheckedRows, row, this.customIsChecked);

          if (index >= 0) {
            this.newCheckedRows.splice(index, 1);
          }
        },

        /**
        * Header checkbox click listener.
        * Add or remove all rows in current page.
        */
        checkAll() {
          const isAllChecked = this.isAllChecked;
          this.visibleData.forEach(currentRow => {
            if (this.isRowCheckable(currentRow)) {
              this.removeCheckedRow(currentRow);
            }

            if (!isAllChecked) {
              if (this.isRowCheckable(currentRow)) {
                this.newCheckedRows.push(currentRow);
              }
            }
          });
          /**
           * @property {Array<Object>} newCheckedRows checked rows
           */

          this.$emit('check', this.newCheckedRows);
          this.$emit('check-all', this.newCheckedRows); // Emit checked rows to update user variable

          this.$emit('update:checkedRows', this.newCheckedRows);
        },

        /**
        * Row checkbox click listener.
        */
        checkRow(row, index, event) {
          if (!this.isRowCheckable(row)) return;
          const lastIndex = this.lastCheckedRowIndex;
          this.lastCheckedRowIndex = index;

          if (event.shiftKey && lastIndex !== null && index !== lastIndex) {
            this.shiftCheckRow(row, index, lastIndex);
          } else if (!this.isRowChecked(row)) {
            this.newCheckedRows.push(row);
          } else {
            this.removeCheckedRow(row);
          }

          this.$emit('check', this.newCheckedRows, row); // Emit checked rows to update user variable

          this.$emit('update:checkedRows', this.newCheckedRows);
        },

        /**
         * Check row when shift is pressed.
         */
        shiftCheckRow(row, index, lastCheckedRowIndex) {
          // Get the subset of the list between the two indicies
          const subset = this.visibleData.slice(Math.min(index, lastCheckedRowIndex), Math.max(index, lastCheckedRowIndex) + 1); // Determine the operation based on the state of the clicked checkbox

          const shouldCheck = !this.isRowChecked(row);
          subset.forEach(item => {
            this.removeCheckedRow(item);

            if (shouldCheck && this.isRowCheckable(item)) {
              this.newCheckedRows.push(item);
            }
          });
        },

        /**
        * Row click listener.
        * Emit all necessary events.
        */
        selectRow(row, index) {
          /**
           * @property {Object} row clicked row
           * @property {number} index index of clicked row
           */
          this.$emit('click', row, index);
          if (this.selected === row) return;
          if (!this.isRowSelectable(row)) return; // Emit new and old row

          /**
           * @property {Object} row selected row
           * @property {Array<Object>} selected selected rows
           */

          this.$emit('select', row, this.selected); // Emit new row to update user variable

          this.$emit('update:selected', row);
        },

        /**
        * Toggle to show/hide details slot
        */
        toggleDetails(obj) {
          const found = this.isVisibleDetailRow(obj);

          if (found) {
            this.closeDetailRow(obj);
            this.$emit('details-close', obj);
          } else {
            this.openDetailRow(obj);
            this.$emit('details-open', obj);
          } // Syncs the detailed rows with the parent component


          this.$emit('update:openedDetailed', this.visibleDetailRows);
        },

        openDetailRow(obj) {
          const index = this.handleDetailKey(obj);
          this.visibleDetailRows.push(index);
        },

        closeDetailRow(obj) {
          const index = this.handleDetailKey(obj);
          const i = this.visibleDetailRows.indexOf(index);

          if (i >= 0) {
            this.visibleDetailRows.splice(i, 1);
          }
        },

        isVisibleDetailRow(obj) {
          const index = this.handleDetailKey(obj);
          return this.visibleDetailRows.indexOf(index) >= 0;
        },

        isActiveDetailRow(row) {
          return this.detailed && !this.customDetailRow && this.isVisibleDetailRow(row);
        },

        isActiveCustomDetailRow(row) {
          return this.detailed && this.customDetailRow && this.isVisibleDetailRow(row);
        },

        isRowFiltered(row) {
          for (const key in this.filters) {
            if (!this.filters[key]) continue;
            const input = this.filters[key];
            const column = this.newColumns.filter(c => c.field === key)[0];

            if (column && column.customSearch && typeof column.customSearch === 'function') {
              if (!column.customSearch(row, input)) return false;
            } else {
              const value = getValueByPath(row, key);
              if (value == null) return false;

              if (Number.isInteger(value)) {
                if (value !== Number(input)) return false;
              } else {
                const re = new RegExp(escapeRegExpChars(input), 'i');

                if (Array.isArray(value)) {
                  const valid = value.some(val => re.test(removeDiacriticsFromString(val)) || re.test(val));
                  if (!valid) return false;
                } else {
                  if (!re.test(removeDiacriticsFromString(value)) && !re.test(value)) {
                    return false;
                  }
                }
              }
            }
          }

          return true;
        },

        /**
        * When the detailKey is defined we use the object[detailKey] as index.
        * If not, use the object reference by default.
        */
        handleDetailKey(index) {
          const key = this.detailKey;
          return !key.length || !index ? index : index[key];
        },

        /**
        * Call initSort only first time (For example async data).
        */
        checkSort() {
          if (this.newColumns.length && this.firstTimeSort) {
            this.initSort();
            this.firstTimeSort = false;
          } else if (this.newColumns.length) {
            if (Object.keys(this.currentSortColumn).length > 0) {
              for (let i = 0; i < this.newColumns.length; i++) {
                if (this.newColumns[i].field === this.currentSortColumn.field) {
                  this.currentSortColumn = this.newColumns[i];
                  break;
                }
              }
            }
          }
        },

        /**
        * Check if footer slot has custom content.
        */
        hasCustomFooterSlot() {
          const footer = this.$slots.footer;
          if (footer.length > 1) return true;
          const tag = footer[0].tag;
          if (tag !== 'th' && tag !== 'td') return false;
          return true;
        },

        /**
        * Table arrow keys listener, change selection.
        */
        pressedArrow(pos) {
          if (!this.visibleData.length) return;
          let index = this.visibleData.indexOf(this.selected) + pos; // Prevent from going up from first and down from last

          index = index < 0 ? 0 : index > this.visibleData.length - 1 ? this.visibleData.length - 1 : index;
          const row = this.visibleData[index];

          if (!this.isRowSelectable(row)) {
            let newIndex = null;

            if (pos > 0) {
              for (let i = index; i < this.visibleData.length && newIndex === null; i++) {
                if (this.isRowSelectable(this.visibleData[i])) newIndex = i;
              }
            } else {
              for (let i = index; i >= 0 && newIndex === null; i--) {
                if (this.isRowSelectable(this.visibleData[i])) newIndex = i;
              }
            }

            if (newIndex >= 0) {
              this.selectRow(this.visibleData[newIndex]);
            }
          } else {
            this.selectRow(row);
          }
        },

        /**
        * Focus table element if has selected prop.
        */
        focus() {
          if (!this.focusable) return;
          this.$el.querySelector('table').focus();
        },

        /**
        * Initial sorted column based on the default-sort prop.
        */
        initSort() {
          if (!this.defaultSort) return;
          let sortField = '';
          let sortDirection = this.defaultSortDirection;

          if (Array.isArray(this.defaultSort)) {
            sortField = this.defaultSort[0];

            if (this.defaultSort[1]) {
              sortDirection = this.defaultSort[1];
            }
          } else {
            sortField = this.defaultSort;
          }

          const sortColumn = this.newColumns.filter(column => column.field === sortField)[0];

          if (sortColumn) {
            this.isAsc = sortDirection.toLowerCase() !== 'desc';
            this.sort(sortColumn, true);
          }
        },

        /**
        * Emits drag start event
        */
        handleDragStart(event, row, index) {
          if (!this.draggable) return;
          this.$emit('dragstart', {
            event,
            row,
            index
          });
        },

        /**
        * Emits drag leave event
        */
        handleDragEnd(event, row, index) {
          if (!this.draggable) return;
          this.$emit('dragend', {
            event,
            row,
            index
          });
        },

        /**
        * Emits drop event
        */
        handleDrop(event, row, index) {
          if (!this.draggable) return;
          this.$emit('drop', {
            event,
            row,
            index
          });
        },

        /**
        * Emits drag over event
        */
        handleDragOver(event, row, index) {
          if (!this.draggable) return;
          this.$emit('dragover', {
            event,
            row,
            index
          });
        },

        /**
        * Emits drag leave event
        */
        handleDragLeave(event, row, index) {
          if (!this.draggable) return;
          this.$emit('dragleave', {
            event,
            row,
            index
          });
        },

        /**
        * Emits drag start event (column)
        */
        handleColumnDragStart(event, column, index) {
          if (!this.canDragColumn) return;
          this.isDraggingColumn = true;
          this.$emit('columndragstart', {
            event,
            column,
            index
          });
        },

        /**
        * Emits drag leave event (column)
        */
        handleColumnDragEnd(event, column, index) {
          if (!this.canDragColumn) return;
          this.isDraggingColumn = false;
          this.$emit('columndragend', {
            event,
            column,
            index
          });
        },

        /**
        * Emits drop event (column)
        */
        handleColumnDrop(event, column, index) {
          if (!this.canDragColumn) return;
          this.$emit('columndrop', {
            event,
            column,
            index
          });
        },

        /**
        * Emits drag over event (column)
        */
        handleColumnDragOver(event, column, index) {
          if (!this.canDragColumn) return;
          this.$emit('columndragover', {
            event,
            column,
            index
          });
        },

        /**
        * Emits drag leave event (column)
        */
        handleColumnDragLeave(event, column, index) {
          if (!this.canDragColumn) return;
          this.$emit('columndragleave', {
            event,
            column,
            index
          });
        },

        emitEventForRow(eventName, event, row) {
          return this.$listeners[eventName] ? this.$emit(eventName, row, event) : null;
        },

        _addColumn(column) {
          this.defaultSlots.push(column);
          const slot = this.$refs['slot'];

          if (slot && slot.children) {
            this.$nextTick(() => {
              const ids = this.defaultSlots.map(it => `[data-id="${it.newKey}"]`).join(',');
              const sortedIds = Array.from(slot.querySelectorAll(ids)).map(el => el.getAttribute('data-id'));
              this.defaultSlots = this.defaultSlots.sort((a, b) => sortedIds.indexOf(`${a.newKey}`) - sortedIds.indexOf(`${b.newKey}`));
            });
          }
        },

        _removeColumn(column) {
          this.$nextTick(() => {
            this.defaultSlots = this.defaultSlots.filter(d => d.newKey !== column.newKey);
          });
        },

        _nextSequence() {
          return this.sequence++;
        }

      }
    };

    /* script */
    const __vue_script__$G = script$G;

    /* template */
    var __vue_render__$B = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.rootClasses},[_c('div',{ref:"slot",staticStyle:{"display":"none"}},[_vm._t("default")],2),(_vm.isMobile && _vm.hasSortablenewColumns)?_c('o-table-mobile-sort',{attrs:{"current-sort-column":_vm.currentSortColumn,"columns":_vm.newColumns,"placeholder":_vm.mobileSortPlaceholder,"icon-pack":_vm.iconPack,"sort-icon":_vm.sortIcon,"sort-icon-size":_vm.sortIconSize,"is-asc":_vm.isAsc},on:{"sort":function (column, event) { return _vm.sort(column, null, event); }}}):_vm._e(),(_vm.paginated && (_vm.paginationPosition === 'top' || _vm.paginationPosition === 'both'))?[_vm._t("pagination",[_c('o-table-pagination',_vm._b({attrs:{"per-page":_vm.perPage,"paginated":_vm.paginated,"total":_vm.newDataTotal,"current-page":_vm.newCurrentPage,"root-class":_vm.paginationWrapperClasses,"icon-pack":_vm.iconPack,"rounded":_vm.paginationRounded,"paginationSize":_vm.paginationSize,"aria-next-label":_vm.ariaNextLabel,"aria-previous-label":_vm.ariaPreviousLabel,"aria-page-label":_vm.ariaPageLabel,"aria-current-label":_vm.ariaCurrentLabel},on:{"update:currentPage":function($event){_vm.newCurrentPage = $event;},"page-change":function (event) { return _vm.$emit('page-change', event); }}},'o-table-pagination',_vm.$attrs,false),[_vm._t("top-left")],2)])]:_vm._e(),_c('div',{class:_vm.tableWrapperClasses,style:(_vm.tableWrapperStyle)},[_c('table',{class:_vm.tableClasses,attrs:{"tabindex":!_vm.focusable ? false : 0},on:{"keydown":[function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"up",38,$event.key,["Up","ArrowUp"])){ return null; }if($event.target !== $event.currentTarget){ return null; }$event.preventDefault();return _vm.pressedArrow(-1)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"down",40,$event.key,["Down","ArrowDown"])){ return null; }if($event.target !== $event.currentTarget){ return null; }$event.preventDefault();return _vm.pressedArrow(1)}]}},[(_vm.$slots.caption)?_c('caption',[_vm._t("caption")],2):_vm._e(),(_vm.newColumns.length && _vm.showHeader)?_c('thead',[_vm._t("preheader"),_c('tr',[(_vm.showDetailRowIcon)?_c('th',{class:_vm.thDetailedClasses}):_vm._e(),(_vm.checkable && _vm.checkboxPosition === 'left')?_c('th',{class:_vm.thCheckboxClasses},[(_vm.headerCheckable)?[_c('o-checkbox',{attrs:{"autocomplete":"off","value":_vm.isAllChecked,"disabled":_vm.isAllUncheckable},nativeOn:{"change":function($event){return _vm.checkAll($event)}}})]:_vm._e()],2):_vm._e(),_vm._l((_vm.visibleColumns),function(column,index){return _c('th',_vm._b({key:column.newKey + ':' + index + 'header',class:_vm.thClasses(column),style:(column.style),attrs:{"draggable":_vm.canDragColumn},on:{"click":function($event){$event.stopPropagation();return _vm.sort(column, null, $event)},"dragstart":function($event){return _vm.handleColumnDragStart($event, column, index)},"dragend":function($event){return _vm.handleColumnDragEnd($event, column, index)},"drop":function($event){return _vm.handleColumnDrop($event, column, index)},"dragover":function($event){return _vm.handleColumnDragOver($event, column, index)},"dragleave":function($event){return _vm.handleColumnDragLeave($event, column, index)}}},'th',column.thAttrs(column),false),[(column.hasHeaderSlot)?[_c('o-slot-component',{attrs:{"component":column,"scoped":"","name":"header","tag":"span","props":{ column: column, index: index }}})]:[_c('span',[_vm._v(" "+_vm._s(column.label)+" "),_c('span',{directives:[{name:"show",rawName:"v-show",value:(column.sortable && _vm.currentSortColumn === column),expression:"column.sortable && currentSortColumn === column"}],class:_vm.thSortIconClasses(column)},[_c('o-icon',{attrs:{"icon":_vm.sortIcon,"pack":_vm.iconPack,"both":"","size":_vm.sortIconSize,"rotation":!_vm.isAsc ? 180 : 0}})],1)])]],2)}),(_vm.checkable && _vm.checkboxPosition === 'right')?_c('th',{class:_vm.thCheckboxClasses},[(_vm.headerCheckable)?[_c('o-checkbox',{attrs:{"autocomplete":"off","value":_vm.isAllChecked,"disabled":_vm.isAllUncheckable},nativeOn:{"change":function($event){return _vm.checkAll($event)}}})]:_vm._e()],2):_vm._e()],2),(_vm.hasSearchablenewColumns)?_c('tr',[(_vm.showDetailRowIcon)?_c('th',{class:_vm.thDetailedClasses}):_vm._e(),(_vm.checkable && _vm.checkboxPosition === 'left')?_c('th'):_vm._e(),_vm._l((_vm.visibleColumns),function(column,index){return _c('th',_vm._b({key:column.newKey + ':' + index + 'searchable',class:_vm.thClasses(column),style:(column.style)},'th',column.thAttrs(column),false),[(column.searchable)?[(column.hasSearchableSlot)?[_c('o-slot-component',{attrs:{"component":column,"scoped":"","name":"searchable","tag":"span","props":{ column: column, filters: _vm.filters }}})]:_c('o-input',{attrs:{"type":column.numeric ? 'number' : 'text'},nativeOn:_vm._d({},[_vm.filtersEvent,function($event){return _vm.onFiltersEvent($event)}]),model:{value:(_vm.filters[column.field]),callback:function ($$v) {_vm.$set(_vm.filters, column.field, $$v);},expression:"filters[column.field]"}})]:_vm._e()],2)}),(_vm.checkable && _vm.checkboxPosition === 'right')?_c('th'):_vm._e()],2):_vm._e(),(_vm.hasCustomSubheadings)?_c('tr',[(_vm.showDetailRowIcon)?_c('th',{class:_vm.thDetailedClasses}):_vm._e(),(_vm.checkable && _vm.checkboxPosition === 'left')?_c('th'):_vm._e(),_vm._l((_vm.visibleColumns),function(column,index){return _c('th',{key:column.newKey + ':' + index + 'subheading',class:_vm.thSubheadingClasses,style:(column.style)},[(
                                    column.$scopedSlots &&
                                    column.$scopedSlots.subheading
                                )?[_c('o-slot-component',{attrs:{"component":column,"scoped":"","name":"subheading","tag":"span","props":{ column: column, index: index }}})]:[_vm._v(_vm._s(column.subheading))]],2)}),(_vm.checkable && _vm.checkboxPosition === 'right')?_c('th'):_vm._e()],2):_vm._e()],2):_vm._e(),_c('tbody',[_vm._l((_vm.visibleData),function(row,index){return [_c('tr',{key:_vm.customRowKey ? row[_vm.customRowKey] : index,class:_vm.rowClasses(row, index),attrs:{"draggable":_vm.canDragRow},on:{"click":function($event){return _vm.selectRow(row, index)},"dblclick":function($event){return _vm.$emit('dblclick', row)},"mouseenter":function($event){return _vm.emitEventForRow('mouseenter', $event, row)},"mouseleave":function($event){return _vm.emitEventForRow('mouseleave', $event, row)},"contextmenu":function($event){return _vm.$emit('contextmenu', row, $event)},"dragstart":function($event){return _vm.handleDragStart($event, row, index)},"dragend":function($event){return _vm.handleDragEnd($event, row, index)},"drop":function($event){return _vm.handleDrop($event, row, index)},"dragover":function($event){return _vm.handleDragOver($event, row, index)},"dragleave":function($event){return _vm.handleDragLeave($event, row, index)}}},[(_vm.showDetailRowIcon)?_c('td',{class:_vm.tdDetailedChevronClasses},[(_vm.hasDetailedVisible(row))?_c('o-icon',{attrs:{"icon":_vm.detailIcon,"pack":_vm.iconPack,"rotation":_vm.isVisibleDetailRow(row) ? 90 : 0,"role":"button","clickable":"","both":""},nativeOn:{"click":function($event){$event.stopPropagation();return _vm.toggleDetails(row)}}}):_vm._e()],1):_vm._e(),(_vm.checkable && _vm.checkboxPosition === 'left')?_c('td',{class:_vm.tdCheckboxClasses},[_c('o-checkbox',{attrs:{"autocomplete":"off","disabled":!_vm.isRowCheckable(row),"value":_vm.isRowChecked(row)},on:{"input":function($event){return _vm.checkRow(row, index, $event)}}})],1):_vm._e(),_vm._l((_vm.visibleColumns),function(column,colindex){return [(column.hasDefaultSlot)?[_c('o-slot-component',_vm._b({key:column.newKey + index + ':' + colindex,class:_vm.tdClasses(row, column),attrs:{"component":column,"scoped":"","name":"default","tag":"td","data-label":column.label,"props":{ row: row, column: column, index: index, colindex: colindex, toggleDetails: _vm.toggleDetails }},nativeOn:{"click":function($event){return _vm.$emit('cell-click', row, column, index, colindex, $event)}}},'o-slot-component',column.tdAttrs(row, column),false))]:_vm._e()]}),(_vm.checkable && _vm.checkboxPosition === 'right')?_c('td',{class:_vm.tdCheckboxClasses},[_c('o-checkbox',{attrs:{"autocomplete":"off","disabled":!_vm.isRowCheckable(row),"value":_vm.isRowChecked(row)},on:{"input":function($event){return _vm.checkRow(row, index, $event)}}})],1):_vm._e()],2),_c('transition',{key:(_vm.customRowKey ? row[_vm.customRowKey] : index) + 'detail',attrs:{"name":_vm.detailTransition}},[(_vm.isActiveDetailRow(row))?_c('tr',{class:_vm.detailedClasses},[_c('td',{attrs:{"colspan":_vm.columnCount}},[_vm._t("detail",null,{"row":row,"index":index})],2)]):_vm._e()]),(_vm.isActiveCustomDetailRow(row))?_vm._t("detail",null,{"row":row,"index":index}):_vm._e()]}),(!_vm.visibleData.length)?_c('tr',[_c('td',{attrs:{"colspan":_vm.columnCount}},[_vm._t("empty")],2)]):_vm._e()],2),(_vm.$slots.footer)?_c('tfoot',[_c('tr',{class:_vm.footerClasses},[(_vm.hasCustomFooterSlot())?_vm._t("footer"):_c('th',{attrs:{"colspan":_vm.columnCount}},[_vm._t("footer")],2)],2)]):_vm._e()]),_vm._t("loading",[_c('o-loading',{attrs:{"full-page":false,"active":_vm.loading}})])],2),((_vm.checkable && _vm.$slots['bottom-left']) ||
            (_vm.paginated && (_vm.paginationPosition === 'bottom' || _vm.paginationPosition === 'both')))?[_vm._t("pagination",[_c('o-table-pagination',_vm._b({attrs:{"per-page":_vm.perPage,"paginated":_vm.paginated,"total":_vm.newDataTotal,"current-page":_vm.newCurrentPage,"root-class":_vm.paginationWrapperClasses,"icon-pack":_vm.iconPack,"rounded":_vm.paginationRounded,"size":_vm.paginationSize,"aria-next-label":_vm.ariaNextLabel,"aria-previous-label":_vm.ariaPreviousLabel,"aria-page-label":_vm.ariaPageLabel,"aria-current-label":_vm.ariaCurrentLabel},on:{"update:currentPage":function($event){_vm.newCurrentPage = $event;},"page-change":function (event) { return _vm.$emit('page-change', event); }}},'o-table-pagination',_vm.$attrs,false),[_vm._t("bottom-left")],2)])]:_vm._e()],2)};
    var __vue_staticRenderFns__$B = [];

      /* style */
      const __vue_inject_styles__$G = undefined;
      /* scoped */
      const __vue_scope_id__$G = undefined;
      /* module identifier */
      const __vue_module_identifier__$G = undefined;
      /* functional template */
      const __vue_is_functional_template__$G = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$G = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$B, staticRenderFns: __vue_staticRenderFns__$B },
        __vue_inject_styles__$G,
        __vue_script__$G,
        __vue_scope_id__$G,
        __vue_is_functional_template__$G,
        __vue_module_identifier__$G,
        false,
        undefined,
        undefined,
        undefined
      );

    const Plugin$p = {
      install(Vue) {
        // individual import + extend method into Table.vue
        if (typeof VueInstance === 'undefined') {
          setVueInstance(Vue);
        }

        registerComponent(Vue, __vue_component__$G);
        registerComponent(Vue, __vue_component__$E);
      }

    };
    use(Plugin$p);

    //
    /**
     * Responsive horizontal navigation tabs, switch between contents with ease
     * @displayName Tabs
     * @requires ./TabItem.vue
     * @example ./examples/Tabs.md
     * @style _tabs.scss
     */

    var script$H = {
      name: 'OTabs',
      mixins: [BaseComponentMixin, TabbedMixin('tab')],
      configField: 'tabs',
      props: {
        /**
         * Tab type
         * @values boxed, toggle
         */
        type: {
          type: String,
          default: 'default'
        },

        /**
        * Tabs will be expanded (full-width)
        */
        expanded: Boolean,

        /** Tab will have an animation */
        animated: {
          type: Boolean,
          default: () => {
            return getValueByPath(getOptions(), 'tabs.animated', true);
          }
        },

        /** Show tab items multiline when there is no space */
        multiline: Boolean,
        rootClass: [String, Function, Array],
        positionClass: [String, Function, Array],
        expandedClass: [String, Function, Array],
        verticalClass: [String, Function, Array],
        multilineClass: [String, Function, Array],
        navTabsClass: [String, Function, Array],
        navSizeClass: [String, Function, Array],
        navPositionClass: [String, Function, Array],
        navTypeClass: [String, Function, Array],
        contentClass: [String, Function, Array],
        transitioningClass: [String, Function, Array],
        tabItemWrapperClass: [String, Function, Array]
      },
      computed: {
        rootClasses() {
          return [this.computedClass('rootClass', 'o-tabs'), {
            [this.computedClass('positionClass', 'o-tabs--', this.position)]: this.position && this.vertical
          }, {
            [this.computedClass('expandedClass', 'o-tabs--fullwidth')]: this.expanded
          }, {
            [this.computedClass('verticalClass', 'o-tabs--vertical')]: this.vertical
          }, {
            [this.computedClass('multilineClass', 'o-tabs--multiline')]: this.multiline
          }];
        },

        itemWrapperClasses() {
          return [this.computedClass('tabItemWrapperClass', 'o-tabs__nav-item-wrapper')];
        },

        navClasses() {
          return [this.computedClass('navTabsClass', 'o-tabs__nav'), {
            [this.computedClass('navSizeClass', 'o-tabs__nav--', this.size)]: this.size
          }, {
            [this.computedClass('navPositionClass', 'o-tabs__nav--', this.position)]: this.position && !this.vertical
          }, {
            [this.computedClass('navTypeClass', 'o-tabs__nav--', this.type)]: this.type
          }];
        },

        contentClasses() {
          return [this.computedClass('contentClass', 'o-tabs__content'), {
            [this.computedClass('transitioningClass', 'o-tabs__content--transitioning')]: this.isTransitioning
          }];
        }

      }
    };

    /* script */
    const __vue_script__$H = script$H;

    /* template */
    var __vue_render__$C = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{class:_vm.rootClasses},[_c('nav',{class:_vm.navClasses,attrs:{"role":"tablist","aria-orientation":_vm.vertical ? 'vertical' : 'horizontal'}},[_vm._t("start"),_vm._l((_vm.items),function(childItem){return _c('div',{directives:[{name:"show",rawName:"v-show",value:(childItem.visible),expression:"childItem.visible"}],key:childItem.newValue,class:_vm.itemWrapperClasses,attrs:{"role":"tab","aria-controls":((childItem.value) + "-content"),"aria-selected":("" + (childItem.isActive))}},[(childItem.$scopedSlots.header)?_c('o-slot-component',{class:childItem.headerClasses,attrs:{"component":childItem,"tag":childItem.tag,"name":"header"},nativeOn:{"click":function($event){return _vm.childClick(childItem)},"keydown":[function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"left",37,$event.key,["Left","ArrowLeft"])){ return null; }if('button' in $event && $event.button !== 0){ return null; }$event.preventDefault();return _vm.prev($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"right",39,$event.key,["Right","ArrowRight"])){ return null; }if('button' in $event && $event.button !== 2){ return null; }$event.preventDefault();return _vm.next($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"up",38,$event.key,["Up","ArrowUp"])){ return null; }$event.preventDefault();return _vm.prev($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"down",40,$event.key,["Down","ArrowDown"])){ return null; }$event.preventDefault();return _vm.next($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"home",undefined,$event.key,undefined)){ return null; }$event.preventDefault();return _vm.homePressed($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"end",undefined,$event.key,undefined)){ return null; }$event.preventDefault();return _vm.endPressed($event)}]}}):_c(childItem.tag,{tag:"component",class:childItem.headerClasses,on:{"click":function($event){return _vm.childClick(childItem)},"keydown":[function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"left",37,$event.key,["Left","ArrowLeft"])){ return null; }if('button' in $event && $event.button !== 0){ return null; }$event.preventDefault();return _vm.prev($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"right",39,$event.key,["Right","ArrowRight"])){ return null; }if('button' in $event && $event.button !== 2){ return null; }$event.preventDefault();return _vm.next($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"up",38,$event.key,["Up","ArrowUp"])){ return null; }$event.preventDefault();return _vm.prev($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"down",40,$event.key,["Down","ArrowDown"])){ return null; }$event.preventDefault();return _vm.next($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"home",undefined,$event.key,undefined)){ return null; }$event.preventDefault();return _vm.homePressed($event)},function($event){if(!$event.type.indexOf('key')&&_vm._k($event.keyCode,"end",undefined,$event.key,undefined)){ return null; }$event.preventDefault();return _vm.endPressed($event)}]}},[(childItem.icon)?_c('o-icon',{attrs:{"rootClass":childItem.headerIconClasses,"icon":childItem.icon,"pack":childItem.iconPack,"size":_vm.size}}):_vm._e(),_c('span',{class:childItem.headerTextClasses},[_vm._v(_vm._s(childItem.label))])],1)],1)}),_vm._t("end")],2),_c('section',{class:_vm.contentClasses,attrs:{"role":"tabpanel"}},[_vm._t("default")],2)])};
    var __vue_staticRenderFns__$C = [];

      /* style */
      const __vue_inject_styles__$H = undefined;
      /* scoped */
      const __vue_scope_id__$H = undefined;
      /* module identifier */
      const __vue_module_identifier__$H = undefined;
      /* functional template */
      const __vue_is_functional_template__$H = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$H = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$C, staticRenderFns: __vue_staticRenderFns__$C },
        __vue_inject_styles__$H,
        __vue_script__$H,
        __vue_scope_id__$H,
        __vue_is_functional_template__$H,
        __vue_module_identifier__$H,
        false,
        undefined,
        undefined,
        undefined
      );

    /**
     * @displayName Tab Item
     */

    var script$I = {
      name: 'OTabItem',
      mixins: [BaseComponentMixin, TabbedChildMixin('tab')],
      configField: 'tabs',
      props: {
        /** Item will be disabled */
        disabled: Boolean,

        /**
         * Tabs item tag name
         */
        tag: {
          type: String,
          default: () => {
            return getValueByPath(getOptions(), 'tabs.itemTag', 'button');
          }
        },
        itemClass: [String, Function, Array],
        itemHeaderClass: [String, Function, Array],
        itemHeaderActiveClass: [String, Function, Array],
        itemHeaderDisabledClass: [String, Function, Array],
        itemHeaderTypeClass: [String, Function, Array],
        itemHeaderIconClass: [String, Function, Array],
        itemHeaderTextClass: [String, Function, Array]
      },
      computed: {
        elementClasses() {
          return [this.computedClass('itemClass', 'o-tab-item__content')];
        },

        headerClasses() {
          return [this.computedClass('itemHeaderClass', 'o-tabs__nav-item'), {
            [this.computedClass('itemHeaderActiveClass', 'o-tabs__nav-item-{*}--active', this.parent.type)]: this.isActive
          }, {
            [this.computedClass('itemHeaderDisabledClass', 'o-tabs__nav-item-{*}--disabled', this.parent.type)]: this.disabled
          }, {
            [this.computedClass('itemHeaderTypeClass', 'o-tabs__nav-item-', this.parent.type)]: this.parent.type
          }];
        },

        headerIconClasses() {
          return [this.computedClass('itemHeaderIconClass', 'o-tabs__nav-item-icon')];
        },

        headerTextClasses() {
          return [this.computedClass('itemHeaderTextClass', 'o-tabs__nav-item-text')];
        }

      }
    };

    /* script */
    const __vue_script__$I = script$I;

    /* template */

      /* style */
      const __vue_inject_styles__$I = undefined;
      /* scoped */
      const __vue_scope_id__$I = undefined;
      /* module identifier */
      const __vue_module_identifier__$I = undefined;
      /* functional template */
      const __vue_is_functional_template__$I = undefined;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$I = /*#__PURE__*/normalizeComponent(
        {},
        __vue_inject_styles__$I,
        __vue_script__$I,
        __vue_scope_id__$I,
        __vue_is_functional_template__$I,
        __vue_module_identifier__$I,
        false,
        undefined,
        undefined,
        undefined
      );

    const Plugin$q = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$H);
        registerComponent(Vue, __vue_component__$I);
      }

    };
    use(Plugin$q);

    const Plugin$r = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$f);
      }

    };
    use(Plugin$r);

    const Plugin$s = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$w);
      }

    };
    use(Plugin$s);

    //
    /**
     * Upload one or more files
     * @displayName Upload
     * @example ./examples/Upload.md
     * @style _upload.scss
     */

    var script$J = {
      name: 'OUpload',
      mixins: [BaseComponentMixin, FormElementMixin],
      configField: 'upload',
      inheritAttrs: false,
      props: {
        /** @model */
        value: [Object, File, Array],

        /** Same as native, also push new item to v-model instead of replacing */
        multiple: Boolean,

        /** Same as native disabled */
        disabled: Boolean,

        /** Same as native accept */
        accept: String,

        /** Accepts drag & drop and change its style */
        dragDrop: Boolean,

        /**
        * Color of the control, optional
        * @values primary, info, success, warning, danger, and any other custom color
        */
        variant: {
          type: String
        },

        /** Replace last chosen files every time (like native file input element) */
        native: {
          type: Boolean,
          default: false
        },

        /** Upload will be expanded (full-width) */
        expanded: {
          type: Boolean,
          default: false
        },
        rootClass: [String, Function, Array],
        draggableClass: [String, Function, Array],
        variantClass: [String, Function, Array],
        expandedClass: [String, Function, Array],
        disabledClass: [String, Function, Array],
        hoveredClass: [String, Function, Array]
      },

      data() {
        return {
          newValue: this.value,
          dragDropFocus: false
        };
      },

      computed: {
        rootClasses() {
          return [this.computedClass('rootClass', 'o-upl'), {
            [this.computedClass('expandedClass', 'o-upl--expanded')]: this.expanded
          }, {
            [this.computedClass('disabledClass', 'o-upl--disabled')]: this.disabled
          }];
        },

        draggableClasses() {
          return [this.computedClass('draggableClass', 'o-upl__draggable'), {
            [this.computedClass('hoveredClass', 'o-upl__draggable--hovered')]: !this.variant && this.dragDropFocus
          }, {
            [this.computedClass('variantClass', 'o-upl__draggable--hovered-', this.variant)]: this.variant && this.dragDropFocus
          }];
        },

        $elementRef() {
          return 'input';
        }

      },
      watch: {
        /**
         *   When v-model is changed:
         *   1. Set internal value.
         *   2. Reset interna input file value
         *   3. If it's invalid, validate again.
         */
        value(value) {
          this.newValue = value;

          if (!value || Array.isArray(value) && value.length === 0) {
            this.$refs.input.value = null;
          }

          !this.isValid && !this.dragDrop && this.checkHtml5Validity();
        }

      },
      methods: {
        /**
        * Listen change event on input type 'file',
        * emit 'input' event and validate
        */
        onFileChange(event) {
          if (this.disabled) return;
          if (this.dragDrop) this.updateDragDropFocus(false);
          const value = event.target.files || event.dataTransfer.files;

          if (value.length === 0) {
            if (!this.newValue) return;
            if (this.native) this.newValue = null;
          } else if (!this.multiple) {
            // only one element in case drag drop mode and isn't multiple
            if (this.dragDrop && value.length !== 1) return;else {
              const file = value[0];
              if (this.checkType(file)) this.newValue = file;else if (this.newValue) {
                this.newValue = null;
                this.clearInput();
              } else {
                // Force input back to empty state and recheck validity
                this.clearInput();
                this.checkHtml5Validity();
                return;
              }
            }
          } else {
            // always new values if native or undefined local
            let newValues = false;

            if (this.native || !this.newValue) {
              this.newValue = [];
              newValues = true;
            }

            for (let i = 0; i < value.length; i++) {
              const file = value[i];

              if (this.checkType(file)) {
                this.newValue.push(file);
                newValues = true;
              }
            }

            if (!newValues) return;
          }

          this.$emit('input', this.newValue);
          !this.dragDrop && this.checkHtml5Validity();
        },

        /*
        * Reset file input value
        */
        clearInput() {
          this.$refs.input.value = null;
        },

        /**
        * Listen drag-drop to update internal variable
        */
        updateDragDropFocus(focus) {
          if (!this.disabled) {
            this.dragDropFocus = focus;
          }
        },

        /**
        * Check mime type of file
        */
        checkType(file) {
          if (!this.accept) return true;
          const types = this.accept.split(',');
          if (types.length === 0) return true;

          for (let i = 0; i < types.length; i++) {
            const type = types[i].trim();

            if (type) {
              if (type.substring(0, 1) === '.') {
                const extension = file.name.toLowerCase().slice(-type.length);

                if (extension === type.toLowerCase()) {
                  return true;
                }
              } else {
                // check mime type
                if (file.type.match(type)) return true;
              }
            }
          }

          return false;
        }

      }
    };

    /* script */
    const __vue_script__$J = script$J;

    /* template */
    var __vue_render__$D = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('label',{class:_vm.rootClasses},[(!_vm.dragDrop)?[_vm._t("default")]:_c('div',{class:_vm.draggableClasses,on:{"mouseenter":function($event){return _vm.updateDragDropFocus(true)},"mouseleave":function($event){return _vm.updateDragDropFocus(false)},"dragover":function($event){$event.preventDefault();return _vm.updateDragDropFocus(true)},"dragleave":function($event){$event.preventDefault();return _vm.updateDragDropFocus(false)},"dragenter":function($event){$event.preventDefault();return _vm.updateDragDropFocus(true)},"drop":function($event){$event.preventDefault();return _vm.onFileChange($event)}}},[_vm._t("default")],2),_c('input',_vm._b({ref:"input",attrs:{"type":"file","multiple":_vm.multiple,"accept":_vm.accept,"disabled":_vm.disabled},on:{"change":_vm.onFileChange}},'input',_vm.$attrs,false))],2)};
    var __vue_staticRenderFns__$D = [];

      /* style */
      const __vue_inject_styles__$J = undefined;
      /* scoped */
      const __vue_scope_id__$J = undefined;
      /* module identifier */
      const __vue_module_identifier__$J = undefined;
      /* functional template */
      const __vue_is_functional_template__$J = false;
      /* style inject */
      
      /* style inject SSR */
      
      /* style inject shadow dom */
      

      
      const __vue_component__$J = /*#__PURE__*/normalizeComponent(
        { render: __vue_render__$D, staticRenderFns: __vue_staticRenderFns__$D },
        __vue_inject_styles__$J,
        __vue_script__$J,
        __vue_scope_id__$J,
        __vue_is_functional_template__$J,
        __vue_module_identifier__$J,
        false,
        undefined,
        undefined,
        undefined
      );

    const Plugin$t = {
      install(Vue) {
        registerComponent(Vue, __vue_component__$J);
      }

    };
    use(Plugin$t);

    var plugins = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Autocomplete: Plugin$1,
        Button: Plugin$2,
        Carousel: Plugin$3,
        Checkbox: Plugin$4,
        Collapse: Plugin$5,
        Datepicker: Plugin$6,
        Datetimepicker: Plugin$7,
        Dropdown: Plugin$8,
        Field: Plugin$9,
        Icon: Plugin$a,
        Input: Plugin$b,
        Inputitems: Plugin$c,
        Loading: Plugin$d,
        Modal: Plugin$f,
        Menu: Plugin$g,
        Notification: Plugin$e,
        NotificationNotice: Plugin$e,
        Pagination: Plugin$h,
        Radio: Plugin$i,
        Select: Plugin$j,
        Skeleton: Plugin$k,
        Sidebar: Plugin$l,
        Slider: Plugin$m,
        Steps: Plugin$n,
        Switch: Plugin$o,
        Table: Plugin$p,
        Tabs: Plugin$q,
        Timepicker: Plugin$r,
        Tooltip: Plugin$s,
        Upload: Plugin$t
    });

    const Oruga = {
      install(Vue, options = {}) {
        setVueInstance(Vue); // Options

        const defaultConfig = getOptions();
        setOptions(merge(defaultConfig, options, true)); // Components

        for (const componentKey in plugins) {
          registerPlugin(Vue, plugins[componentKey]);
        } // Config component


        registerComponentProgrammatic(Vue, 'config', Programmatic);
      }

    };
    use(Oruga);

    exports.Autocomplete = Plugin$1;
    exports.BDatetimepicker = __vue_component__$g;
    exports.BTimepicker = __vue_component__$f;
    exports.Button = Plugin$2;
    exports.Carousel = Plugin$3;
    exports.Checkbox = Plugin$4;
    exports.Collapse = Plugin$5;
    exports.Config = Plugin;
    exports.ConfigProgrammatic = Programmatic;
    exports.Datepicker = Plugin$6;
    exports.Datetimepicker = Plugin$7;
    exports.Dropdown = Plugin$8;
    exports.Field = Plugin$9;
    exports.Icon = Plugin$a;
    exports.Input = Plugin$b;
    exports.Inputitems = Plugin$c;
    exports.Loading = Plugin$d;
    exports.LoadingProgrammatic = LoadingProgrammatic;
    exports.Menu = Plugin$g;
    exports.Modal = Plugin$f;
    exports.ModalProgrammatic = ModalProgrammatic;
    exports.Notification = Plugin$e;
    exports.NotificationNotice = Plugin$e;
    exports.NotificationProgrammatic = NotificationProgrammatic;
    exports.OAutocomplete = __vue_component__$2;
    exports.OButton = __vue_component__$3;
    exports.OCarousel = __vue_component__$4;
    exports.OCarouselItem = __vue_component__$5;
    exports.OCheckbox = __vue_component__$6;
    exports.OCollapse = __vue_component__$7;
    exports.ODatepicker = __vue_component__$e;
    exports.ODropdown = __vue_component__$8;
    exports.ODropdownItem = __vue_component__$9;
    exports.OField = __vue_component__$i;
    exports.OIcon = __vue_component__;
    exports.OInput = __vue_component__$1;
    exports.OInputitems = __vue_component__$j;
    exports.OLoading = __vue_component__$k;
    exports.OMenu = __vue_component__$o;
    exports.OMenuItem = __vue_component__$q;
    exports.OMenuList = __vue_component__$p;
    exports.OModal = __vue_component__$n;
    exports.ONotification = __vue_component__$l;
    exports.OPagination = __vue_component__$s;
    exports.OPaginationButton = __vue_component__$r;
    exports.ORadio = __vue_component__$t;
    exports.OSelect = __vue_component__$a;
    exports.OSidebar = __vue_component__$v;
    exports.OSkeleton = __vue_component__$u;
    exports.OSlider = __vue_component__$z;
    exports.OSliderTick = __vue_component__$y;
    exports.OStepItem = __vue_component__$B;
    exports.OSteps = __vue_component__$A;
    exports.OSwitch = __vue_component__$C;
    exports.OTabItem = __vue_component__$I;
    exports.OTable = __vue_component__$G;
    exports.OTableColumn = __vue_component__$E;
    exports.OTabs = __vue_component__$H;
    exports.OTooltip = __vue_component__$w;
    exports.OUpload = __vue_component__$J;
    exports.Pagination = Plugin$h;
    exports.Radio = Plugin$i;
    exports.Select = Plugin$j;
    exports.Sidebar = Plugin$l;
    exports.Skeleton = Plugin$k;
    exports.Slider = Plugin$m;
    exports.Steps = Plugin$n;
    exports.Switch = Plugin$o;
    exports.Table = Plugin$p;
    exports.Tabs = Plugin$q;
    exports.Timepicker = Plugin$r;
    exports.Tooltip = Plugin$s;
    exports.Upload = Plugin$t;
    exports.default = Oruga;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
