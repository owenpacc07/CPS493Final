import { getValueByPath, isMobile, matchWithGroups } from './helpers.mjs';
import { getOptions } from './config.mjs';
import { B as BaseComponentMixin, n as normalizeComponent, b as registerComponent, u as use } from './plugins-9401a4a3.mjs';
import './Icon-33c4eb50.mjs';
import { F as FormElementMixin } from './FormElementMixin-32cbff10.mjs';
import './Input-2f8444b9.mjs';
import './MatchMediaMixin-87673064.mjs';
import './trapFocus-21978f6e.mjs';
import './DropdownItem-954d5851.mjs';
import './Select-73c43b71.mjs';
import { _ as __vue_component__$1 } from './Datepicker-a543e13c.mjs';
import { _ as __vue_component__$2 } from './Timepicker-5633968d.mjs';

//
const AM = 'AM';
const PM = 'PM';
/**
 * An input with a simple dropdown/modal for selecting a date and time, uses native datetimepicker for mobile
 * @displayName Datetimepicker
 * @example ./examples/Datetimepicker.md
 */

var script = {
  name: 'ODatetimepicker',
  components: {
    [__vue_component__$1.name]: __vue_component__$1,
    [__vue_component__$2.name]: __vue_component__$2
  },
  configField: 'datetimepicker',
  mixins: [FormElementMixin, BaseComponentMixin],
  inheritAttrs: false,
  props: {
    /* @model */
    value: {
      type: Date
    },

    /* Enable input/typing. Note that you might have to set a custom datetime parser */
    editable: {
      type: Boolean,
      default: false
    },

    /**
     * Size of button, optional
     * @values small, medium, large
     */
    size: String,
    placeholder: String,
    disabled: Boolean,

    /**
     * 	Icon name to be added on the right side
     */
    iconRight: String,

    /**
     * Make the icon right clickable
     */
    iconRightClickable: Boolean,

    /* Datimepicker is shown inline, input is removed */
    inline: Boolean,

    /* Open datetimepicker on input focus */
    openOnFocus: Boolean,

    /**
     * Optional, position of the datepicker relative to the input
     * @values top-right, top-left, bottom-left
     */
    position: String,

    /* Enable native datetimepicker on mobile */
    mobileNative: {
      type: Boolean,
      default: true
    },

    /* Earliest datetime available for selection */
    minDatetime: Date,

    /* Latest datetime available for selection */
    maxDatetime: Date,

    /* Function to format datetime (Date type) to a string for displaying in the input */
    datetimeFormatter: {
      type: Function
    },

    /* Function to parse string to a datetime (Date type) for setting the component's datetime from the input */
    datetimeParser: {
      type: Function
    },

    /* Function used internally to create a new Date instance */
    datetimeCreator: {
      type: Function,
      default: date => {
        const datetimeCreator = getValueByPath(getOptions(), 'datetimepicker.datetimeCreator', undefined);

        if (typeof datetimeCreator === 'function') {
          return datetimeCreator(date);
        } else {
          return date;
        }
      }
    },

    /**
     * Properties and classes to bind to the internal DatePicker
     */
    datepicker: Object,

    /**
     * Properties and classes to bind to the internal TimePicker
     */
    timepicker: Object,

    /* Accept a string with a BCP 47 language tag, or an array of such strings. See Unicode BCP 47 locale identifier */
    locale: {
      type: [String, Array],
      default: () => {
        return getValueByPath(getOptions(), 'locale');
      }
    },

    /* Append datetimepicker calendar to body */
    appendToBody: Boolean,
    datepickerWrapperClass: [String, Function, Array],
    timepickerWrapperClass: [String, Function, Array]
  },

  data() {
    return {
      newValue: this.value
    };
  },

  computed: {
    datepickerWrapperClasses() {
      return [this.computedClass('datepickerWrapperClass', 'o-dtpck__date')];
    },

    timepickerWrapperClasses() {
      return [this.computedClass('timepickerWrapperClass', 'o-dtpck__time')];
    },

    computedValue: {
      get() {
        return this.newValue;
      },

      set(value) {
        if (value) {
          let val = new Date(value.getTime());

          if (this.newValue) {
            // restore time part
            if ((value.getDate() !== this.newValue.getDate() || value.getMonth() !== this.newValue.getMonth() || value.getFullYear() !== this.newValue.getFullYear()) && value.getHours() === 0 && value.getMinutes() === 0 && value.getSeconds() === 0) {
              val.setHours(this.newValue.getHours(), this.newValue.getMinutes(), this.newValue.getSeconds(), 0);
            }
          } else {
            val = this.datetimeCreator(value);
          } // check min and max range


          if (this.minDatetime && val < this.minDatetime) {
            val = this.minDatetime;
          } else if (this.maxDatetime && val > this.maxDatetime) {
            val = this.maxDatetime;
          }

          this.newValue = new Date(val.getTime());
        } else {
          this.newValue = value;
        }

        this.$emit('input', this.newValue);
      }

    },

    localeOptions() {
      return new Intl.DateTimeFormat(this.locale, {
        year: 'numeric',
        month: 'numeric',
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        second: this.enableSeconds() ? 'numeric' : undefined
      }).resolvedOptions();
    },

    dtf() {
      return new Intl.DateTimeFormat(this.locale, {
        year: this.localeOptions.year || 'numeric',
        month: this.localeOptions.month || 'numeric',
        day: this.localeOptions.day || 'numeric',
        hour: this.localeOptions.hour || 'numeric',
        minute: this.localeOptions.minute || 'numeric',
        second: this.enableSeconds() ? this.localeOptions.second || 'numeric' : undefined,
        hourCycle: !this.isHourFormat24() ? 'h12' : 'h23'
      });
    },

    isMobileNative() {
      return this.mobileNative;
    },

    isMobile() {
      return this.isMobileNative && isMobile.any();
    },

    minDate() {
      if (!this.minDatetime) {
        return this.datepicker ? this.datepicker.minDate : null;
      }

      return new Date(this.minDatetime.getFullYear(), this.minDatetime.getMonth(), this.minDatetime.getDate(), 0, 0, 0, 0);
    },

    maxDate() {
      if (!this.maxDatetime) {
        return this.datepicker ? this.datepicker.maxDate : null;
      }

      return new Date(this.maxDatetime.getFullYear(), this.maxDatetime.getMonth(), this.maxDatetime.getDate(), 0, 0, 0, 0);
    },

    minTime() {
      if (!this.minDatetime || this.newValue === null || typeof this.newValue === 'undefined' || this.newValue.getFullYear() != this.minDatetime.getFullYear() || this.newValue.getMonth() != this.minDatetime.getMonth() || this.newValue.getDate() != this.minDatetime.getDate()) {
        return this.timepicker ? this.timepicker.minTime : null;
      }

      return this.minDatetime;
    },

    maxTime() {
      if (!this.maxDatetime || this.newValue === null || typeof this.newValue === 'undefined' || this.newValue.getFullYear() != this.maxDatetime.getFullYear() || this.newValue.getMonth() != this.maxDatetime.getMonth() || this.newValue.getDate() != this.maxDatetime.getDate()) {
        return this.timepicker ? this.timepicker.maxTime : null;
      }

      return this.maxDatetime;
    },

    datepickerSize() {
      return this.datepicker && this.datepicker.size ? this.datepicker.size : this.size;
    },

    timepickerSize() {
      return this.timepicker && this.timepicker.size ? this.timepicker.size : this.size;
    },

    timepickerDisabled() {
      return this.timepicker && this.timepicker.disabled ? this.timepicker.disabled : this.disabled;
    }

  },
  watch: {
    value() {
      this.newValue = this.value;
    }

  },
  methods: {
    enableSeconds() {
      if (this.$refs.timepicker) {
        return this.$refs.timepicker.enableSeconds;
      }

      return false;
    },

    isHourFormat24() {
      if (this.$refs.timepicker) {
        return this.$refs.timepicker.isHourFormat24;
      }

      return !this.localeOptions.hour12;
    },

    defaultDatetimeParser(date) {
      const datetimeParser = getValueByPath(getOptions(), 'datetimepicker.datetimeParser', undefined);

      if (typeof this.datetimeParser === 'function') {
        return this.datetimeParser(date);
      } else if (typeof datetimeParser === 'function') {
        return datetimeParser(date);
      } else {
        if (this.dtf.formatToParts && typeof this.dtf.formatToParts === 'function') {
          let dayPeriods = [AM, PM, AM.toLowerCase(), PM.toLowerCase()];

          if (this.$refs.timepicker) {
            dayPeriods.push(this.$refs.timepicker.amString);
            dayPeriods.push(this.$refs.timepicker.pmString);
          }

          const parts = this.dtf.formatToParts(new Date());
          const formatRegex = parts.map((part, idx) => {
            if (part.type === 'literal') {
              if (idx + 1 < parts.length && parts[idx + 1].type === 'hour') {
                return `[^\\d]+`;
              }

              return part.value.replace(/ /g, '\\s?');
            } else if (part.type === 'dayPeriod') {
              return `((?!=<${part.type}>)(${dayPeriods.join('|')})?)`;
            }

            return `((?!=<${part.type}>)\\d+)`;
          }).join('');
          const datetimeGroups = matchWithGroups(formatRegex, date); // We do a simple validation for the group.
          // If it is not valid, it will fallback to Date.parse below

          if (datetimeGroups.year && datetimeGroups.year.length === 4 && datetimeGroups.month && datetimeGroups.month <= 12 && datetimeGroups.day && datetimeGroups.day <= 31 && datetimeGroups.hour && datetimeGroups.hour >= 0 && datetimeGroups.hour < 24 && datetimeGroups.minute && datetimeGroups.minute >= 0 && datetimeGroups.minute <= 59) {
            const d = new Date(datetimeGroups.year, datetimeGroups.month - 1, datetimeGroups.day, datetimeGroups.hour, datetimeGroups.minute, datetimeGroups.second || 0);
            return d;
          }
        }

        return new Date(Date.parse(date));
      }
    },

    defaultDatetimeFormatter(date) {
      const datetimeFormatter = getValueByPath(getOptions(), 'datetimepicker.datetimeFormatter', undefined);

      if (typeof this.datetimeFormatter === 'function') {
        return this.datetimeFormatter(date);
      } else if (typeof datetimeFormatter === 'function') {
        return datetimeFormatter(date);
      } else {
        return this.dtf.format(date);
      }
    },

    /*
    * Parse date from string
    */
    onChangeNativePicker(event) {
      const date = event.target.value;
      const s = date ? date.split(/\D/) : [];

      if (s.length >= 5) {
        const year = parseInt(s[0], 10);
        const month = parseInt(s[1], 10) - 1;
        const day = parseInt(s[2], 10);
        const hours = parseInt(s[3], 10);
        const minutes = parseInt(s[4], 10); // Seconds are omitted intentionally; they are unsupported by input
        // type=datetime-local and cause the control to fail native validation

        this.computedValue = new Date(year, month, day, hours, minutes);
      } else {
        this.computedValue = null;
      }
    },

    formatNative(value) {
      const date = new Date(value);

      if (value && !isNaN(date)) {
        const year = date.getFullYear();
        const month = date.getMonth() + 1;
        const day = date.getDate();
        const hours = date.getHours();
        const minutes = date.getMinutes();
        const seconds = date.getSeconds();
        return year + '-' + ((month < 10 ? '0' : '') + month) + '-' + ((day < 10 ? '0' : '') + day) + 'T' + ((hours < 10 ? '0' : '') + hours) + ':' + ((minutes < 10 ? '0' : '') + minutes) + ':' + ((seconds < 10 ? '0' : '') + seconds);
      }

      return '';
    },

    toggle() {
      this.$refs.datepicker.toggle();
    }

  },

  mounted() {
    if (!this.isMobile || this.inline) {
      // $refs attached, it's time to refresh datepicker (input)
      if (this.newValue) {
        this.$refs.datepicker.$forceUpdate();
      }
    }
  }

};

/* script */
const __vue_script__ = script;

/* template */
var __vue_render__ = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (!_vm.isMobile || _vm.inline)?_c('o-datepicker',_vm._b({ref:"datepicker",class:_vm.datepickerWrapperClasses,attrs:{"rounded":_vm.rounded,"open-on-focus":_vm.openOnFocus,"position":_vm.position,"inline":_vm.inline,"editable":_vm.editable,"expanded":_vm.expanded,"close-on-click":false,"date-formatter":_vm.defaultDatetimeFormatter,"date-parser":_vm.defaultDatetimeParser,"min-date":_vm.minDate,"max-date":_vm.maxDate,"icon":_vm.icon,"icon-right":_vm.iconRight,"icon-right-clickable":_vm.iconRightClickable,"icon-pack":_vm.iconPack,"size":_vm.datepickerSize,"placeholder":_vm.placeholder,"range":false,"disabled":_vm.disabled,"mobile-native":_vm.isMobileNative,"locale":_vm.locale,"append-to-body":_vm.appendToBody},on:{"focus":_vm.onFocus,"blur":_vm.onBlur,"active-change":function($event){return _vm.$emit('active-change', $event)},"icon-right-click":function($event){return _vm.$emit('icon-right-click')},"change-month":function($event){return _vm.$emit('change-month', $event)},"change-year":function($event){return _vm.$emit('change-year', $event)}},scopedSlots:_vm._u([{key:"footer",fn:function(){return [_c('div',{class:_vm.timepickerWrapperClasses},[_c('o-timepicker',_vm._b({ref:"timepicker",attrs:{"inline":"","editable":_vm.editable,"min-time":_vm.minTime,"max-time":_vm.maxTime,"size":_vm.timepickerSize,"disabled":_vm.timepickerDisabled,"mobile-native":_vm.isMobileNative,"locale":_vm.locale},model:{value:(_vm.computedValue),callback:function ($$v) {_vm.computedValue=$$v;},expression:"computedValue"}},'o-timepicker',_vm.timepicker,false))],1),(_vm.$slots.footer !== undefined)?[_vm._t("footer")]:_vm._e()]},proxy:true}],null,true),model:{value:(_vm.computedValue),callback:function ($$v) {_vm.computedValue=$$v;},expression:"computedValue"}},'o-datepicker',_vm.datepicker,false)):_c('o-input',_vm._b({ref:"input",attrs:{"type":"datetime-local","autocomplete":"off","value":_vm.formatNative(_vm.computedValue),"placeholder":_vm.placeholder,"size":_vm.datepickerSize,"icon":_vm.icon,"icon-pack":_vm.iconPack,"rounded":_vm.rounded,"max":_vm.formatNative(_vm.maxDate),"min":_vm.formatNative(_vm.minDate),"disabled":_vm.disabled,"readonly":false,"use-html5-validation":_vm.useHtml5Validation},on:{"focus":_vm.onFocus,"blur":_vm.onBlur,"invalid":_vm.onInvalid},nativeOn:{"change":function($event){return _vm.onChangeNativePicker($event)}}},'o-input',_vm.$attrs,false))};
var __vue_staticRenderFns__ = [];

  /* style */
  const __vue_inject_styles__ = undefined;
  /* scoped */
  const __vue_scope_id__ = undefined;
  /* module identifier */
  const __vue_module_identifier__ = undefined;
  /* functional template */
  const __vue_is_functional_template__ = false;
  /* style inject */
  
  /* style inject SSR */
  
  /* style inject shadow dom */
  

  
  const __vue_component__ = /*#__PURE__*/normalizeComponent(
    { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
    __vue_inject_styles__,
    __vue_script__,
    __vue_scope_id__,
    __vue_is_functional_template__,
    __vue_module_identifier__,
    false,
    undefined,
    undefined,
    undefined
  );

const Plugin = {
  install(Vue) {
    registerComponent(Vue, __vue_component__);
  }

};
use(Plugin);

export default Plugin;
export { __vue_component__ as BDatetimepicker };
