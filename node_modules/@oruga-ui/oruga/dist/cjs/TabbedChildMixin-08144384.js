'use strict';

var helpers = require('./helpers.js');
var Icon = require('./Icon-2540a413.js');
var InjectedChildMixin = require('./InjectedChildMixin-f4307b88.js');
var SlotComponent = require('./SlotComponent-0a757062.js');

var TabbedMixin = (cmp => ({
  mixins: [InjectedChildMixin.ProviderParentMixin(cmp, InjectedChildMixin.Sorted)],
  components: {
    [Icon.__vue_component__.name]: Icon.__vue_component__,
    [SlotComponent.SlotComponent.name]: SlotComponent.SlotComponent
  },
  props: {
    /** @model */
    value: [String, Number],

    /**
    * Color of the control, optional
    * @values primary, info, success, warning, danger, and any other custom color
    */
    variant: [String, Object],

    /**
     * Tab size, optional
     * @values small, medium, large
     */
    size: String,
    animated: {
      type: Boolean,
      default: true
    },

    /** Show tab in vertical layout */
    vertical: {
      type: Boolean,
      default: false
    },

    /**
     * Position of the tab, optional
     * @values centered, right
     */
    position: String,

    /** Destroy tab on hide */
    destroyOnHide: {
      type: Boolean,
      default: false
    }
  },

  data() {
    return {
      activeId: this.value,
      contentHeight: 0,
      isTransitioning: false
    };
  },

  computed: {
    activeItem() {
      return this.activeId !== undefined && this.activeId !== null ? this.childItems.filter(i => i.newValue === this.activeId)[0] : this.items[0];
    },

    activeIndex() {
      return this.childItems.findIndex(item => item.newValue === this.activeId);
    },

    items() {
      return this.sortedItems;
    }

  },
  watch: {
    /**
     * When v-model is changed set the new active tab.
     */
    value(value) {
      if (this.activeId !== value) {
        this.performAction(value);
      }
    }

  },
  methods: {
    /**
    * Child click listener, emit input event and change active child.
    */
    childClick(child) {
      if (this.activeId !== child.newValue) {
        this.performAction(child.newValue);
        this.$emit('input', this.activeId);
      }
    },

    /**
     * Select the first 'viable' child, starting at startingIndex and in the direction specified
     * by the boolean parameter forward. In other words, first try to select the child at index 
     * startingIndex, and if it is not visible or it is disabled, then go to the index in the
     * specified direction until either returning to startIndex or finding a viable child item.
    */
    clickFirstViableChild(startingIndex, forward) {
      let direction = forward ? 1 : -1;
      let newIndex = startingIndex;

      for (; newIndex !== this.activeIndex; newIndex = helpers.mod(newIndex + direction, this.childItems.length)) {
        // Break if the item at this index is viable (not disabled and is visible)
        if (this.childItems[newIndex].visible && !this.childItems[newIndex].disabled) {
          break;
        }
      }

      this.childClick(this.childItems[newIndex]);
    },

    /**
     * Go to the next item or wrap around
    */
    next() {
      let newIndex = helpers.mod(this.activeIndex + 1, this.childItems.length);
      this.clickFirstViableChild(newIndex, true);
    },

    /**
     * Go to the previous item or wrap around
    */
    prev() {
      let newIndex = helpers.mod(this.activeIndex - 1, this.childItems.length);
      this.clickFirstViableChild(newIndex, false);
    },

    /**
     * Go to the first viable item
    */
    homePressed() {
      if (this.childItems.length < 1) {
        return;
      }

      this.clickFirstViableChild(0, true);
    },

    /**
     * Go to the last viable item
    */
    endPressed() {
      if (this.childItems.length < 1) {
        return;
      }

      this.clickFirstViableChild(this.childItems.length - 1, false);
    },

    /**
    * Activate next child and deactivate prev child
    */
    performAction(newId) {
      const oldValue = this.activeId;
      const oldTab = oldValue !== undefined && oldValue !== null ? this.childItems.filter(i => i.newValue === oldValue)[0] : this.items[0];
      this.activeId = newId;

      if (oldTab && this.activeItem) {
        oldTab.deactivate(this.activeItem.index);
        this.activeItem.activate(oldTab.index);
      }
    }

  }
}));

var TabbedChildMixin = (parentCmp => ({
  mixins: [InjectedChildMixin.InjectedChildMixin(parentCmp, InjectedChildMixin.Sorted$1)],
  props: {
    /**
     * Item value (it will be used as v-model of wrapper component)
     */
    value: [String, Number],

    /**
     * Item label
     */
    label: String,

    /**
     * Icon on the left
     */
    icon: String,

    /**
     * Icon pack
     */
    iconPack: String,

    /**
     * Show/hide item
     */
    visible: {
      type: Boolean,
      default: true
    },

    /**
     * Header class of the item
     */
    headerClass: [String, Array, Object]
  },

  data() {
    return {
      transitionName: undefined,
      newValue: this.value
    };
  },

  computed: {
    isActive() {
      return this.parent.activeItem === this;
    },

    elementClasses() {
      return [];
    }

  },
  methods: {
    /**
     * Activate element, alter animation name based on the index.
     */
    activate(oldIndex) {
      this.transitionName = this.index < oldIndex ? this.parent.vertical ? 'slide-down' : 'slide-next' : this.parent.vertical ? 'slide-up' : 'slide-prev';
      this.$emit("activate");
    },

    /**
     * Deactivate element, alter animation name based on the index.
     */
    deactivate(newIndex) {
      this.transitionName = newIndex < this.index ? this.parent.vertical ? 'slide-down' : 'slide-next' : this.parent.vertical ? 'slide-up' : 'slide-prev';
    }

  },

  render(h) {
    // if destroy apply v-if
    if (this.parent.destroyOnHide) {
      if (!this.isActive || !this.visible) return;
    }

    const vnode = h('div', {
      directives: [{
        name: 'show',
        value: this.isActive && this.visible
      }],
      attrs: {
        'class': this.elementClasses,
        'id': `${parentCmp}-${this.newValue}`,
        'tabindex': this.isActive ? 0 : -1
      }
    }, this.$slots.default); // check animated prop

    if (this.parent.animated) {
      return h('transition', {
        props: {
          'name': this.transitionName
        },
        on: {
          'before-enter': () => {
            this.parent.isTransitioning = true;
          },
          'after-enter': () => {
            this.parent.isTransitioning = false;
          }
        }
      }, [vnode]);
    }

    return vnode;
  }

}));

exports.TabbedChildMixin = TabbedChildMixin;
exports.TabbedMixin = TabbedMixin;
