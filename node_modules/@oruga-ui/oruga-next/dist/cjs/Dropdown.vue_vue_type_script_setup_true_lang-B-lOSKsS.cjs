"use strict";
/*! Oruga v0.10.5 | MIT License | github.com/oruga-ui/oruga */
const vue = require("vue");
const config = require("./config-DQse3iF9.cjs");
const helpers = require("./helpers.cjs");
const defineClasses = require("./defineClasses-HOBoThd5.cjs");
const useParentProvider = require("./useParentProvider-TVrHYLvm.cjs");
const PositionWrapper_vue_vue_type_script_setup_true_lang = require("./PositionWrapper.vue_vue_type_script_setup_true_lang-Dv8RXs-d.cjs");
const unrefElement = require("./unrefElement-BtPFHjfc.cjs");
const useEventListener = require("./useEventListener-Cew5Aed0.cjs");
const useMatchMedia = require("./useMatchMedia-CERtemgT.cjs");
const useClickOutside = require("./useClickOutside-Dwq_QtCr.cjs");
const useOptions = require("./useOptions-011ZwErH.cjs");
const usePreventScrolling = require("./usePreventScrolling-E0W8EUbK.cjs");
const useSequentialId = require("./useSequentialId-BSuTima6.cjs");
const fieldInjection = require("./fieldInjection-CvE2Bm-L.cjs");
const _sfc_main$1 = /* @__PURE__ */ vue.defineComponent({
  ...{
    isOruga: true,
    name: "ODropdownItem",
    configField: "dropdown"
  },
  __name: "DropdownItem",
  props: {
    override: { type: Boolean, default: void 0 },
    value: { default: void 0 },
    label: { default: void 0 },
    disabled: { type: Boolean, default: false },
    clickable: { type: Boolean, default: true },
    hidden: { type: Boolean, default: false },
    tag: { default: () => config.getDefault("dropdown.itemTag", "div") },
    itemClass: {},
    itemSelectedClass: {},
    itemFocusedClass: {},
    itemClickableClass: {},
    itemDisabledClass: {}
  },
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const itemValue = props.value ?? vue.useId();
    const rootRef = vue.useTemplateRef("rootElement");
    const providedData = vue.computed(() => ({
      ...props,
      $el: rootRef.value,
      value: itemValue,
      selectItem
    }));
    const { parent, item } = useParentProvider.useProviderChild({ data: providedData });
    const isClickable = vue.computed(
      () => !parent.value.disabled && !props.disabled && props.clickable
    );
    const isSelected = vue.computed(() => {
      if (!helpers.isDefined(parent.value.selected)) return false;
      if (parent.value.multiple && Array.isArray(parent.value.selected))
        return parent.value.selected.some(
          (selected) => helpers.isEqual(itemValue, selected)
        );
      return helpers.isEqual(itemValue, parent.value.selected);
    });
    const isFocused = vue.computed(
      () => item.value.identifier === parent.value.focsuedIdentifier
    );
    function selectItem(event) {
      if (!isClickable.value) return;
      parent.value.selectItem(item.value, event);
      emits("click", itemValue, event);
    }
    function focusItem() {
      parent.value.focusItem(item.value);
    }
    const rootClasses = defineClasses.defineClasses(
      ["itemClass", "o-dropdown__item"],
      [
        "itemDisabledClass",
        "o-dropdown__item--disabled",
        null,
        vue.computed(() => parent.value.disabled || props.disabled)
      ],
      ["itemSelectedClass", "o-dropdown__item--active", null, isSelected],
      ["itemClickableClass", "o-dropdown__item--clickable", null, isClickable],
      ["itemFocusedClass", "o-dropdown__item--focused", null, isFocused]
    );
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.tag), {
        id: `${vue.unref(parent).menuId}-${vue.unref(item).identifier}`,
        ref: "rootElement",
        "data-oruga": "dropdown-item",
        "data-id": `dropdown-${vue.unref(item).identifier}`,
        class: vue.normalizeClass(vue.unref(rootClasses)),
        role: vue.unref(parent).selectable ? "option" : "menuitem",
        "aria-selected": vue.unref(parent).selectable ? isSelected.value : void 0,
        "aria-disabled": _ctx.disabled,
        onClick: selectItem,
        onMouseenter: focusItem,
        onKeydown: [
          vue.withKeys(selectItem, ["enter"]),
          vue.withKeys(selectItem, ["space"])
        ]
      }, {
        default: vue.withCtx(() => [
          vue.renderSlot(_ctx.$slots, "default", {}, () => [
            vue.createTextVNode(vue.toDisplayString(_ctx.label), 1)
          ])
        ]),
        _: 3
      }, 40, ["id", "data-id", "class", "role", "aria-selected", "aria-disabled"]);
    };
  }
});
function maintainScrollVisibility(activeElement, scrollParent) {
  const parent = unrefElement.unrefElement(scrollParent);
  const element = unrefElement.unrefElement(activeElement);
  const { offsetHeight, offsetTop } = element;
  const { offsetHeight: parentOffsetHeight, scrollTop } = parent;
  const isAbove = offsetTop < scrollTop;
  const isBelow = offsetTop + offsetHeight > scrollTop + parentOffsetHeight;
  if (isAbove) {
    parent.scrollTo(0, offsetTop);
  } else if (isBelow) {
    parent.scrollTo(0, offsetTop - parentOffsetHeight + offsetHeight);
  }
}
function useInfiniteScroll(elementRef, onEnd, onStart) {
  if (config.isClient) useEventListener.useEventListener(elementRef, "scroll", checkScroll);
  function checkScroll() {
    const element = unrefElement.unrefElement(elementRef);
    if (!element) return;
    const trashhold = element.offsetTop;
    if (element.clientHeight !== element.scrollHeight) {
      if (Math.ceil(
        element.scrollTop + element.clientHeight + trashhold
      ) >= element.scrollHeight) {
        onEnd();
      } else if (element.scrollTop <= trashhold) {
        onStart();
      }
    }
  }
  return { checkScroll };
}
const _hoisted_1 = { key: 1 };
const _sfc_main = /* @__PURE__ */ vue.defineComponent({
  ...{
    isOruga: true,
    name: "ODropdown",
    configField: "dropdown"
  },
  __name: "Dropdown",
  props: /* @__PURE__ */ vue.mergeModels({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    multiple: {},
    options: { default: void 0 },
    active: { type: Boolean, default: false },
    label: { default: void 0 },
    disabled: { type: Boolean, default: false },
    inline: { type: Boolean, default: false },
    selectable: { type: Boolean, default: false },
    scrollable: { type: Boolean, default: false },
    checkScroll: { type: Boolean, default: () => config.getDefault("dropdown.checkScroll", false) },
    maxHeight: { default: () => config.getDefault("dropdown.maxHeight", 200) },
    position: { default: () => config.getDefault("dropdown.position", "bottom-left") },
    animation: { default: () => config.getDefault("dropdown.animation", "fade") },
    expanded: { type: Boolean, default: false },
    menuId: { default: () => vue.useId() },
    menuTag: { default: () => config.getDefault("dropdown.menuTag", "div") },
    triggerTag: { default: () => config.getDefault("dropdown.triggerTag", "div") },
    triggers: { default: () => config.getDefault("dropdown.triggers", ["click"]) },
    delay: { default: void 0 },
    keepOpen: { type: Boolean, default: () => config.getDefault("dropdown.keepOpen", false) },
    keepFirst: { type: Boolean, default: () => config.getDefault("dropdown.keepFirst", false) },
    closeOnOutside: { type: Boolean, default: () => config.getDefault("dropdown.closeOnOutside", true) },
    closeOnScroll: { type: Boolean, default: () => config.getDefault("dropdown.closeOnScroll", false) },
    selectOnFocus: { type: Boolean, default: () => config.getDefault("dropdown.selectOnFocus", false) },
    selectOnClose: { type: Boolean, default: () => config.getDefault("dropdown.selectOnClose", false) },
    mobileModal: { type: Boolean, default: () => config.getDefault("dropdown.mobileModal", true) },
    desktopModal: { type: Boolean, default: () => config.getDefault("dropdown.desktopModal", false) },
    mobileBreakpoint: { default: () => config.getDefault("dropdown.mobileBreakpoint") },
    teleport: { type: [Boolean, String, Object], default: () => config.getDefault("dropdown.teleport", false) },
    clipScroll: { type: Boolean, default: () => config.getDefault("dropdown.clipScroll", false) },
    labelledby: {},
    ariaLabel: {},
    rootClass: {},
    mobileClass: {},
    modalClass: {},
    teleportClass: {},
    inlineClass: {},
    disabledClass: {},
    expandedClass: {},
    positionClass: {},
    activeClass: {},
    hoverableClass: {},
    triggerClass: {},
    menuClass: {},
    menuPositionClass: {},
    menuActiveClass: {},
    overlayClass: {},
    scrollClipClass: {},
    scrollKeepClass: {}
  }, {
    "modelValue": { default: void 0 },
    "modelModifiers": {},
    "active": { type: Boolean, ...{ default: false } },
    "activeModifiers": {}
  }),
  emits: /* @__PURE__ */ vue.mergeModels(["update:model-value", "update:active", "select", "change", "open", "close", "scroll-start", "scroll-end"], ["update:modelValue", "update:active"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    var _a;
    const props = __props;
    const emits = __emit;
    const triggerRef = vue.ref();
    const menuRef = vue.ref();
    const provideData = vue.computed(() => {
      var _a2;
      return {
        disabled: props.disabled,
        multiple: helpers.isTrueish(props.multiple),
        selectable: props.selectable,
        menuId: props.menuId,
        selected: vmodel.value,
        focsuedIdentifier: (_a2 = focusedItem.value) == null ? void 0 : _a2.identifier,
        selectItem,
        focusItem
      };
    });
    const { childItems } = useParentProvider.useProviderParent({
      rootRef: menuRef,
      data: provideData
    });
    const { nextSequence } = useSequentialId.useSequentialId();
    const groupedOptions = vue.computed(() => {
      const normalizedOptions = useOptions.normalizeOptions(props.options, nextSequence);
      const groupedOptions2 = useOptions.toOptionsGroup(normalizedOptions, nextSequence());
      return groupedOptions2;
    });
    const isNotEmpty = vue.computed(() => childItems.value.some(isItemViable));
    const { parentField } = fieldInjection.injectField();
    const vmodel = vue.useModel(__props, "modelValue");
    const isActive = vue.useModel(__props, "active");
    const labelId = props.labelledby ?? ((_a = parentField.value) == null ? void 0 : _a.labelId);
    const autoPosition = vue.ref(props.position);
    vue.watch(
      () => props.position,
      (v) => autoPosition.value = v
    );
    const { isMobile } = useMatchMedia.useMatchMedia(props.mobileBreakpoint);
    const isMobileNative = config.isClient && helpers.isMobileAgent.any();
    const isModal = vue.computed(
      () => !props.inline && (isMobile.value && props.mobileModal || !isMobile.value && props.desktopModal)
    );
    const menuStyle = vue.computed(() => ({
      maxHeight: props.scrollable ? helpers.toCssDimension(props.maxHeight) : null,
      overflow: props.scrollable ? "auto" : null
    }));
    const hoverable = vue.computed(() => props.triggers.includes("hover"));
    const toggleScroll = usePreventScrolling.usePreventScrolling(props.clipScroll);
    if (config.isClient && props.scrollable && props.checkScroll)
      useInfiniteScroll(
        menuRef,
        () => emits("scroll-end"),
        () => emits("scroll-start")
      );
    if (config.isClient && props.closeOnOutside)
      useClickOutside.useClickOutside([menuRef, triggerRef], onClickedOutside, {
        trigger: isActive,
        passive: true
      });
    if (config.isClient && props.closeOnScroll)
      useEventListener.useEventListener(window, "scroll", onPageScroll, { passive: true });
    vue.watch(
      isActive,
      (value) => {
        if (value) {
          if (!props.inline && props.keepFirst && !focusedItem.value)
            moveFocus(1);
        }
        if (isModal.value) toggleScroll(value);
      },
      { flush: "post" }
    );
    vue.watch(
      childItems,
      () => {
        if (isActive.value && !props.inline && props.keepFirst) {
          focusedItem.value = void 0;
          moveFocus(1);
        }
      },
      { deep: true, flush: "post" }
    );
    function onClickedOutside(event) {
      if (!isActive.value || props.inline) return;
      if (!props.closeOnOutside) return;
      close("outside", event);
    }
    function onPageScroll(event) {
      if (!isActive.value || props.inline) return;
      if (!props.closeOnScroll) return;
      close("scroll", event);
    }
    function onTriggerClick(event) {
      if (isMobileNative && hoverable.value) toggle("click", event);
      if (!props.triggers.includes("click")) return;
      toggle("click", event);
    }
    function onTriggerContextMenu(event) {
      if (!props.triggers.includes("contextmenu")) return;
      event.preventDefault();
      open("contextmenu", event);
    }
    function onTriggerFocus(event) {
      if (!props.triggers.includes("focus")) return;
      open("focus", event);
    }
    function onTriggerHover(event) {
      if (isMobileNative) return;
      if (!props.triggers.includes("hover")) return;
      open("hover", event);
    }
    function onTriggerHoverLeave(event) {
      if (isMobileNative) return;
      if (!props.triggers.includes("hover")) return;
      close("outside", event);
    }
    function toggle(method, event) {
      if (props.disabled) return;
      if (!isActive.value) open(method, event);
      else close(method, event);
    }
    let timer;
    function open(method, event) {
      if (props.disabled) return;
      if (isActive.value) return;
      if (props.delay) {
        timer = setTimeout(() => {
          isActive.value = true;
          emits("open", method, event);
          timer = void 0;
        }, props.delay);
      } else {
        vue.nextTick(() => isActive.value = true);
        emits("open", method, event);
      }
    }
    function close(method, event) {
      var _a2, _b;
      if (!isActive.value) return;
      emits("close", method, event);
      if (props.selectOnClose && ((_b = (_a2 = focusedItem.value) == null ? void 0 : _a2.data) == null ? void 0 : _b.value))
        selectItem(focusedItem.value);
      isActive.value = false;
      focusedItem.value = void 0;
      if (timer) clearTimeout(timer);
    }
    function selectItem(item, event) {
      var _a2;
      const value = item.data.value;
      emits("select", value);
      if (props.selectable) {
        if (helpers.isTrueish(props.multiple)) {
          if (vmodel.value && Array.isArray(vmodel.value)) {
            if (!vmodel.value.includes(value)) {
              vmodel.value = [...vmodel.value, value];
            } else {
              vmodel.value = vmodel.value.filter(
                (val) => val !== value
              );
            }
          } else {
            vmodel.value = [value];
          }
          vue.nextTick(() => emits("change", vmodel.value));
        } else {
          if (vmodel.value !== value) {
            vmodel.value = value;
            vue.nextTick(() => emits("change", vmodel.value));
          }
        }
      }
      (_a2 = triggerRef.value) == null ? void 0 : _a2.focus();
      if (props.keepOpen || !isActive.value || !event) return;
      close("content", event);
    }
    const focusedItem = vue.ref();
    function focusItem(value) {
      focusedItem.value = value;
    }
    function moveFocus(delta) {
      var _a2;
      if (!isNotEmpty.value) return;
      const item = getFirstViableItem(((_a2 = focusedItem.value) == null ? void 0 : _a2.index) || 0, delta);
      setFocus(item);
    }
    function setFocus(item) {
      var _a2, _b;
      if (props.selectOnFocus && ((_a2 = item.data) == null ? void 0 : _a2.value))
        selectItem(item, new Event("focus"));
      const dropdownMenu = unrefElement.unrefElement(menuRef);
      const element = unrefElement.unrefElement((_b = item.data) == null ? void 0 : _b.$el);
      if (!dropdownMenu || !element) return;
      focusedItem.value = item;
      maintainScrollVisibility(element, dropdownMenu);
    }
    function onUpPressed(event) {
      if (!isActive.value) return open("keydown", event);
      moveFocus(-1);
    }
    function onDownPressed(event) {
      if (!isActive.value) return open("keydown", event);
      moveFocus(1);
    }
    function onEnter(event) {
      var _a2;
      if (!isActive.value) return;
      if (focusedItem.value) {
        setFocus(focusedItem.value);
        (_a2 = focusedItem.value.data) == null ? void 0 : _a2.selectItem(event);
      }
    }
    function onHomePressed(event) {
      open("keydown", event);
      if (!isNotEmpty.value) return;
      const item = getFirstViableItem(0, 1);
      setFocus(item);
    }
    function onEndPressed(event) {
      open("keydown", event);
      if (!isNotEmpty.value) return;
      const item = getFirstViableItem(childItems.value.length - 1, -1);
      setFocus(item);
    }
    function onEscape(event) {
      close("escape", event);
    }
    function getFirstViableItem(startingIndex, delta) {
      var _a2, _b;
      let newIndex = helpers.mod(
        ((_a2 = focusedItem.value) == null ? void 0 : _a2.index) == startingIndex ? startingIndex + delta : startingIndex,
        childItems.value.length
      );
      for (; newIndex !== ((_b = focusedItem.value) == null ? void 0 : _b.index); newIndex = helpers.mod(newIndex + delta, childItems.value.length)) {
        if (isItemViable(childItems.value[newIndex])) break;
      }
      return childItems.value[newIndex];
    }
    function isItemViable(item) {
      var _a2, _b, _c;
      return !((_a2 = item.data) == null ? void 0 : _a2.disabled) && !((_b = item.data) == null ? void 0 : _b.hidden) && !!((_c = item.data) == null ? void 0 : _c.clickable);
    }
    const rootClasses = defineClasses.defineClasses(
      ["rootClass", "o-dropdown"],
      [
        "disabledClass",
        "o-dropdown--disabled",
        null,
        vue.computed(() => props.disabled)
      ],
      [
        "expandedClass",
        "o-dropdown--expanded",
        null,
        vue.computed(() => props.expanded)
      ],
      ["inlineClass", "o-dropdown--inline", null, vue.computed(() => props.inline)],
      ["mobileClass", "o-dropdown--mobile", null, isMobile],
      ["modalClass", "o-dropdown--modal", null, isModal],
      ["hoverableClass", "o-dropdown--hoverable", null, hoverable],
      [
        "positionClass",
        "o-dropdown--position-",
        autoPosition,
        vue.computed(() => !!autoPosition.value)
      ],
      [
        "activeClass",
        "o-dropdown--active",
        null,
        vue.computed(() => isActive.value || props.inline)
      ]
    );
    const triggerClasses = defineClasses.defineClasses(["triggerClass", "o-dropdown__trigger"]);
    const teleportClasses = defineClasses.defineClasses([
      "teleportClass",
      "o-dropdown--teleport",
      null,
      vue.computed(() => !!props.teleport)
    ]);
    const overlayClasses = defineClasses.defineClasses(["overlayClass", "o-dropdown__overlay"]);
    const menuClasses = defineClasses.defineClasses(
      ["menuClass", "o-dropdown__menu"],
      [
        "menuPositionClass",
        "o-dropdown__menu--",
        autoPosition,
        vue.computed(() => !!autoPosition.value)
      ],
      [
        "menuActiveClass",
        "o-dropdown__menu--active",
        null,
        vue.computed(() => isActive.value || props.inline)
      ]
    );
    __expose({ $trigger: triggerRef, $content: menuRef, value: vmodel });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        "data-oruga": "dropdown",
        class: vue.normalizeClass(vue.unref(rootClasses)),
        onMouseleave: onTriggerHoverLeave,
        onFocusout: onTriggerHoverLeave
      }, [
        !_ctx.inline ? (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.triggerTag), {
          key: 0,
          ref_key: "triggerRef",
          ref: triggerRef,
          class: vue.normalizeClass(vue.unref(triggerClasses)),
          role: _ctx.selectable ? "combobox" : void 0,
          tabindex: _ctx.disabled ? -1 : null,
          "aria-haspopup": _ctx.selectable ? "listbox" : "menu",
          "aria-expanded": _ctx.selectable ? isActive.value : void 0,
          "aria-activedescendant": focusedItem.value ? `${_ctx.menuId}-${focusedItem.value.identifier}` : void 0,
          "aria-disabled": _ctx.disabled,
          "aria-controls": _ctx.menuId,
          "aria-labelledby": _ctx.selectable ? vue.unref(labelId) : void 0,
          "aria-label": _ctx.selectable ? _ctx.ariaLabel : void 0,
          onClick: onTriggerClick,
          onContextmenu: onTriggerContextMenu,
          onMouseenter: onTriggerHover,
          onFocusCapture: onTriggerFocus,
          onKeydown: [
            vue.withKeys(onEscape, ["tab"]),
            vue.withKeys(onEscape, ["escape"]),
            vue.withKeys(onEnter, ["enter"]),
            vue.withKeys(onEnter, ["space"]),
            vue.withKeys(vue.withModifiers(onUpPressed, ["prevent"]), ["up"]),
            vue.withKeys(vue.withModifiers(onDownPressed, ["prevent"]), ["down"]),
            vue.withKeys(vue.withModifiers(onHomePressed, ["prevent"]), ["home"]),
            vue.withKeys(vue.withModifiers(onEndPressed, ["prevent"]), ["end"])
          ]
        }, {
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "trigger", {
              active: isActive.value,
              value: __props.modelValue,
              toggle: onTriggerClick
            }, () => [
              vue.createTextVNode(vue.toDisplayString(_ctx.label), 1)
            ])
          ]),
          _: 3
        }, 40, ["class", "role", "tabindex", "aria-haspopup", "aria-expanded", "aria-activedescendant", "aria-disabled", "aria-controls", "aria-labelledby", "aria-label", "onKeydown"])) : vue.createCommentVNode("", true),
        vue.createVNode(PositionWrapper_vue_vue_type_script_setup_true_lang._sfc_main, {
          position: autoPosition.value,
          "onUpdate:position": _cache[6] || (_cache[6] = ($event) => autoPosition.value = $event),
          teleport: _ctx.teleport,
          class: vue.normalizeClass([...vue.unref(rootClasses), ...vue.unref(teleportClasses)]),
          trigger: triggerRef.value,
          disabled: !isActive.value,
          "default-position": "bottom",
          "disable-positioning": !isModal.value
        }, {
          default: vue.withCtx(({ setContent }) => [
            isModal.value ? (vue.openBlock(), vue.createBlock(vue.Transition, {
              key: 0,
              name: _ctx.animation
            }, {
              default: vue.withCtx(() => [
                vue.withDirectives(vue.createElementVNode("div", {
                  class: vue.normalizeClass(vue.unref(overlayClasses)),
                  tabindex: "-1",
                  onClick: onClickedOutside
                }, null, 2), [
                  [vue.vShow, isActive.value]
                ])
              ]),
              _: 1
            }, 8, ["name"])) : vue.createCommentVNode("", true),
            vue.createVNode(vue.Transition, { name: _ctx.animation }, {
              default: vue.withCtx(() => [
                vue.withDirectives((vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.menuTag), {
                  id: _ctx.menuId,
                  ref: (el) => menuRef.value = setContent(el),
                  tabindex: _ctx.inline ? 0 : -1,
                  class: vue.normalizeClass(vue.unref(menuClasses)),
                  style: vue.normalizeStyle(menuStyle.value),
                  role: _ctx.selectable ? "listbox" : "menu",
                  "aria-labelledby": vue.unref(labelId),
                  "aria-label": _ctx.ariaLabel,
                  "aria-hidden": !_ctx.inline && (_ctx.disabled || !isActive.value),
                  "aria-multiselectable": _ctx.selectable ? vue.unref(helpers.isTrueish)(_ctx.multiple) : void 0,
                  onKeydown: [
                    _cache[0] || (_cache[0] = vue.withKeys(vue.withModifiers(($event) => _ctx.inline && onEnter($event), ["prevent"]), ["enter"])),
                    _cache[1] || (_cache[1] = vue.withKeys(vue.withModifiers(($event) => _ctx.inline && onEnter($event), ["prevent"]), ["space"])),
                    _cache[2] || (_cache[2] = vue.withKeys(vue.withModifiers(($event) => _ctx.inline && onUpPressed($event), ["prevent"]), ["up"])),
                    _cache[3] || (_cache[3] = vue.withKeys(vue.withModifiers(($event) => _ctx.inline && onDownPressed($event), ["prevent"]), ["down"])),
                    _cache[4] || (_cache[4] = vue.withKeys(vue.withModifiers(($event) => _ctx.inline && onHomePressed($event), ["prevent"]), ["home"])),
                    _cache[5] || (_cache[5] = vue.withKeys(vue.withModifiers(($event) => _ctx.inline && onEndPressed($event), ["prevent"]), ["end"]))
                  ]
                }, {
                  default: vue.withCtx(() => {
                    var _a2;
                    return [
                      vue.renderSlot(_ctx.$slots, "default", {
                        active: isActive.value,
                        focusedIndex: (_a2 = focusedItem.value) == null ? void 0 : _a2.index,
                        toggle
                      }, () => [
                        vue.renderSlot(_ctx.$slots, "before"),
                        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(groupedOptions.value, (group, groupIndex) => {
                          return vue.openBlock(), vue.createElementBlock(vue.Fragment, null, [
                            group.label ? vue.withDirectives((vue.openBlock(), vue.createBlock(_sfc_main$1, vue.mergeProps({
                              key: 0,
                              ref_for: true
                            }, group.attrs, {
                              key: group.key,
                              value: group.value,
                              hidden: group.hidden,
                              role: "presentation",
                              clickable: false
                            }), {
                              default: vue.withCtx(() => [
                                _ctx.$slots.group ? vue.renderSlot(_ctx.$slots, "group", {
                                  key: 0,
                                  group: group.label,
                                  index: groupIndex
                                }) : (vue.openBlock(), vue.createElementBlock("span", _hoisted_1, vue.toDisplayString(group.label), 1))
                              ]),
                              _: 2
                            }, 1040, ["value", "hidden"])), [
                              [vue.vShow, !group.hidden]
                            ]) : vue.createCommentVNode("", true),
                            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(group.options, (option) => {
                              return vue.withDirectives((vue.openBlock(), vue.createBlock(_sfc_main$1, vue.mergeProps({ ref_for: true }, option.attrs, {
                                key: option.key,
                                value: option.value,
                                hidden: option.hidden
                              }), {
                                default: vue.withCtx(() => [
                                  vue.createTextVNode(vue.toDisplayString(option.label), 1)
                                ]),
                                _: 2
                              }, 1040, ["value", "hidden"])), [
                                [vue.vShow, !option.hidden]
                              ]);
                            }), 128))
                          ], 64);
                        }), 256)),
                        vue.renderSlot(_ctx.$slots, "after")
                      ])
                    ];
                  }),
                  _: 2
                }, 1064, ["id", "tabindex", "class", "style", "role", "aria-labelledby", "aria-label", "aria-hidden", "aria-multiselectable"])), [
                  [vue.vShow, !_ctx.disabled && isActive.value || _ctx.inline]
                ])
              ]),
              _: 2
            }, 1032, ["name"])
          ]),
          _: 3
        }, 8, ["position", "teleport", "class", "trigger", "disabled", "disable-positioning"])
      ], 34);
    };
  }
});
exports._sfc_main = _sfc_main;
exports._sfc_main$1 = _sfc_main$1;
//# sourceMappingURL=Dropdown.vue_vue_type_script_setup_true_lang-B-lOSKsS.cjs.map
