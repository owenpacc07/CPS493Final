"use strict";
/*! Oruga v0.10.5 | MIT License | github.com/oruga-ui/oruga */
const vue = require("vue");
const config = require("./config-DQse3iF9.cjs");
const helpers = require("./helpers.cjs");
const getActiveClasses = (classes) => {
  const values = vue.toValue(classes);
  if (!values) return [];
  return values.flatMap(
    (bind) => Object.keys(bind).filter((key) => key && bind[key]).flatMap((v) => v.split(" "))
  );
};
function defineClasses(...args) {
  const options = Array.isArray(args.at(-1)) ? void 0 : args.at(-1);
  const classDefinitions = Array.isArray(args.at(-1)) ? args : args.slice(0, -1);
  const vm = vue.getCurrentInstance();
  if (!vm)
    throw new Error(
      "defineClasses must be called within a component setup function."
    );
  if (!vue.getCurrentScope() && !(options == null ? void 0 : options.scope))
    throw new Error(
      "defineClasses must be called within a current active effect scope."
    );
  const scope = (options == null ? void 0 : options.scope) || vue.effectScope();
  if (vue.getCurrentScope())
    vue.onScopeDispose(() => {
      if (scope) scope.stop();
    });
  const classes = vue.ref([]);
  classes.value = classDefinitions.map((defintion, index) => {
    const className = defintion[0];
    const defaultClass = defintion[1];
    const suffix = defintion[2];
    const apply = defintion[3];
    function getClassBind() {
      const computedClass = computeClass(
        vm,
        className,
        defaultClass,
        vue.toValue(suffix) || void 0
      );
      const applied = !helpers.isDefined(apply) || vue.toValue(apply);
      return { [computedClass]: applied };
    }
    scope.run(() => {
      vue.watch(
        [
          () => {
            var _a;
            return (_a = vm.proxy) == null ? void 0 : _a.$props[className];
          },
          () => (options == null ? void 0 : options.props) ? options == null ? void 0 : options.props[className] : null
        ],
        () => {
          const classBind = getClassBind();
          classes.value[index] = classBind;
        }
      );
      if (helpers.isDefined(suffix) && vue.isRef(suffix)) {
        vue.watch(suffix, (value, oldValue) => {
          if (value === oldValue) return;
          const classBind = getClassBind();
          classes.value[index] = classBind;
        });
      }
      if (helpers.isDefined(apply) && vue.isRef(apply)) {
        vue.watch(apply, (applied, oldValue) => {
          if (applied === oldValue) return;
          const classBind = classes.value[index];
          Object.keys(classBind).forEach(
            (key) => classBind[key] = applied
          );
          classes.value[index] = classBind;
        });
      }
    });
    return getClassBind();
  });
  return classes;
}
function computeClass(vm, field, defaultValue, suffix = "") {
  var _a;
  const props = getProps(vm);
  const componentKey = (_a = vm.proxy) == null ? void 0 : _a.$options.configField;
  if (!componentKey)
    throw new Error("component must define the 'configField' option.");
  const config$1 = props.override === true ? {} : config.getOptions();
  let globalClass = helpers.getValueByPath(
    config$1,
    `${componentKey}.${field}.class`,
    ""
  ) || helpers.getValueByPath(
    config$1,
    `${componentKey}.${field}`,
    ""
  );
  let localClass = helpers.getValueByPath(
    props,
    field,
    ""
  );
  if (Array.isArray(localClass)) {
    localClass = localClass.join(" ");
  }
  if (typeof localClass === "function") {
    const props2 = getProps(vm);
    localClass = localClass(suffix, props2);
  } else {
    localClass = suffixProcessor(localClass, suffix);
  }
  if (Array.isArray(globalClass)) {
    globalClass = globalClass.join(" ");
  }
  if (typeof globalClass === "function") {
    const props2 = getProps(vm);
    globalClass = globalClass(suffix, props2);
  } else {
    globalClass = suffixProcessor(globalClass, suffix);
  }
  if (defaultValue.includes("{*}")) {
    defaultValue = defaultValue.replace(
      /\{\*\}/g,
      helpers.blankIfUndefined(suffix)
    );
  } else {
    defaultValue = defaultValue + helpers.blankIfUndefined(suffix);
  }
  const globalOverride = props.override || helpers.getValueByPath(config$1, "override", false);
  const localOverride = helpers.getValueByPath(
    config$1,
    `${componentKey}.override`,
    globalOverride
  );
  const overrideClass = helpers.getValueByPath(
    config$1,
    `${componentKey}.${field}.override`,
    localOverride
  );
  let appliedClasses = `${!overrideClass ? defaultValue : ""} ${helpers.blankIfUndefined(globalClass)} ${helpers.blankIfUndefined(localClass)}`.trim().replace(/\s\s+/g, " ");
  const globalTransformClasses = helpers.getValueByPath(
    config$1,
    "transformClasses",
    void 0
  );
  const localTransformClasses = helpers.getValueByPath(
    config$1,
    `${componentKey}.transformClasses`,
    void 0
  );
  if (localTransformClasses) {
    appliedClasses = localTransformClasses(appliedClasses);
  } else if (globalTransformClasses) {
    appliedClasses = globalTransformClasses(appliedClasses);
  }
  return appliedClasses;
}
function suffixProcessor(input, suffix) {
  return helpers.blankIfUndefined(input).split(" ").filter((cls) => cls.length > 0).map((cls) => cls + helpers.blankIfUndefined(suffix)).join(" ");
}
const getProps = (vm) => {
  var _a;
  let props = ((_a = vm.proxy) == null ? void 0 : _a.$props) || {};
  props = Object.keys(props).filter((key) => key.endsWith("Props")).map((key) => props[key]).reduce((a, b) => ({ ...a, ...b }), props);
  return props;
};
exports.defineClasses = defineClasses;
exports.getActiveClasses = getActiveClasses;
//# sourceMappingURL=defineClasses-HOBoThd5.cjs.map
