"use strict";
/*! Oruga v0.10.5 | MIT License | github.com/oruga-ui/oruga */
const vue = require("vue");
const Select_vue_vue_type_script_setup_true_lang = require("./Select.vue_vue_type_script_setup_true_lang-CgbH85R0.cjs");
const utils = require("./utils-BOwxsHCu.cjs");
const config = require("./config-DQse3iF9.cjs");
const helpers = require("./helpers.cjs");
const defineClasses = require("./defineClasses-HOBoThd5.cjs");
const useMatchMedia = require("./useMatchMedia-CERtemgT.cjs");
const AM = "AM";
const PM = "PM";
const HOUR_FORMAT_24 = "24";
const HOUR_FORMAT_12 = "12";
function useTimepickerMixins(props) {
  const localeOptions = vue.computed(
    () => new Intl.DateTimeFormat(props.locale, {
      hour: "numeric",
      minute: "numeric",
      second: props.enableSeconds ? "numeric" : void 0
    }).resolvedOptions()
  );
  const isHourFormat24 = vue.computed(
    () => props.hourFormat && props.hourFormat === HOUR_FORMAT_24 || !props.hourFormat && !localeOptions.value.hour12
  );
  const dtf = vue.computed(
    () => new Intl.DateTimeFormat(props.locale, {
      hour: localeOptions.value.hour || "numeric",
      minute: localeOptions.value.minute || "numeric",
      second: props.enableSeconds ? localeOptions.value.second || "numeric" : void 0,
      hourCycle: !isHourFormat24.value ? "h12" : "h23"
    })
  );
  const sampleTime = vue.computed(() => {
    const d = timeCreator();
    d.setHours(10);
    d.setSeconds(0);
    d.setMinutes(0);
    d.setMilliseconds(0);
    return d;
  });
  const amString = vue.computed(() => {
    if (dtf.value.formatToParts && typeof dtf.value.formatToParts === "function") {
      const d = new Date(sampleTime.value);
      d.setHours(10);
      const dayPeriod = dtf.value.formatToParts(d).find((part) => part.type === "dayPeriod");
      if (dayPeriod) return dayPeriod.value;
    }
    return AM;
  });
  const pmString = vue.computed(() => {
    if (dtf.value.formatToParts && typeof dtf.value.formatToParts === "function") {
      const d = new Date(sampleTime.value);
      d.setHours(20);
      const dayPeriod = dtf.value.formatToParts(d).find((part) => part.type === "dayPeriod");
      if (dayPeriod) {
        return dayPeriod.value;
      }
    }
    return PM;
  });
  const meridiens = vue.computed(() => [amString.value, pmString.value]);
  const hourLiteral = vue.computed(() => {
    if (dtf.value.formatToParts && typeof dtf.value.formatToParts === "function") {
      const d = new Date(sampleTime.value);
      const parts = dtf.value.formatToParts(d);
      const literal = parts.find(
        (part, idx) => idx > 0 && parts[idx - 1].type === "hour"
      );
      if (literal) return literal.value;
    }
    return ":";
  });
  const minuteLiteral = vue.computed(() => {
    if (dtf.value.formatToParts && typeof dtf.value.formatToParts === "function") {
      const d = new Date(sampleTime.value);
      const parts = dtf.value.formatToParts(d);
      const literal = parts.find(
        (part, idx) => idx > 0 && parts[idx - 1].type === "minute"
      );
      if (literal) return literal.value;
    }
    return ":";
  });
  const secondLiteral = vue.computed(() => {
    if (dtf.value.formatToParts && typeof dtf.value.formatToParts === "function") {
      const d = new Date(sampleTime.value);
      const parts = dtf.value.formatToParts(d);
      const literal = parts.find(
        (part, idx) => idx > 0 && parts[idx - 1].type === "second"
      );
      if (literal) return literal.value;
    }
    return void 0;
  });
  function timeCreator() {
    return typeof props.creator === "function" ? props.creator() : /* @__PURE__ */ new Date();
  }
  function timeFormatter(time) {
    if (typeof props.formatter === "function") return props.formatter(time);
    if (!time) return "00:00";
    return dtf.value.format(time);
  }
  function timeParser(time) {
    if (typeof props.parser === "function") return props.parser(time);
    if (!time) return void 0;
    if (dtf.value.formatToParts && typeof dtf.value.formatToParts === "function") {
      const formatRegex = dtf.value.formatToParts(sampleTime.value).map((part) => {
        if (part.type === "literal") {
          return part.value.replace(/ /g, "\\s?");
        } else if (part.type === "dayPeriod") {
          return `((?!=<${part.type}>)(${amString.value}|${pmString.value}|${AM}|${PM}|${AM.toLowerCase()}|${PM.toLowerCase()})?)`;
        }
        return `((?!=<${part.type}>)\\d+)`;
      }).join("");
      const timeGroups = utils.matchWithGroups(formatRegex, time);
      timeGroups.hour = timeGroups.hour ? parseInt(timeGroups.hour, 10) : null;
      timeGroups.minute = timeGroups.minute ? parseInt(timeGroups.minute, 10) : null;
      timeGroups.second = timeGroups.second ? parseInt(timeGroups.second, 10) : null;
      if (timeGroups.hour && timeGroups.hour >= 0 && timeGroups.hour < 24 && timeGroups.minute && timeGroups.minute >= 0 && timeGroups.minute < 59) {
        if (timeGroups.dayPeriod && (timeGroups.dayPeriod.toLowerCase() === pmString.value.toLowerCase() || timeGroups.dayPeriod.toLowerCase() === PM.toLowerCase()) && timeGroups.hour < 12) {
          timeGroups.hour += 12;
        }
        const date2 = new Date(sampleTime.value);
        date2.setHours(timeGroups.hour);
        date2.setMinutes(timeGroups.minute);
        date2.setSeconds(timeGroups.second || 0);
        return date2;
      }
    }
    let am = false;
    if (props.hourFormat === HOUR_FORMAT_12) {
      const dateString12 = time.split(" ");
      time = dateString12[0];
      am = dateString12[1] === amString.value || dateString12[1] === AM;
    }
    const timeSplit = time.split(":");
    let hours = parseInt(timeSplit[0], 10);
    const minutes = parseInt(timeSplit[1], 10);
    const seconds = props.enableSeconds && timeSplit.length >= 3 ? parseInt(timeSplit[2], 10) : 0;
    if (isNaN(hours) || hours < 0 || hours > 23 || props.hourFormat === HOUR_FORMAT_12 && (hours < 1 || hours > 12) || isNaN(minutes) || minutes < 0 || minutes > 59) {
      return void 0;
    }
    const date = new Date(sampleTime.value);
    date.setSeconds(seconds);
    date.setMinutes(minutes);
    if (props.hourFormat === HOUR_FORMAT_12) {
      if (am && hours === 12) {
        hours = 0;
      } else if (!am && hours !== 12) {
        hours += 12;
      }
    }
    date.setHours(hours);
    return new Date(date.getTime());
  }
  return {
    dtf,
    timeCreator,
    timeFormatter,
    timeParser,
    pmString,
    amString,
    meridiens,
    isHourFormat24,
    hourLiteral,
    minuteLiteral,
    secondLiteral
  };
}
const _hoisted_1 = ["value", "disabled"];
const _hoisted_2 = ["value", "disabled"];
const _hoisted_3 = ["value", "disabled"];
const _sfc_main = /* @__PURE__ */ vue.defineComponent({
  ...{
    isOruga: true,
    name: "OTimepicker",
    configField: "timepicker"
  },
  __name: "Timepicker",
  props: /* @__PURE__ */ vue.mergeModels({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    active: { type: Boolean, default: false },
    minTime: { default: void 0 },
    maxTime: { default: void 0 },
    inline: { type: Boolean, default: false },
    placeholder: { default: void 0 },
    expanded: { type: Boolean, default: false },
    rounded: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    size: { default: () => config.getDefault("timepicker.size") },
    hourFormat: { default: void 0 },
    incrementHours: { default: 1 },
    incrementMinutes: { default: 1 },
    incrementSeconds: { default: 1 },
    openOnFocus: { type: Boolean, default: () => config.getDefault("timepicker.openOnFocus", true) },
    closeOnClick: { type: Boolean, default: () => config.getDefault("timepicker.closeOnClick", true) },
    enableSeconds: { type: Boolean, default: false },
    defaultMinutes: { default: void 0 },
    defaultSeconds: { default: void 0 },
    locale: { default: () => config.getDefault("locale") },
    formatter: { type: Function, default: config.getDefault("timepicker.formatter") },
    parser: { type: Function, default: config.getDefault("timepicker.parser") },
    creator: { type: Function, default: config.getDefault("timepicker.creator") },
    unselectableTimes: { type: [Array, Function], default: void 0 },
    resetOnMeridianChange: { type: Boolean, default: false },
    position: { default: void 0 },
    iconPack: { default: () => config.getDefault("timepicker.iconPack") },
    icon: { default: () => config.getDefault("timepicker.icon") },
    iconRight: { default: () => config.getDefault("timepicker.iconRight") },
    iconRightClickable: { type: Boolean, default: false },
    mobileModal: { type: Boolean, default: () => config.getDefault("timepicker.mobileModal", true) },
    desktopModal: { type: Boolean, default: () => config.getDefault("timepicker.desktopModal", false) },
    mobileNative: { type: Boolean, default: () => config.getDefault("timepicker.mobileNative", true) },
    mobileBreakpoint: { default: () => config.getDefault("timepicker.mobileBreakpoint") },
    teleport: { type: [Boolean, String, Object], default: () => config.getDefault("timepicker.teleport", false) },
    useHtml5Validation: { type: Boolean, default: () => config.getDefault("useHtml5Validation", true) },
    customValidity: { type: [String, Function], default: "" },
    ariaSelectSecondsLabel: { default: () => config.getDefault("timepicker.ariaSelectSecondLabel", "Select Second") },
    ariaSelectMinutesLabel: { default: () => config.getDefault("timepicker.ariaSelectMinuteLabel", "Select Minute") },
    ariaSelectHoursLabel: { default: () => config.getDefault("timepicker.ariaSelectHourLabel", "Select Hour") },
    rootClass: {},
    mobileClass: {},
    sizeClass: {},
    boxClass: {},
    separatorClass: {},
    footerClass: {},
    dropdownClass: {},
    inputClass: {},
    inputClasses: { default: () => config.getDefault("timepicker.inputClasses") },
    dropdownClasses: { default: () => config.getDefault("timepicker.dropdownClasses") },
    selectClasses: { default: () => config.getDefault("timepicker.selectClasses") }
  }, {
    "modelValue": { default: void 0 },
    "modelModifiers": {},
    "active": { type: Boolean, ...{ default: false } },
    "activeModifiers": {}
  }),
  emits: /* @__PURE__ */ vue.mergeModels(["update:model-value", "update:active", "focus", "blur", "invalid", "icon-click", "icon-right-click"], ["update:modelValue", "update:active"]),
  setup(__props, { expose: __expose }) {
    const props = __props;
    const { isMobile } = useMatchMedia.useMatchMedia(props.mobileBreakpoint);
    const {
      dtf,
      timeCreator,
      timeFormatter,
      timeParser,
      pmString,
      amString,
      meridiens,
      isHourFormat24,
      hourLiteral,
      minuteLiteral,
      secondLiteral
    } = useTimepickerMixins(props);
    const pickerRef = vue.useTemplateRef("pickerComponent");
    const vmodel = vue.useModel(__props, "modelValue");
    const isActive = vue.useModel(__props, "active");
    const hoursSelected = vue.ref();
    const minutesSelected = vue.ref();
    const secondsSelected = vue.ref();
    const meridienSelected = vue.ref();
    vue.watch(
      () => props.modelValue,
      (value) => updateValue(value),
      { immediate: true }
    );
    function updateValue(value) {
      if (Array.isArray(value)) return updateValue(value[0]);
      if (vmodel.value !== value) vmodel.value = value;
      if (value) {
        hoursSelected.value = value.getHours();
        minutesSelected.value = value.getMinutes();
        secondsSelected.value = value.getSeconds();
        meridienSelected.value = value.getHours() >= 12 ? pmString.value : amString.value;
      } else {
        hoursSelected.value = void 0;
        minutesSelected.value = void 0;
        secondsSelected.value = void 0;
        meridienSelected.value = amString.value;
      }
    }
    const step = vue.computed(() => props.enableSeconds ? "1" : void 0);
    vue.watch(
      () => props.hourFormat,
      () => {
        if (helpers.isDefined(hoursSelected.value))
          meridienSelected.value = (hoursSelected.value || 0) >= 12 ? pmString.value : amString.value;
      }
    );
    vue.watch(
      () => props.locale,
      (value) => {
        if (!value) meridienSelected.value = amString.value;
      }
    );
    function formatNumber(value, prependZero) {
      return isHourFormat24.value || prependZero ? helpers.pad(value) : String(value);
    }
    const hours = vue.computed(() => {
      if (!props.incrementHours || props.incrementHours < 1)
        throw new Error("Hour increment cannot be null or less than 1.");
      const hours2 = [];
      const numberOfHours = isHourFormat24.value ? 24 : 12;
      for (let i = 0; i < numberOfHours; i += props.incrementHours) {
        let value = i;
        let label = value;
        if (!isHourFormat24.value) {
          value = i + 1;
          label = value;
          if (meridienSelected.value === amString.value) {
            if (value === 12) value = 0;
          } else if (meridienSelected.value === pmString.value) {
            if (value !== 12) value += 12;
          }
        }
        hours2.push({
          label: formatNumber(label, false),
          value
        });
      }
      return hours2;
    });
    const minutes = vue.computed(() => {
      if (!props.incrementMinutes || props.incrementMinutes < 1)
        throw new Error("Minute increment cannot be null or less than 1.");
      const minutes2 = [];
      for (let i = 0; i < 60; i += props.incrementMinutes) {
        minutes2.push({
          label: formatNumber(i, true),
          value: i
        });
      }
      return minutes2;
    });
    const seconds = vue.computed(() => {
      if (!props.incrementSeconds || props.incrementSeconds < 1)
        throw new Error("Second increment cannot be null or less than 1.");
      const seconds2 = [];
      for (let i = 0; i < 60; i += props.incrementSeconds) {
        seconds2.push({
          label: formatNumber(i, true),
          value: i
        });
      }
      return seconds2;
    });
    function isHourDisabled(hour) {
      let disabled = false;
      if (props.minTime) {
        const minHours = props.minTime.getHours();
        const noMinutesAvailable = minutes.value.every((minute) => {
          return isMinuteDisabledForHour(hour, minute.value);
        });
        disabled = hour < minHours || noMinutesAvailable;
      }
      if (props.maxTime) {
        if (!disabled) {
          const maxHours = props.maxTime.getHours();
          disabled = hour > maxHours;
        }
      }
      if (props.unselectableTimes && !disabled) {
        if (typeof props.unselectableTimes === "function") {
          const date = /* @__PURE__ */ new Date();
          date.setHours(hour);
          date.setMinutes(minutesSelected.value || 0);
          date.setSeconds(secondsSelected.value || 0);
          return props.unselectableTimes(date);
        } else {
          const unselectable = props.unselectableTimes.filter((time) => {
            if (props.enableSeconds && helpers.isDefined(secondsSelected.value)) {
              return time.getHours() === hour && time.getMinutes() === minutesSelected.value && time.getSeconds() === secondsSelected.value;
            } else if (helpers.isDefined(minutesSelected.value)) {
              return time.getHours() === hour && time.getMinutes() === minutesSelected.value;
            }
            return false;
          });
          if (unselectable.length > 0) {
            disabled = true;
          } else {
            disabled = minutes.value.every((minute) => {
              return props.unselectableTimes.filter((time) => {
                return time.getHours() === hour && time.getMinutes() === minute.value;
              }).length > 0;
            });
          }
        }
      }
      return disabled;
    }
    function isMinuteDisabledForHour(hour, minute) {
      let disabled = false;
      if (props.minTime) {
        const minHours = props.minTime.getHours();
        const minMinutes = props.minTime.getMinutes();
        disabled = hour === minHours && minute < minMinutes;
      }
      if (props.maxTime) {
        if (!disabled) {
          const maxHours = props.maxTime.getHours();
          const maxMinutes = props.maxTime.getMinutes();
          disabled = hour === maxHours && minute > maxMinutes;
        }
      }
      return disabled;
    }
    function isMinuteDisabled(minute) {
      if (hoursSelected.value === void 0) return false;
      let disabled = isHourDisabled(hoursSelected.value) || isMinuteDisabledForHour(hoursSelected.value, minute);
      if (props.unselectableTimes && !disabled) {
        if (typeof props.unselectableTimes === "function") {
          const date = /* @__PURE__ */ new Date();
          date.setHours(hoursSelected.value);
          date.setMinutes(minute);
          date.setSeconds(secondsSelected.value || 0);
          return props.unselectableTimes(date);
        } else {
          const unselectable = props.unselectableTimes.filter((time) => {
            if (props.enableSeconds && helpers.isDefined(secondsSelected.value)) {
              return time.getHours() === hoursSelected.value && time.getMinutes() === minute && time.getSeconds() === secondsSelected.value;
            } else {
              return time.getHours() === hoursSelected.value && time.getMinutes() === minute;
            }
          });
          disabled = unselectable.length > 0;
        }
      }
      return disabled;
    }
    function isSecondDisabled(second) {
      if (!helpers.isDefined(minutesSelected.value)) return false;
      let disabled = false;
      if (isMinuteDisabled(minutesSelected.value)) {
        disabled = true;
      } else {
        if (props.minTime) {
          const minHours = props.minTime.getHours();
          const minMinutes = props.minTime.getMinutes();
          const minSeconds = props.minTime.getSeconds();
          disabled = hoursSelected.value === minHours && minutesSelected.value === minMinutes && second < minSeconds;
        }
        if (props.maxTime) {
          if (!disabled) {
            const maxHours = props.maxTime.getHours();
            const maxMinutes = props.maxTime.getMinutes();
            const maxSeconds = props.maxTime.getSeconds();
            disabled = hoursSelected.value === maxHours && minutesSelected.value === maxMinutes && second > maxSeconds;
          }
        }
      }
      if (props.unselectableTimes && !disabled) {
        if (typeof props.unselectableTimes === "function") {
          const date = /* @__PURE__ */ new Date();
          date.setHours(hoursSelected.value || 0);
          date.setMinutes(minutesSelected.value);
          date.setSeconds(second);
          return props.unselectableTimes(date);
        } else {
          const unselectable = props.unselectableTimes.filter((time) => {
            return time.getHours() === hoursSelected.value && time.getMinutes() === minutesSelected.value && time.getSeconds() === second;
          });
          disabled = unselectable.length > 0;
        }
      }
      return disabled;
    }
    function isMeridienDisabled(meridienString) {
      const offset = meridienString == "AM" ? 0 : 12;
      for (let i = 0; i < 12; i++) {
        if (!isHourDisabled(i + offset)) return false;
      }
      return true;
    }
    function updateDateSelected(hours2, minutes2, seconds2, meridiens2) {
      if (helpers.isDefined(hours2) && helpers.isDefined(minutes2) && (!helpers.isDefined(isHourFormat24.value) && helpers.isDefined(meridiens2) || helpers.isDefined(isHourFormat24.value))) {
        let time;
        if (vmodel.value) {
          time = new Date(vmodel.value);
        } else {
          time = timeCreator();
          time.setMilliseconds(0);
        }
        time.setHours(hours2);
        time.setMinutes(minutes2);
        time.setSeconds(seconds2);
        if (!isNaN(time.getTime())) {
          vmodel.value = new Date(time.getTime());
        }
      }
    }
    function format(value, isNative) {
      if (Array.isArray(value)) return format(value[0], isNative);
      if (isNative) return formatNative(value);
      return timeFormatter(value);
    }
    function formatNative(value) {
      if (Array.isArray(value)) return formatNative(value[0]);
      if (!value) return "";
      const date = new Date(value);
      if (!helpers.isDate(date)) return "";
      const hours2 = date.getHours();
      const minutes2 = date.getMinutes();
      const seconds2 = date.getSeconds();
      return formatNumber(hours2, true) + ":" + formatNumber(minutes2, true) + ":" + formatNumber(seconds2, true);
    }
    function parse(value, isNative) {
      if (isNative) return parseNative(value);
      const date = timeParser(value);
      return helpers.isDate(date) ? date : void 0;
    }
    function parseNative(date) {
      if (!date) return void 0;
      let time;
      if (vmodel.value) {
        time = new Date(vmodel.value);
      } else {
        time = timeCreator();
        time.setMilliseconds(0);
      }
      const t = date.split(":");
      time.setHours(parseInt(t[0], 10));
      time.setMinutes(parseInt(t[1], 10));
      time.setSeconds(t[2] ? parseInt(t[2], 10) : 0);
      return new Date(time.getTime());
    }
    function onMeridienChange(value) {
      if (helpers.isDefined(hoursSelected.value) && props.resetOnMeridianChange) {
        hoursSelected.value = void 0;
        minutesSelected.value = void 0;
        secondsSelected.value = void 0;
        vmodel.value = void 0;
      } else if (helpers.isDefined(hoursSelected.value)) {
        if (value === pmString.value) hoursSelected.value += 12;
        else if (value === amString.value) hoursSelected.value -= 12;
      }
      updateDateSelected(
        hoursSelected.value || 0,
        minutesSelected.value || 0,
        props.enableSeconds ? secondsSelected.value || 0 : 0,
        value
      );
    }
    function onHoursChange(value) {
      if (!minutesSelected.value && typeof props.defaultMinutes !== "undefined")
        minutesSelected.value = props.defaultMinutes;
      if (!secondsSelected.value && typeof props.defaultSeconds !== "undefined")
        secondsSelected.value = props.defaultSeconds;
      updateDateSelected(
        parseInt(value, 10),
        minutesSelected.value || 0,
        props.enableSeconds ? secondsSelected.value || 0 : 0,
        meridienSelected.value
      );
    }
    function onMinutesChange(value) {
      if (!secondsSelected.value && props.defaultSeconds)
        secondsSelected.value = props.defaultSeconds;
      updateDateSelected(
        hoursSelected.value || 0,
        parseInt(value, 10),
        props.enableSeconds ? secondsSelected.value || 0 : 0,
        meridienSelected.value
      );
    }
    function onSecondsChange(value) {
      updateDateSelected(
        hoursSelected.value || 0,
        minutesSelected.value || 0,
        parseInt(value, 10),
        meridienSelected.value
      );
    }
    const rootClasses = defineClasses.defineClasses(
      ["rootClass", "o-timepicker"],
      [
        "sizeClass",
        "o-timepicker--",
        vue.computed(() => props.size),
        vue.computed(() => !!props.size)
      ],
      ["mobileClass", "o-timepicker--mobile", null, isMobile]
    );
    const separatorClasses = defineClasses.defineClasses([
      "separatorClass",
      "o-timepicker__separtor"
    ]);
    const footerClasses = defineClasses.defineClasses(["footerClass", "o-timepicker__footer"]);
    const pickerDropdownClasses = defineClasses.defineClasses([
      "dropdownClass",
      "o-timepicker__dropdown"
    ]);
    const boxClasses = defineClasses.defineClasses(["boxClass", "o-timepicker__box"]);
    const boxClassBind = vue.computed(() => defineClasses.getActiveClasses(boxClasses));
    const selectSelectClasses = defineClasses.defineClasses([
      "selectClasses.selectClass",
      "o-timepicker__select"
    ]);
    const selectPlaceholderClasses = defineClasses.defineClasses([
      "selectClasses.placeholderClass",
      "o-timepicker__select-placeholder"
    ]);
    const selectBind = vue.computed(() => ({
      "select-class": defineClasses.getActiveClasses(selectSelectClasses),
      "placeholder-class": defineClasses.getActiveClasses(selectPlaceholderClasses),
      ...props.selectClasses
    }));
    __expose({ focus: () => {
      var _a;
      return (_a = pickerRef.value) == null ? void 0 : _a.focus();
    }, value: vmodel });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createBlock(utils._sfc_main, {
        ref: "pickerComponent",
        active: isActive.value,
        "onUpdate:active": _cache[8] || (_cache[8] = ($event) => isActive.value = $event),
        value: vmodel.value,
        "data-oruga": "timepicker",
        "picker-props": props,
        formatter: format,
        parser: parse,
        type: "time",
        max: _ctx.maxTime,
        min: _ctx.minTime,
        step: step.value,
        "root-classes": vue.unref(rootClasses),
        "dropdown-classes": vue.unref(pickerDropdownClasses),
        "box-class": boxClassBind.value,
        dtf: vue.unref(dtf),
        "onUpdate:value": updateValue,
        onFocus: _cache[9] || (_cache[9] = ($event) => _ctx.$emit("focus", $event)),
        onBlur: _cache[10] || (_cache[10] = ($event) => _ctx.$emit("blur", $event)),
        onInvalid: _cache[11] || (_cache[11] = ($event) => _ctx.$emit("invalid", $event)),
        onIconClick: _cache[12] || (_cache[12] = ($event) => _ctx.$emit("icon-click", $event)),
        onIconRightClick: _cache[13] || (_cache[13] = ($event) => _ctx.$emit("icon-right-click", $event))
      }, vue.createSlots({
        default: vue.withCtx(() => [
          vue.createVNode(Select_vue_vue_type_script_setup_true_lang._sfc_main, vue.mergeProps(selectBind.value, {
            modelValue: hoursSelected.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => hoursSelected.value = $event),
            options: hours.value,
            override: "",
            disabled: _ctx.disabled,
            placeholder: "00",
            "aria-label": _ctx.ariaSelectHoursLabel,
            "use-html5-validation": false,
            onChange: _cache[1] || (_cache[1] = ($event) => onHoursChange($event.target.value))
          }), null, 16, ["modelValue", "options", "disabled", "aria-label"]),
          vue.createElementVNode("span", {
            class: vue.normalizeClass(vue.unref(separatorClasses))
          }, vue.toDisplayString(vue.unref(hourLiteral)), 3),
          vue.createVNode(Select_vue_vue_type_script_setup_true_lang._sfc_main, vue.mergeProps(selectBind.value, {
            modelValue: minutesSelected.value,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => minutesSelected.value = $event),
            override: "",
            disabled: _ctx.disabled,
            placeholder: "00",
            "aria-label": _ctx.ariaSelectMinutesLabel,
            "use-html5-validation": false,
            onChange: _cache[3] || (_cache[3] = ($event) => onMinutesChange($event.target.value))
          }), {
            default: vue.withCtx(() => [
              (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(minutes.value, (minute) => {
                return vue.openBlock(), vue.createElementBlock("option", {
                  key: minute.value,
                  value: minute.value,
                  disabled: isMinuteDisabled(minute.value)
                }, vue.toDisplayString(minute.label), 9, _hoisted_1);
              }), 128))
            ]),
            _: 1
          }, 16, ["modelValue", "disabled", "aria-label"]),
          _ctx.enableSeconds ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
            vue.createElementVNode("span", {
              class: vue.normalizeClass(vue.unref(separatorClasses))
            }, vue.toDisplayString(vue.unref(minuteLiteral)), 3),
            vue.createVNode(Select_vue_vue_type_script_setup_true_lang._sfc_main, vue.mergeProps(selectBind.value, {
              modelValue: secondsSelected.value,
              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => secondsSelected.value = $event),
              override: "",
              disabled: _ctx.disabled,
              placeholder: "00",
              "aria-label": _ctx.ariaSelectSecondsLabel,
              "use-html5-validation": false,
              onChange: _cache[5] || (_cache[5] = ($event) => onSecondsChange($event.target.value))
            }), {
              default: vue.withCtx(() => [
                (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(seconds.value, (second) => {
                  return vue.openBlock(), vue.createElementBlock("option", {
                    key: second.value,
                    value: second.value,
                    disabled: isSecondDisabled(second.value)
                  }, vue.toDisplayString(second.label), 9, _hoisted_2);
                }), 128))
              ]),
              _: 1
            }, 16, ["modelValue", "disabled", "aria-label"]),
            vue.createElementVNode("span", {
              class: vue.normalizeClass(vue.unref(separatorClasses))
            }, vue.toDisplayString(vue.unref(secondLiteral)), 3)
          ], 64)) : vue.createCommentVNode("", true),
          !vue.unref(isHourFormat24) ? (vue.openBlock(), vue.createBlock(Select_vue_vue_type_script_setup_true_lang._sfc_main, vue.mergeProps({ key: 1 }, selectBind.value, {
            modelValue: meridienSelected.value,
            "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => meridienSelected.value = $event),
            override: "",
            disabled: _ctx.disabled,
            "use-html5-validation": false,
            onChange: _cache[7] || (_cache[7] = ($event) => onMeridienChange($event.target.value))
          }), {
            default: vue.withCtx(() => [
              (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(vue.unref(meridiens), (meridien) => {
                return vue.openBlock(), vue.createElementBlock("option", {
                  key: meridien,
                  value: meridien,
                  disabled: isMeridienDisabled(meridien)
                }, vue.toDisplayString(meridien), 9, _hoisted_3);
              }), 128))
            ]),
            _: 1
          }, 16, ["modelValue", "disabled"])) : vue.createCommentVNode("", true),
          _ctx.$slots.footer ? (vue.openBlock(), vue.createElementBlock("footer", {
            key: 2,
            class: vue.normalizeClass(vue.unref(footerClasses))
          }, [
            vue.renderSlot(_ctx.$slots, "footer")
          ], 2)) : vue.createCommentVNode("", true)
        ]),
        _: 2
      }, [
        _ctx.$slots.trigger ? {
          name: "trigger",
          fn: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "trigger")
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["active", "value", "max", "min", "step", "root-classes", "dropdown-classes", "box-class", "dtf"]);
    };
  }
});
exports._sfc_main = _sfc_main;
//# sourceMappingURL=Timepicker.vue_vue_type_script_setup_true_lang-wsHVsbzH.cjs.map
