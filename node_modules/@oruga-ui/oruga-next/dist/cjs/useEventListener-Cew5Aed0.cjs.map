{"version":3,"file":"useEventListener-Cew5Aed0.cjs","sources":["../../src/composables/useEventListener.ts"],"sourcesContent":["import {\n    onMounted,\n    watch,\n    getCurrentScope,\n    onScopeDispose,\n    type MaybeRefOrGetter,\n    type Ref,\n    type Component,\n} from \"vue\";\nimport { isObject } from \"@/utils/helpers\";\nimport { unrefElement } from \"./unrefElement\";\n\nexport type EventTarget = Element | Document | Window | Component;\nexport type EventListenerOptions = AddEventListenerOptions & {\n    /** Register event listener immediate or on mounted hook. */\n    immediate?: boolean;\n    /** Trigger when the listener get registered and removed */\n    trigger?: Ref<boolean>;\n};\n\n/**\n * Register DOM events using addEventListener on mounted, and removeEventListener automatically on unmounted.\n * Adaption of {@link  https://vueuse.org/core/useEventListener}\n *\n * @param element DOM element to add the listener to\n * @param event Event name\n * @param handler Event handler function\n * @param options EventListenerOptions\n * @return stop function\n */\nexport function useEventListener(\n    element: MaybeRefOrGetter<EventTarget>,\n    event: string,\n    handler: (evt?: any) => void,\n    options?: EventListenerOptions,\n): () => void {\n    let cleanup: () => void;\n\n    const register = (): void => {\n        if (!element) return;\n\n        const target = unrefElement(element);\n        // create a clone of options, to avoid it being changed reactively on removal\n        const optionsClone = isObject(options) ? { ...options } : options;\n        // register listener with timeout to prevent animation collision\n        setTimeout(() => {\n            target.addEventListener(event, handler, optionsClone);\n            cleanup = (): void => {\n                target.removeEventListener(event, handler, optionsClone);\n            };\n        });\n    };\n\n    let stopWatch: () => void;\n\n    if (typeof options?.trigger !== \"undefined\") {\n        stopWatch = watch(\n            options.trigger,\n            (value) => {\n                // toggle listener\n                if (value) register();\n                else if (typeof cleanup === \"function\") cleanup();\n            },\n            { flush: \"post\" },\n        );\n    }\n\n    if (options?.immediate) register();\n    else if (getCurrentScope()) {\n        // register listener on mount\n        onMounted(() => {\n            if (\n                typeof options?.trigger === \"undefined\" ||\n                options.trigger.value\n            )\n                register();\n        });\n    }\n\n    const stop = (): void => {\n        // remove listener before unmounting\n        if (typeof stopWatch === \"function\") stopWatch();\n        if (typeof cleanup === \"function\") cleanup();\n    };\n\n    if (getCurrentScope()) onScopeDispose(stop);\n\n    return stop;\n}\n"],"names":["unrefElement","isObject","watch","getCurrentScope","onMounted","onScopeDispose"],"mappings":";;;;;AA8BO,SAAS,iBACZ,SACA,OACA,SACA,SACU;AACN,MAAA;AAEJ,QAAM,WAAW,MAAY;AACzB,QAAI,CAAC,QAAS;AAER,UAAA,SAASA,0BAAa,OAAO;AAEnC,UAAM,eAAeC,QAAAA,SAAS,OAAO,IAAI,EAAE,GAAG,YAAY;AAE1D,eAAW,MAAM;AACN,aAAA,iBAAiB,OAAO,SAAS,YAAY;AACpD,gBAAU,MAAY;AACX,eAAA,oBAAoB,OAAO,SAAS,YAAY;AAAA,MAC3D;AAAA,IAAA,CACH;AAAA,EACL;AAEI,MAAA;AAEA,MAAA,QAAO,mCAAS,aAAY,aAAa;AAC7B,gBAAAC,IAAA;AAAA,MACR,QAAQ;AAAA,MACR,CAAC,UAAU;AAEP,YAAI,MAAgB,UAAA;AAAA,iBACX,OAAO,YAAY,WAAoB,SAAA;AAAA,MACpD;AAAA,MACA,EAAE,OAAO,OAAO;AAAA,IACpB;AAAA,EAAA;AAGA,MAAA,mCAAS,UAAoB,UAAA;AAAA,WACxBC,uBAAmB;AAExBC,QAAAA,UAAU,MAAM;AACZ,UACI,QAAO,mCAAS,aAAY,eAC5B,QAAQ,QAAQ;AAEP,iBAAA;AAAA,IAAA,CAChB;AAAA,EAAA;AAGL,QAAM,OAAO,MAAY;AAEjB,QAAA,OAAO,cAAc,WAAsB,WAAA;AAC3C,QAAA,OAAO,YAAY,WAAoB,SAAA;AAAA,EAC/C;AAEI,MAAAD,IAAA,gBAAA,EAAmBE,KAAA,eAAe,IAAI;AAEnC,SAAA;AACX;;"}