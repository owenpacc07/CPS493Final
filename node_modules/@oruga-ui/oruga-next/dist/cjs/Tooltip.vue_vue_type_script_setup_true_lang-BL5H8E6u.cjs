"use strict";
/*! Oruga v0.10.5 | MIT License | github.com/oruga-ui/oruga */
const vue = require("vue");
const PositionWrapper_vue_vue_type_script_setup_true_lang = require("./PositionWrapper.vue_vue_type_script_setup_true_lang-Dv8RXs-d.cjs");
const config = require("./config-DQse3iF9.cjs");
const defineClasses = require("./defineClasses-HOBoThd5.cjs");
const useClickOutside = require("./useClickOutside-Dwq_QtCr.cjs");
const _hoisted_1 = ["id"];
const _sfc_main = /* @__PURE__ */ vue.defineComponent({
  ...{
    isOruga: true,
    name: "OTooltip",
    configField: "tooltip"
  },
  __name: "Tooltip",
  props: /* @__PURE__ */ vue.mergeModels({
    override: { type: Boolean, default: void 0 },
    active: { type: Boolean, default: false },
    label: { default: void 0 },
    variant: { default: () => config.getDefault("tooltip.variant") },
    position: { default: () => config.getDefault("tooltip.position", "auto") },
    always: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    animation: { default: () => config.getDefault("tooltip.animation", "fade") },
    multiline: { type: Boolean, default: false },
    triggerTag: { default: () => config.getDefault("tooltip.triggerTag", "div") },
    triggers: { default: () => config.getDefault("tooltip.triggers", ["hover", "focus"]) },
    delay: { default: void 0 },
    closeable: { type: [Array, Boolean], default: () => config.getDefault("tooltip.closeable", ["escape", "outside", "content"]) },
    teleport: { type: [Boolean, String, Object], default: () => config.getDefault("dropdown.teleport", false) },
    rootClass: {},
    teleportClass: {},
    triggerClass: {},
    contentClass: {},
    positionClass: {},
    variantClass: {},
    multilineClass: {},
    alwaysClass: {},
    arrowClass: {},
    arrowPositionClass: {},
    arrowVariantClass: {}
  }, {
    "active": { type: Boolean, ...{ default: false } },
    "activeModifiers": {}
  }),
  emits: /* @__PURE__ */ vue.mergeModels(["update:active", "close", "open"], ["update:active"]),
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const isActive = vue.useModel(__props, "active");
    vue.watch(isActive, (value) => {
      if (value) emits("open");
      else emits("close");
    });
    const tooltipId = vue.useId();
    const timer = vue.ref();
    const autoPosition = vue.ref(props.position);
    vue.watch(
      () => props.position,
      (v) => autoPosition.value = v
    );
    const contentRef = vue.ref();
    const triggerRef = vue.ref();
    const cancelOptions = vue.computed(
      () => typeof props.closeable === "boolean" ? props.closeable ? ["escape", "outside", "content"] : [] : props.closeable
    );
    if (config.isClient && cancelOptions.value.includes("outside")) {
      useClickOutside.useClickOutside([contentRef, triggerRef], onClickedOutside, {
        trigger: isActive,
        passive: true
      });
    }
    function onClickedOutside() {
      if (!isActive.value || props.always) return;
      if (!cancelOptions.value.includes("outside")) return;
      isActive.value = false;
    }
    function onEscape() {
      if (!isActive.value) return;
      if (!cancelOptions.value.includes("escape")) return;
      isActive.value = false;
    }
    function onClick() {
      if (!props.triggers.includes("click")) return;
      vue.nextTick(() => setTimeout(() => open()));
    }
    function onContextMenu(event) {
      if (!props.triggers.includes("contextmenu")) return;
      event.preventDefault();
      open();
    }
    function onFocus() {
      if (!props.triggers.includes("focus")) return;
      open();
    }
    function onHover() {
      if (!props.triggers.includes("hover")) return;
      open();
    }
    function open() {
      if (props.disabled) return;
      if (props.delay) {
        timer.value = setTimeout(() => {
          isActive.value = true;
          timer.value = null;
        }, props.delay);
      } else {
        isActive.value = true;
      }
    }
    function onClose() {
      if (!cancelOptions.value.includes("content")) return;
      isActive.value = !props.closeable;
      if (timer.value && props.closeable) clearTimeout(timer.value);
    }
    const rootClasses = defineClasses.defineClasses(
      ["rootClass", "o-tooltip"],
      [
        "teleportClass",
        "o-tooltip--teleport",
        null,
        vue.computed(() => !!props.teleport)
      ]
    );
    const triggerClasses = defineClasses.defineClasses(["triggerClass", "o-tooltip__trigger"]);
    const contentClasses = defineClasses.defineClasses(
      ["contentClass", "o-tooltip__content"],
      [
        "positionClass",
        "o-tooltip__content--",
        autoPosition,
        vue.computed(() => !!autoPosition.value)
      ],
      [
        "variantClass",
        "o-tooltip__content--",
        vue.computed(() => props.variant),
        vue.computed(() => !!props.variant)
      ],
      [
        "multilineClass",
        "o-tooltip__content--multiline",
        null,
        vue.computed(() => props.multiline)
      ],
      [
        "alwaysClass",
        "o-tooltip__content--always",
        null,
        vue.computed(() => props.always)
      ]
    );
    const arrowClasses = defineClasses.defineClasses(
      ["arrowClass", "o-tooltip__arrow"],
      [
        "arrowPositionClass",
        "o-tooltip__arrow--",
        autoPosition,
        vue.computed(() => !!autoPosition.value)
      ],
      [
        "arrowVariantClass",
        "o-tooltip__arrow--",
        vue.computed(() => props.variant),
        vue.computed(() => !!props.variant)
      ]
    );
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        "data-oruga": "tooltip",
        class: vue.normalizeClass(vue.unref(rootClasses))
      }, [
        (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.triggerTag), {
          ref_key: "triggerRef",
          ref: triggerRef,
          class: vue.normalizeClass(vue.unref(triggerClasses)),
          "aria-haspopup": "true",
          "aria-describedby": vue.unref(tooltipId),
          onKeydown: vue.withKeys(onEscape, ["escape"]),
          onClick,
          onContextmenu: onContextMenu,
          onMouseenter: onHover,
          onFocusCapture: onFocus,
          onBlurCapture: onClose,
          onMouseleave: onClose
        }, {
          default: vue.withCtx(() => [
            vue.renderSlot(_ctx.$slots, "default", { active: isActive.value })
          ]),
          _: 3
        }, 40, ["class", "aria-describedby"])),
        vue.createVNode(PositionWrapper_vue_vue_type_script_setup_true_lang._sfc_main, {
          position: autoPosition.value,
          "onUpdate:position": _cache[0] || (_cache[0] = ($event) => autoPosition.value = $event),
          teleport: _ctx.teleport,
          class: vue.normalizeClass(vue.unref(rootClasses)),
          trigger: triggerRef.value,
          "default-position": "top",
          disabled: !isActive.value
        }, {
          default: vue.withCtx(({ setContent }) => [
            vue.createVNode(vue.Transition, { name: _ctx.animation }, {
              default: vue.withCtx(() => [
                vue.withDirectives(vue.createElementVNode("div", {
                  id: vue.unref(tooltipId),
                  ref: (el) => contentRef.value = setContent(el),
                  class: vue.normalizeClass(vue.unref(contentClasses)),
                  role: "tooltip"
                }, [
                  vue.createElementVNode("span", {
                    class: vue.normalizeClass(vue.unref(arrowClasses))
                  }, null, 2),
                  vue.renderSlot(_ctx.$slots, "content", {}, () => [
                    vue.createTextVNode(vue.toDisplayString(_ctx.label), 1)
                  ])
                ], 10, _hoisted_1), [
                  [vue.vShow, isActive.value || _ctx.always && !_ctx.disabled]
                ])
              ]),
              _: 2
            }, 1032, ["name"])
          ]),
          _: 3
        }, 8, ["position", "teleport", "class", "trigger", "disabled"])
      ], 2);
    };
  }
});
exports._sfc_main = _sfc_main;
//# sourceMappingURL=Tooltip.vue_vue_type_script_setup_true_lang-BL5H8E6u.cjs.map
