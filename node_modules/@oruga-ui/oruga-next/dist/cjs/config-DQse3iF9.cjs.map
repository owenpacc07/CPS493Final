{"version":3,"file":"config-DQse3iF9.cjs","sources":["../../src/utils/programmatic.ts","../../src/utils/plugins.ts","../../src/utils/ssr.ts","../../src/utils/config.ts"],"sourcesContent":["import { ref } from \"vue\";\n\nexport interface OrugaProgrammatic {\n    [key: string]: Record<string, any>;\n}\n\n/** Oruga object for programmatic components */\nconst oruga = ref<OrugaProgrammatic>({} as OrugaProgrammatic);\n\n/** Add components to the oruga object */\nexport function addProgrammatic(property: string, component: object): void {\n    oruga.value[property] = component;\n}\n\n/** Composable for internal and external usage of programmatic components*/\nexport function useOruga(): OrugaProgrammatic {\n    return oruga.value;\n}\n","import type { App, Component, Plugin, defineComponent } from \"vue\";\nimport { useOruga, addProgrammatic } from \"./programmatic\";\n\nexport let VueInstance: App | undefined;\n\n/** set the global vue instance */\nexport const setVueInstance = (Vue: App): void => {\n    VueInstance = Vue;\n};\n\n/** register a plugin to the vue app instance */\nexport const registerPlugin = (app: App, plugin: Plugin): void => {\n    app.use(plugin);\n};\n\n/** register a component to the vue app instance */\nexport const registerComponent = (\n    app: App,\n    component: ReturnType<typeof defineComponent>, // type Component isn't correct since vue 3.5 any more\n): void => {\n    app.component(component.name, component);\n};\n\n/** register a global programmatic component to the oruga object */\nexport const registerComponentProgrammatic = (\n    app: App,\n    property: string,\n    component: Component,\n): void => {\n    // set global vue instance\n    setVueInstance(app);\n    // use composable for unified access to programmatic oruga object\n    const oruga = useOruga();\n    // add component (manipulates the programmatic oruga object)\n    addProgrammatic(property, component);\n\n    // add provide and $oruga (only needed once)\n    if (!(app._context.provides && app._context.provides.oruga))\n        app.provide(\"oruga\", oruga);\n    if (!app.config.globalProperties.$oruga)\n        app.config.globalProperties.$oruga = oruga;\n};\n","// Polyfills for SSR\n\nexport const isClient = typeof window !== \"undefined\";\nexport const isSSR = typeof window === \"undefined\";\n\nexport const HTMLElement = isSSR ? Object : window.HTMLElement;\nexport const HTMLInputElement = isSSR ? Object : window.HTMLInputElement;\nexport const File = isSSR ? Object : window.File;\n","import { ref, toRaw, type App } from \"vue\";\nimport { getValueByPath, merge, setValueByPath } from \"./helpers\";\nimport { setVueInstance } from \"./plugins\";\nimport { isClient } from \"./ssr\";\nimport type { DeepType, OrugaOptions } from \"@/types\";\n\ndeclare module \"../index\" {\n    interface OrugaProgrammatic {\n        config: typeof ConfigProgrammatic;\n    }\n}\n\nconst globalOptions = ref<OrugaOptions>({\n    iconPack: \"mdi\",\n    useHtml5Validation: true,\n    statusIcon: true,\n    transformClasses: undefined,\n    teleportTarget: () => (isClient ? document.body : \"body\"),\n});\n\nexport const setOptions = (options: OrugaOptions): void => {\n    globalOptions.value = options;\n};\n\nexport const getOptions = (): OrugaOptions => {\n    return Object.assign({}, toRaw(globalOptions.value));\n};\n\nexport const getOption = <K extends keyof OrugaOptions | string>(\n    path: K,\n    defaultValue?: DeepType<OrugaOptions, K>,\n): DeepType<OrugaOptions, K> | undefined => {\n    return getValueByPath(globalOptions.value, path, defaultValue);\n};\n\n/** less type strict version of getOption for component props defaults */\nexport const getDefault = <T>(path: string, defaultValue?: T): T => {\n    return getValueByPath(globalOptions.value, path, defaultValue) as T & {};\n};\n\nexport const setOption = <T>(path: string, value: T): void => {\n    setValueByPath(globalOptions.value, path, value);\n};\n\nexport const ConfigProgrammatic = {\n    getOption,\n    getOptions,\n    setOption,\n    setOptions(options: OrugaOptions): void {\n        setOptions(merge(getOptions(), options, true));\n    },\n};\n\nexport const OrugaConfig = {\n    install(app: App, options?: OrugaOptions): void {\n        // set global vue instance\n        setVueInstance(app);\n        // set options\n        setOptions(merge(getOptions(), options, true));\n    },\n};\n"],"names":["ref","VueInstance","oruga","toRaw","getValueByPath","setValueByPath","merge"],"mappings":";;;;AAOA,MAAM,QAAQA,IAAuB,IAAA,EAAuB;AAG5C,SAAA,gBAAgB,UAAkB,WAAyB;AACjE,QAAA,MAAM,QAAQ,IAAI;AAC5B;AAGO,SAAS,WAA8B;AAC1C,SAAO,MAAM;AACjB;ACdWC,QAAAA,cAAAA;AAGE,MAAA,iBAAiB,CAAC,QAAmB;AAChCA,UAAAA,cAAA;AAClB;AAGa,MAAA,iBAAiB,CAAC,KAAU,WAAyB;AAC9D,MAAI,IAAI,MAAM;AAClB;AAGa,MAAA,oBAAoB,CAC7B,KACA,cACO;AACH,MAAA,UAAU,UAAU,MAAM,SAAS;AAC3C;AAGO,MAAM,gCAAgC,CACzC,KACA,UACA,cACO;AAEP,iBAAe,GAAG;AAElB,QAAMC,SAAQ,SAAS;AAEvB,kBAAgB,UAAU,SAAS;AAGnC,MAAI,EAAE,IAAI,SAAS,YAAY,IAAI,SAAS,SAAS;AAC7C,QAAA,QAAQ,SAASA,MAAK;AAC1B,MAAA,CAAC,IAAI,OAAO,iBAAiB;AACzB,QAAA,OAAO,iBAAiB,SAASA;AAC7C;ACvCa,MAAA,WAAW,OAAO,WAAW;AAC7B,MAAA,QAAQ,OAAO,WAAW;ACSvC,MAAM,gBAAgBF,IAAAA,IAAkB;AAAA,EACpC,UAAU;AAAA,EACV,oBAAoB;AAAA,EACpB,YAAY;AAAA,EACZ,kBAAkB;AAAA,EAClB,gBAAgB,MAAO,WAAW,SAAS,OAAO;AACtD,CAAC;AAEY,MAAA,aAAa,CAAC,YAAgC;AACvD,gBAAc,QAAQ;AAC1B;AAEO,MAAM,aAAa,MAAoB;AAC1C,SAAO,OAAO,OAAO,CAAA,GAAIG,IAAAA,MAAM,cAAc,KAAK,CAAC;AACvD;AAEa,MAAA,YAAY,CACrB,MACA,iBACwC;AACxC,SAAOC,QAAe,eAAA,cAAc,OAAO,MAAM,YAAY;AACjE;AAGa,MAAA,aAAa,CAAI,MAAc,iBAAwB;AAChE,SAAOA,QAAe,eAAA,cAAc,OAAO,MAAM,YAAY;AACjE;AAEa,MAAA,YAAY,CAAI,MAAc,UAAmB;AAC3CC,UAAAA,eAAA,cAAc,OAAO,MAAM,KAAK;AACnD;AAEO,MAAM,qBAAqB;AAAA,EAC9B;AAAA,EACA;AAAA,EACA;AAAA,EACA,WAAW,SAA6B;AACpC,eAAWC,QAAAA,MAAM,WAAc,GAAA,SAAS,IAAI,CAAC;AAAA,EAAA;AAErD;AAEO,MAAM,cAAc;AAAA,EACvB,QAAQ,KAAU,SAA8B;AAE5C,mBAAe,GAAG;AAElB,eAAWA,QAAAA,MAAM,WAAc,GAAA,SAAS,IAAI,CAAC;AAAA,EAAA;AAErD;;;;;;;;;;;;;;"}