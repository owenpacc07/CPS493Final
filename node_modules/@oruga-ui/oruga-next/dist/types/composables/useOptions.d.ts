import { MaybeRefOrGetter } from 'vue';
/**
 * Internal OptionsItem representation object with additional state information.
 *
 * @internal
 */
export type OptionsItem<V = unknown> = OptionsPropItem<V> & {
    /** internal definiton if the element should be hidden */
    hidden?: boolean;
    /** internal genereated uniqe option key */
    key?: string;
};
/**
 * Options should always be formatted as an array of objects with label and value properties.
 *
 * @public
 */
export type OptionsPropItem<V = unknown> = {
    /** displayed option label */
    label: string;
    /** the real option value */
    value: V;
    /** additional attributes bound to the option element */
    attrs?: {
        disabled?: boolean;
    } & Record<string, any>;
    [index: string]: any;
};
/**
 * The types of options that can be passed to the options prop.
 *
 * @public
 */
export type OptionsProp<V = string | number | object> = (string | number)[] | Record<string | number, string> | OptionsPropItem<V>[];
/**
 * Option groups should always be formatted as an array of objects with group and nested options.
 *
 * @internal
 */
export type OptionsGroupItem<V = unknown> = {
    /** displayed option group label */
    label?: string;
    /** the real option group value */
    value?: V;
    /** list of options */
    options: OptionsItem<V>[];
    /** additional attributes bound to the options grouü element */
    attrs?: Record<string, any>;
    /** internal definiton if the element should be hidden */
    hidden?: boolean;
    /** internal genereated uniqe option key */
    key?: string;
};
/**
 * Option groups should always be formatted as an array of objects with group and nested options.
 *
 * @public
 */
export type OptionsGroupPropItem<V = unknown> = {
    /** displayed option group label */
    label?: string;
    /** the real option group value */
    value?: V;
    /** list of options */
    options: OptionsProp<V>;
    /** additional attributes bound to the options grouü element */
    attrs?: Record<string, any>;
};
/**
 * An array of option items with a group support — where the `option` of the
 * groups can be any valid OptionsProp type.
 *
 * @public
 */
export type OptionsGroupProp<V = string | number | object> = OptionsGroupPropItem<V>[];
/**
 * The types of options that can be passed to the options prop.
 * An array of option items with a group support — where the `option` of the
 * groups can be any valid OptionsProp type.
 *
 * @public
 */
export type OptionsPropWithGroups<V = unknown> = OptionsProp<V> | OptionsGroupProp<V>;
/** Normalized external options prop for internal usage */
type NormalizedOptions<V, O extends OptionsPropWithGroups<V> | undefined> = O extends OptionsGroupProp<V> ? OptionsGroupItem<V>[] : O extends OptionsProp<V> ? OptionsItem<V>[] : never[];
/**
 * A function to normalize an array of objects, array of strings, or object of
 * key-values to use an array of objects with value and label properties.
 *
 * @param options - An un-normalized {@link OptionsPropWithGroups}.
 *
 * @returns A list of {@link OptionsItem} | {@link OptionsGroupItem}.
 */
export declare function normalizeOptions<V, O extends OptionsPropWithGroups<V> = OptionsPropWithGroups<V>>(options: O | undefined, uuid: () => string): NormalizedOptions<V, O>;
/**
 * A helper to determine if an option is a group or an option.
 * @param option - An option
 *
 * @returns option is OptionsGroupItem
 */
export declare function isGroupOption(option: Partial<OptionsItem | OptionsGroupItem>): option is OptionsGroupItem;
export declare function toOptionsGroup<V>(options: OptionsItem<V>[] | OptionsGroupItem<V>[], key: string): OptionsGroupItem<V>[];
export declare function toOptionsList<V>(options: MaybeRefOrGetter<OptionsGroupItem<V>[]>): OptionsItem<V>[];
/**
 * Applies an filter function for a list of options {@link OptionsItem | OptionsGroupItem}.
 * Options are filtered by setting the hidden attribute.
 * The options reactivity is not triggered by this.
 * @param options - Options to filter
 * @param filter - filter function
 */
export declare function filterOptionsItems<V>(options: MaybeRefOrGetter<OptionsItem<V>[] | OptionsGroupItem<V>[]>, filter: (option: OptionsItem<V>, index: number) => boolean): void;
/**
 * Checks if no options are given or every existing options are hidden.
 * @param options - A list of {@link OptionsItem | OptionsGroupItem} to check for a given value
 *
 * @returns boolean
 */
export declare function checkOptionsEmpty(options: MaybeRefOrGetter<OptionsItem[] | OptionsGroupItem[]>): boolean;
/**
 * Given an list of {@link OptionsItem | OptionsGroupItem}, find the option item with the given value.
 *
 * @param options - A list of {@link OptionsItem | OptionsGroupItem} to check for a given value
 * @param value - The value to check
 *
 * @returns {@link OptionsItem}
 */
export declare function findOption<V>(options: MaybeRefOrGetter<OptionsItem<V>[]> | MaybeRefOrGetter<OptionsGroupItem<V>[]>, value: MaybeRefOrGetter<V>): OptionsItem<V> | undefined;
/**
 * Given an options list, find the first value.
 * @param options - An options list (with groups)
 */
export declare function firstViableOption<V>(options: MaybeRefOrGetter<OptionsItem<V>[]> | MaybeRefOrGetter<OptionsGroupItem<V>[]>): OptionsItem<V> | undefined;
export declare function isOptionViable(option: MaybeRefOrGetter<OptionsItem>): boolean;
export {};
