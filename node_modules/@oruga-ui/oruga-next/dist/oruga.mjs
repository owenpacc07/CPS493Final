var Yl = Object.defineProperty;
var Wl = (t, l, a) => l in t ? Yl(t, l, { enumerable: !0, configurable: !0, writable: !0, value: a }) : t[l] = a;
var Fa = (t, l, a) => Wl(t, typeof l != "symbol" ? l + "" : l, a);
import { Comment as Kl, Text as Ul, Fragment as ve, ref as ne, toRaw as Xt, toValue as Ae, getCurrentInstance as St, getCurrentScope as Gt, effectScope as ma, onScopeDispose as Ha, watch as be, isRef as Ma, onMounted as st, inject as Na, computed as o, provide as xa, watchEffect as Ot, triggerRef as _t, nextTick as ze, onUnmounted as ea, onBeforeUnmount as ba, defineComponent as Ce, createElementBlock as A, openBlock as p, normalizeStyle as Xe, normalizeClass as N, unref as i, createBlock as se, resolveDynamicComponent as xe, mergeModels as ge, useTemplateRef as Me, useModel as Pe, useAttrs as it, createCommentVNode as Q, withDirectives as Be, mergeProps as fe, vModelDynamic as ql, vModelText as jl, toDisplayString as ce, useId as Le, withKeys as oe, withCtx as de, renderSlot as ae, createTextVNode as Ve, Teleport as ga, createVNode as he, withModifiers as re, Transition as Je, createElementVNode as pe, vShow as Oe, renderList as $e, useSlots as vt, readonly as Xl, vModelCheckbox as Ya, vModelSelect as Gl, createSlots as Vt, resolveComponent as Wa, createApp as Ql, toHandlers as At, onBeforeMount as Jl, normalizeProps as Et, guardReactiveProps as Ht, vModelRadio as Zl, toHandlerKey as _l, TransitionGroup as eo } from "vue";
/*! Oruga v0.10.5 | MIT License | github.com/oruga-ui/oruga */
function to(t) {
  return t < 0 ? -1 : t > 0 ? 1 : 0;
}
const ao = Math.sign || to, ot = (t, l) => (t % l + l) % l, tt = (t) => (t < 10 ? "0" : "") + t;
function Oa(t, l, a) {
  return Math.max(l, Math.min(a, t));
}
const qe = (t) => !!t && typeof t == "object" && !Array.isArray(t), lt = (t) => !!t && t instanceof Date && !isNaN(t.getTime()), ke = (t) => t !== null && typeof t < "u", we = (t) => ke(t) && t !== "false" && t !== !1, kt = (t) => ke(t) ? t : "", Zs = (t, l) => ke(t) ? t : l, wt = (t, l = "px") => ke(t) ? isNaN(t) ? String(t) : String(t) + l : void 0;
function lo(t, l, a, e = !1, s = !1) {
  return a && typeof a == "function" ? (s ? t : [...t]).sort((d, g) => a(d, g, e)) : (s ? t : [...t]).sort((d, g) => {
    let u = qe(d) ? Ye(d, l) : d, c = qe(g) ? Ye(g, l) : g;
    return typeof u == "boolean" && typeof c == "boolean" ? e ? u > c ? 1 : -1 : u > c ? -1 : 1 : !u && u !== 0 ? 1 : !c && c !== 0 ? -1 : u === c ? 0 : (u = typeof u == "string" ? u.toUpperCase() : u, c = typeof c == "string" ? c.toUpperCase() : c, e ? u > c ? 1 : -1 : u > c ? -1 : 1);
  });
}
function Qt(t, l) {
  if (!t && l || t && !l) return !1;
  if (t === l) return !0;
  if (qe(t) && qe(l)) {
    const a = Object.keys(t), e = Object.keys(l);
    if (a.length !== e.length) return !1;
    for (const s of a) {
      const d = t[s], g = l[s], u = qe(d) && qe(g);
      if (u && !Qt(d, g) || !u && d !== g)
        return !1;
    }
    return !0;
  }
  return Array.isArray(t) && Array.isArray(l) ? !(t.length !== l.length || !t.every((a, e) => a === l[e])) : !1;
}
function _s(t) {
  return typeof HTMLElement == "object" ? t instanceof HTMLElement : t && typeof t == "object" && t !== null && t.nodeType === 1 && typeof t.nodeName == "string";
}
function ia(t, l, a) {
  if (!t) return "";
  const e = l ? Ye(t, l) : t, s = typeof a == "function" ? a(e, t) : e;
  return String(s || "");
}
function ya(t, l, a = !1) {
  return !qe(t) || !qe(l) ? l : a ? Ka(t, l) : Object.assign(t, l);
}
function Ka(t, l) {
  return !qe(t) || !qe(l) ? l : (Object.getOwnPropertyNames(l).forEach((a) => {
    const e = t[a], s = l[a];
    Array.isArray(e) && Array.isArray(s) ? t[a] = e.concat(s) : qe(e) && qe(s) ? t[a] = Ka(
      Object.assign({}, e),
      s
    ) : t[a] = s;
  }), t);
}
function Ye(t, l, a) {
  if (!t || typeof t != "object" || typeof l != "string")
    return a;
  const e = l.split(".").reduce((s, d) => typeof s < "u" ? s[d] : void 0, t);
  return typeof e < "u" ? e : a;
}
function Ua(t, l, a) {
  const e = l.split(".");
  if (e.length === 1) {
    t[l] = a;
    return;
  }
  const s = e[0];
  return typeof t[s] > "u" && (t[s] = {}), Ua(t[s], e.slice(1).join("."), a);
}
function ei(t) {
  typeof t.remove < "u" ? t.remove() : typeof t.parentNode < "u" && t.parentNode !== null && t.parentNode.removeChild(t);
}
function oo(t) {
  return t && t.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
function Va(t) {
  return t && t.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}
function qa(t) {
  return !!(!t || t.type === Kl || t.type === Ul && !t.children.trim() || t.type === ve && qa(t.children));
}
const ct = {
  Android: () => typeof window < "u" && !!window.navigator.userAgent.match(/Android/i),
  BlackBerry: () => typeof window < "u" && !!window.navigator.userAgent.match(/BlackBerry/i),
  iOS: () => typeof window < "u" && !!window.navigator.userAgent.match(/iPhone|iPad|iPod/i),
  Opera: () => typeof window < "u" && !!window.navigator.userAgent.match(/Opera Mini/i),
  Windows: () => typeof window < "u" && !!window.navigator.userAgent.match(/IEMobile/i),
  any: () => ct.Android() || ct.BlackBerry() || ct.iOS() || ct.Opera() || ct.Windows()
}, ja = ne({});
function no(t, l) {
  ja.value[t] = l;
}
function so() {
  return ja.value;
}
let pa;
const Xa = (t) => {
  pa = t;
}, io = (t, l) => {
  t.use(l);
}, Ie = (t, l) => {
  t.component(l.name, l);
}, $t = (t, l, a) => {
  Xa(t);
  const e = so();
  no(l, a), t._context.provides && t._context.provides.oruga || t.provide("oruga", e), t.config.globalProperties.$oruga || (t.config.globalProperties.$oruga = e);
}, Ee = typeof window < "u", Ga = typeof window > "u", zt = ne({
  iconPack: "mdi",
  useHtml5Validation: !0,
  statusIcon: !0,
  transformClasses: void 0,
  teleportTarget: () => Ee ? document.body : "body"
}), Qa = (t) => {
  zt.value = t;
}, Jt = () => Object.assign({}, Xt(zt.value)), nt = (t, l) => Ye(zt.value, t, l), n = (t, l) => Ye(zt.value, t, l), ro = (t, l) => {
  Ua(zt.value, t, l);
}, uo = {
  getOption: nt,
  getOptions: Jt,
  setOption: ro,
  setOptions(t) {
    Qa(ya(Jt(), t, !0));
  }
}, co = {
  install(t, l) {
    Xa(t), Qa(ya(Jt(), l, !0));
  }
}, fo = {
  sizes: {
    default: "mdi-24px",
    small: "",
    medium: "mdi-36px",
    large: "mdi-48px"
  },
  iconPrefix: "mdi-"
}, ht = () => {
  const l = nt("iconComponent") ? "" : "fa-";
  return {
    sizes: {
      default: "",
      small: "sm",
      medium: "lg",
      large: "xl"
    },
    iconPrefix: l,
    internalIcons: {
      check: "check",
      information: "info-circle",
      alert: "exclamation-triangle",
      "alert-circle": "exclamation-circle",
      "arrow-up": "arrow-up",
      "chevron-right": "angle-right",
      "chevron-left": "angle-left",
      "chevron-down": "angle-down",
      "chevron-up": "angle-up",
      eye: "eye",
      "eye-off": "eye-slash",
      "caret-down": "caret-down",
      "caret-up": "caret-up",
      "close-circle": "times-circle",
      close: "times",
      loading: "circle-notch",
      "emoticon-sad": "frown"
    }
  };
}, po = () => {
  let t = {
    mdi: fo,
    fa: ht(),
    fas: ht(),
    far: ht(),
    fad: ht(),
    fab: ht(),
    fal: ht()
  };
  const l = nt("customIconPacks");
  return l && (t = ya(t, l, !0)), t;
};
function We(t) {
  const l = Ae(t);
  return (l == null ? void 0 : l.$el) ?? l;
}
function Aa(t) {
  const l = Ae(t);
  return typeof l == "string" ? document.querySelector(l) : We(l);
}
const Ke = (t) => {
  const l = Ae(t);
  return l ? l.flatMap(
    (a) => Object.keys(a).filter((e) => e && a[e]).flatMap((e) => e.split(" "))
  ) : [];
};
function M(...t) {
  const l = Array.isArray(t.at(-1)) ? void 0 : t.at(-1), a = Array.isArray(t.at(-1)) ? t : t.slice(0, -1), e = St();
  if (!e)
    throw new Error(
      "defineClasses must be called within a component setup function."
    );
  if (!Gt() && !(l != null && l.scope))
    throw new Error(
      "defineClasses must be called within a current active effect scope."
    );
  const s = (l == null ? void 0 : l.scope) || ma();
  Gt() && Ha(() => {
    s && s.stop();
  });
  const d = ne([]);
  return d.value = a.map((g, u) => {
    const c = g[0], y = g[1], f = g[2], v = g[3];
    function I() {
      const C = vo(
        e,
        c,
        y,
        Ae(f) || void 0
      ), B = !ke(v) || Ae(v);
      return { [C]: B };
    }
    return s.run(() => {
      be(
        [
          () => {
            var C;
            return (C = e.proxy) == null ? void 0 : C.$props[c];
          },
          () => l != null && l.props ? l == null ? void 0 : l.props[c] : null
        ],
        () => {
          const C = I();
          d.value[u] = C;
        }
      ), ke(f) && Ma(f) && be(f, (C, B) => {
        if (C === B) return;
        const P = I();
        d.value[u] = P;
      }), ke(v) && Ma(v) && be(v, (C, B) => {
        if (C === B) return;
        const P = d.value[u];
        Object.keys(P).forEach(
          (h) => P[h] = C
        ), d.value[u] = P;
      });
    }), I();
  }), d;
}
function vo(t, l, a, e = "") {
  var P;
  const s = ra(t), d = (P = t.proxy) == null ? void 0 : P.$options.configField;
  if (!d)
    throw new Error("component must define the 'configField' option.");
  const g = s.override === !0 ? {} : Jt();
  let u = Ye(
    g,
    `${d}.${l}.class`,
    ""
  ) || Ye(
    g,
    `${d}.${l}`,
    ""
  ), c = Ye(
    s,
    l,
    ""
  );
  if (Array.isArray(c) && (c = c.join(" ")), typeof c == "function") {
    const h = ra(t);
    c = c(e, h);
  } else
    c = za(c, e);
  if (Array.isArray(u) && (u = u.join(" ")), typeof u == "function") {
    const h = ra(t);
    u = u(e, h);
  } else
    u = za(u, e);
  a.includes("{*}") ? a = a.replace(
    /\{\*\}/g,
    kt(e)
  ) : a = a + kt(e);
  const y = s.override || Ye(g, "override", !1), f = Ye(
    g,
    `${d}.override`,
    y
  );
  let I = `${Ye(
    g,
    `${d}.${l}.override`,
    f
  ) ? "" : a} ${kt(u)} ${kt(c)}`.trim().replace(/\s\s+/g, " ");
  const C = Ye(
    g,
    "transformClasses",
    void 0
  ), B = Ye(
    g,
    `${d}.transformClasses`,
    void 0
  );
  return B ? I = B(I) : C && (I = C(I)), I;
}
function za(t, l) {
  return kt(t).split(" ").filter((a) => a.length > 0).map((a) => a + kt(l)).join(" ");
}
const ra = (t) => {
  var a;
  let l = ((a = t.proxy) == null ? void 0 : a.$props) || {};
  return l = Object.keys(l).filter((e) => e.endsWith("Props")).map((e) => l[e]).reduce((e, s) => ({ ...e, ...s }), l), l;
};
function mt(t, l, a, e) {
  let s;
  const d = () => {
    if (!t) return;
    const c = We(t), y = qe(e) ? { ...e } : e;
    setTimeout(() => {
      c.addEventListener(l, a, y), s = () => {
        c.removeEventListener(l, a, y);
      };
    });
  };
  let g;
  typeof (e == null ? void 0 : e.trigger) < "u" && (g = be(
    e.trigger,
    (c) => {
      c ? d() : typeof s == "function" && s();
    },
    { flush: "post" }
  )), e != null && e.immediate ? d() : Gt() && st(() => {
    (typeof (e == null ? void 0 : e.trigger) > "u" || e.trigger.value) && d();
  });
  const u = () => {
    typeof g == "function" && g(), typeof s == "function" && s();
  };
  return Gt() && Ha(u), u;
}
function rt(t) {
  var c;
  const l = ne(!1), a = ne(), e = St();
  if (!e)
    throw new Error(
      "useMatchMedia must be called within a component setup function."
    );
  const s = e.props, d = (c = e.proxy) == null ? void 0 : c.$options.configField;
  if (!d)
    throw new Error("component must define the 'configField' option.");
  let g = s.mobileBreakpoint;
  if (!g) {
    const y = nt(
      "mobileBreakpoint",
      t || "1023px"
    );
    g = nt(`${d}.mobileBreakpoint`, y);
  }
  a.value = Ee ? window.matchMedia(`(max-width: ${g})`) : void 0, a.value ? (l.value = a.value.matches, mt(a.value, "change", u)) : l.value = !1;
  function u(y) {
    l.value = y.matches;
  }
  return { isMobile: l };
}
const Ja = Symbol("FielData");
function mo(t) {
  xa(Ja, t);
}
function Ge() {
  const t = Na(
    Ja,
    o(() => {
    })
  ), l = o(() => {
    var d;
    if ((d = t == null ? void 0 : t.value) != null && d.message)
      return t == null ? void 0 : t.value.message;
  }), a = o(() => {
    var d;
    if ((d = t == null ? void 0 : t.value) != null && d.variant) {
      if (typeof t.value.variant == "string")
        return t.value.variant;
      if (Array.isArray(t.value.variant)) {
        for (const g in t.value.variant)
          if (t.value.variant[g]) return g;
      }
    }
  }), e = nt("statusVariantIcon", {
    success: "check",
    danger: "alert-circle",
    info: "information",
    warning: "alert"
  }), s = o(() => !a.value || !e ? "" : e[a.value] || "");
  return {
    parentField: t,
    statusVariant: a,
    statusVariantIcon: s,
    statusMessage: l
  };
}
const bo = Ga ? [] : [
  HTMLButtonElement,
  HTMLFieldSetElement,
  HTMLInputElement,
  HTMLObjectElement,
  HTMLOutputElement,
  HTMLSelectElement,
  HTMLTextAreaElement
];
function Ta(t) {
  return bo.some((l) => t instanceof l) ? t : null;
}
const go = [
  "disabled",
  "required",
  "pattern",
  "maxlength",
  "minlength",
  "max",
  "min",
  "step"
];
function et(t, l, a) {
  const { parentField: e } = Ge(), s = o(() => {
    const h = We(t);
    if (!h) return;
    if (h.getAttribute("data-oruga-input"))
      return h;
    const z = h.querySelector("[data-oruga-input]");
    if (!z) {
      console.warn(
        "useInputHandler: Underlaying Oruga input component not found"
      );
      return;
    }
    return z;
  }), d = o(() => {
    const h = s.value;
    return h || console.warn("useInputHandler: inputRef contains no element"), h;
  }), g = ne(!1);
  function u() {
    ze(() => {
      d.value && d.value.focus();
    });
  }
  function c() {
    ze(() => {
      d.value && d.value.click();
    });
  }
  function y(h) {
    g.value = !1, e != null && e.value && e.value.setFocus(!1), l("blur", h || new Event("blur")), C();
  }
  function f(h) {
    g.value = !0, e != null && e.value && e.value.setFocus(!0), l("focus", h || new Event("focus"));
  }
  const v = ne(!0);
  function I(h, z) {
    ze(() => {
      e != null && e.value && (e.value.props.variant || e.value.setVariant(h), e.value.props.message || e.value.setMessage(z));
    });
  }
  function C() {
    a.useHtml5Validation && d.value && (d.value.validity.valid ? (I(null, null), v.value = !0) : (B(), v.value = !1));
  }
  function B() {
    var F;
    const h = "danger", z = (F = d.value) == null ? void 0 : F.validationMessage;
    I(h, z);
  }
  function P(h) {
    C();
    const z = Ta(h.target);
    if (z && (e != null && e.value) && a.useHtml5Validation) {
      h.preventDefault();
      let F = !1;
      if (z.form != null) {
        const O = z.form.elements;
        for (let K = 0; K < O.length; ++K) {
          const U = Ta(
            O.item(K)
          );
          if (U != null && U.willValidate && !U.validity.valid) {
            F = z === U;
            break;
          }
        }
      }
      if (F) {
        const O = e.value.$el, K = nt("invalidHandler");
        if (!O) return;
        if (K instanceof Function)
          K(z, O);
        else {
          const U = O ? O.scrollIntoView != null : !1;
          z.focus({ preventScroll: U }), U && O.scrollIntoView({ block: "nearest" });
        }
      }
    }
    l("invalid", h);
  }
  if (!Ga) {
    const h = ne(null);
    Ot(() => {
      if (h.value, !(a.useHtml5Validation ?? !0)) return;
      const O = s.value;
      if (!ke(O)) return;
      const K = a.customValidity ?? "";
      typeof K == "string" ? O.setCustomValidity(K) : O.setCustomValidity(
        K(a.modelValue, O.validity)
      ), v.value || C();
    }), be(
      [s, () => a.useHtml5Validation ?? !0],
      (O, K) => {
        const U = O[0], S = O[1], T = K[0], w = K[1];
        U !== T ? T == null || T.setCustomValidity("") : w && !S && (U == null || U.setCustomValidity(""));
      }
    );
    const z = () => {
      _t(h);
    };
    let F = null;
    be(
      [
        s,
        v,
        () => a.useHtml5Validation ?? !0,
        () => a.customValidity
      ],
      (O, K) => {
        const U = O[0], S = O[1], T = O[2], w = O[3] instanceof Function, V = K[0], $ = ke(U) && T && // For inputs known to be invalid, changes in constraint validation properties
        // may make it so the field is now valid and the message needs to be hidden.
        // For browser-implemented constraint validation (e.g. the `required` attribute),
        // we just care about the message displayed to the user, which is hidden for valid inputs
        // until the next interaction with the control.
        (!S || // For inputs with complex custom validation, any changes to validation-related attributes
        // may affect the results of `props.customValidity`.
        w);
        if ((!$ || U !== V) && F != null && (F.takeRecords().length > 0 && z(), F.disconnect()), $ && ke(U) && U !== V) {
          F == null && (F = new MutationObserver(
            z
          )), F.observe(U, {
            attributeFilter: go
          });
          let Y = U;
          for (; Y = Y.parentNode; )
            Y instanceof HTMLFieldSetElement && F.observe(Y, {
              attributeFilter: ["disabled"]
            });
        }
      }
    );
  }
  return {
    input: d,
    isFocused: g,
    isValid: v,
    setFocus: u,
    doClick: c,
    onFocus: f,
    onBlur: y,
    onInvalid: P,
    checkHtml5Validity: C
  };
}
function Ca(t, l, a) {
  let e;
  return (...s) => {
    const d = () => {
      e = void 0, t.apply(this, s);
    };
    e && clearTimeout(e), e = setTimeout(d, l);
  };
}
function ut(t = 0) {
  let l = t;
  function a() {
    return String(l++);
  }
  return {
    nextSequence: a,
    sequence: l
  };
}
function bt(t) {
  var c;
  const l = St();
  if (!l)
    throw new Error(
      "useProviderChild must be called within a component setup function."
    );
  const a = (c = l.proxy) == null ? void 0 : c.$options.configField, e = (t == null ? void 0 : t.key) || a, s = ne([]);
  if (t != null && t.rootRef) {
    const y = Ca((f) => {
      const v = We(t.rootRef);
      if (!v) return;
      const I = f.map((P) => `[data-id="${e}-${P.identifier}"]`).join(","), C = v.querySelectorAll(I), B = Array.from(C).map(
        (P) => {
          var h;
          return (h = P.getAttribute("data-id")) == null ? void 0 : h.replace(`${e}-`, "");
        }
      );
      f.forEach(
        (P) => P.index = B.indexOf(`${P.identifier}`)
      ), f.sort((P, h) => P.index - h.index);
    }, 500);
    be(s, y);
  }
  const { nextSequence: d } = ut(1);
  function g(y) {
    const f = s.value.length, v = d(), I = { index: f, data: y, identifier: v };
    return s.value = [
      ...s.value,
      I
    ], I;
  }
  function u(y) {
    s.value = s.value.filter((f) => f !== y);
  }
  return xa("$o-" + e, {
    registerItem: g,
    unregisterItem: u,
    data: t == null ? void 0 : t.data
  }), {
    childItems: s
  };
}
function pt(t) {
  var u, c;
  t = Object.assign({ needParent: !0, register: !0 }, t);
  const l = St();
  if (!l)
    throw new Error(
      "useProviderChild must be called within a component setup function."
    );
  const a = (u = l.proxy) == null ? void 0 : u.$options.configField, e = (t == null ? void 0 : t.key) || a, s = Na("$o-" + e, void 0);
  if (t.needParent && !s)
    throw new Error(
      `You should wrap ${(c = l.proxy) == null ? void 0 : c.$options.name} in a ${e} component`
    );
  const d = ne();
  return s && t.register && (d.value = s.registerItem(
    t == null ? void 0 : t.data
  )), ea(() => {
    s && d.value && s.unregisterItem(d.value);
  }), { parent: (s == null ? void 0 : s.data) || ne(), item: d };
}
function ta(t, l, a) {
  if (!window) return () => {
  };
  const e = Object.assign({ ignore: [] }, a), s = Array.isArray(t) ? t : [t], d = (c) => s.some((y) => {
    if (typeof y == "string")
      return Array.from(
        window.document.querySelectorAll(y)
      ).some(
        (f) => f === c.target || c.composedPath().includes(f)
      );
    {
      const f = We(y);
      return f && (c.target === f || c.composedPath().includes(f));
    }
  });
  function g(c) {
    d(c) || l(c);
  }
  return mt(window, "click", g, e);
}
function yo(t) {
  if (t.style.position === "fixed" || !t)
    return document.documentElement;
  let l = !1, a = t.parentElement;
  for (; !l && ke(a) && a !== document.documentElement; ) {
    const { overflow: e, overflowY: s } = getComputedStyle(a), { scrollHeight: d, clientHeight: g } = a;
    if (l = /(auto|scroll)/.test(`${e}${s}`) && d > g, l) break;
    a = a.parentElement;
  }
  return a;
}
function dt(t, l) {
  return t ? Array.isArray(t) ? t.map(
    (a) => {
      if (typeof a == "string" || typeof a == "number")
        return {
          label: String(a),
          value: String(a),
          key: l()
        };
      if (typeof a == "object") {
        if ("options" in a) {
          const e = dt(a.options, l);
          return {
            ...a,
            options: e,
            key: l()
          };
        } else if ("value" in a)
          return {
            ...a,
            key: l()
          };
      }
      return a;
    }
  ) : Object.keys(t).map(
    (a) => ({
      // create option from object key/value
      label: t[a],
      value: a,
      key: l()
    })
  ) : [];
}
function Bt(t) {
  return t && typeof t == "object" && Array.isArray(t.options);
}
function ha(t, l) {
  return Array.isArray(t) ? t.some((e) => Bt(e)) ? [...t] : [{ options: t, key: l }] : [];
}
function Co(t) {
  return Array.isArray(Ae(t)) ? Ae(t).reduce((l, a) => (l.push(...a.options), l), []) : [];
}
function ka(t, l) {
  Ae(t).forEach(
    (a, e) => {
      Bt(a) ? (ka(a.options, l), a.hidden = a.options.every((s) => s.hidden)) : a.hidden = l(a, e);
    }
  );
}
function Za(t) {
  return Array.isArray(Ae(t)) ? Ae(t).every((l) => Bt(l) ? Za(l.options) : !_a(l)) : !0;
}
function Zt(t, l) {
  if (Array.isArray(Ae(t))) {
    for (const a of Ae(t))
      if (!(typeof a != "object" && a)) {
        if (Bt(a)) {
          const e = Zt(a.options, l);
          if (e !== void 0) return e;
        } else if (Qt(Ae(l), a.value)) return a;
      }
  }
}
function _a(t) {
  var l;
  return !Ae(t).hidden && !((l = Ae(t).attrs) != null && l.disabled);
}
function aa(t) {
  const l = M([
    "scrollClipClass",
    "o-scroll-clip"
  ]), a = M([
    "scrollKeepClass",
    "o-scroll-keep"
  ]), e = o(
    () => Ke(
      Ae(t) ? l.value : a.value
    )
  ), s = ne();
  ba(() => d(!1));
  function d(g) {
    Ee && e.value && (s.value = s.value ? s.value : document.documentElement.scrollTop, g ? document.body.classList.add(...e.value) : document.body.classList.remove(...e.value), Ae(t) || (g ? document.body.style.top = `-${s.value}px` : (document.documentElement.scrollTop = s.value, document.body.style.top = "", s.value = void 0)));
  }
  return d;
}
function la() {
  const t = nt("teleportTarget", "body");
  return Ae(t);
}
function ho(t) {
  return t ? t.querySelectorAll(`a[href]:not([tabindex="-1"]),
                                 area[href],
                                 input:not([disabled]):not([type="hidden"]),
                                 select:not([disabled]),
                                 textarea:not([disabled]),
                                 button:not([disabled]),
                                 iframe,
                                 object,
                                 embed,
                                 *[tabindex]:not([tabindex="-1"]):not([disabled]),
                                 *[contenteditable]`) : null;
}
function el() {
  let t = null;
  function l(d, g) {
    g ? (d.focus({ preventScroll: !0 }), typeof t == "function" && d.addEventListener("keydown", t)) : typeof t == "function" && d.removeEventListener("keydown", t);
  }
  return {
    vTrapFocus: {
      mounted: (d, { value: g }) => {
        t = (u) => {
          const c = u.target;
          if (!c) return;
          const y = ho(d);
          if (!(y != null && y.length)) return;
          const f = y[0], v = y[y.length - 1];
          c === f && u.shiftKey && u.key === "Tab" ? (u.preventDefault(), v.focus()) : c === v && !u.shiftKey && u.key === "Tab" && (u.preventDefault(), f.focus());
        }, l(d, g);
      },
      beforeUnmount: (d) => {
        l(d, !1), t = null;
      },
      updated: (d, { value: g }) => {
        l(d, g);
      }
    }
  };
}
const Te = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OIcon",
  configField: "icon",
  __name: "Icon",
  props: {
    override: { type: Boolean, default: void 0 },
    icon: { default: void 0 },
    component: { default: () => n("iconComponent") },
    pack: { default: () => n("iconPack", "mdi") },
    variant: { default: () => n("icon.variant") },
    size: { default: () => n("icon.size") },
    customSize: { default: void 0 },
    customClass: { default: void 0 },
    clickable: { type: Boolean, default: !1 },
    spin: { type: Boolean, default: !1 },
    rotation: { default: void 0 },
    both: { type: Boolean, default: !1 },
    rootClass: {},
    sizeClass: {},
    variantClass: {},
    clickableClass: {},
    spinClass: {}
  },
  setup(t) {
    const l = t, a = o(() => {
      const v = {};
      return l.rotation && (v.transform = `rotate(${l.rotation}deg)`), v;
    }), e = o(() => po()[l.pack]), s = o(
      () => {
        var v;
        return (v = e.value) != null && v.iconPrefix ? e.value.iconPrefix : "";
      }
    ), d = o(() => {
      var v;
      if ((v = e.value) != null && v.sizes) {
        if (l.size && e.value.sizes[l.size] !== void 0)
          return e.value.sizes[l.size];
        if (e.value.sizes.default)
          return e.value.sizes.default;
      }
      return null;
    }), g = o(
      () => `${s.value}${y(l.icon)}`
    ), u = o(() => l.customSize || d.value), c = o(() => {
      if (!l.variant) return;
      let v = "";
      return typeof l.variant == "string" ? v = l.variant : v = Object.keys(l.variant).filter(
        (I) => l.variant[I]
      )[0], v;
    });
    function y(v) {
      var I, C;
      return l.both && (I = e.value) != null && I.internalIcons && (C = e.value) != null && C.internalIcons[v] ? e.value.internalIcons[v] : v;
    }
    const f = M(
      ["rootClass", "o-icon"],
      [
        "clickableClass",
        "o-icon--clickable",
        null,
        o(() => l.clickable)
      ],
      ["spinClass", "o-icon--spin", null, o(() => l.spin)],
      [
        "sizeClass",
        "o-icon--",
        o(() => l.size),
        o(() => !!l.size)
      ],
      [
        "variantClass",
        "o-icon--",
        c,
        o(() => !!c.value)
      ]
    );
    return (v, I) => (p(), A("span", {
      "data-oruga": "icon",
      class: N(i(f)),
      style: Xe(a.value)
    }, [
      v.component ? (p(), se(xe(v.component), {
        key: 0,
        icon: [v.pack, g.value],
        size: u.value,
        class: N([v.customClass])
      }, null, 8, ["icon", "size", "class"])) : (p(), A("i", {
        key: 1,
        class: N([v.pack, g.value, u.value, v.customClass])
      }, null, 2))
    ], 6));
  }
}), ko = ["id", "type", "data-oruga-input", "maxlength", "autocomplete", "placeholder", "disabled"], wo = ["id", "maxlength", "placeholder", "disabled"], Pt = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OInput",
  configField: "input",
  inheritAttrs: !1,
  __name: "Input",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    number: {},
    type: { default: "text" },
    size: { default: () => n("input.size") },
    variant: { default: () => n("input.variant") },
    placeholder: { default: void 0 },
    expanded: { type: Boolean, default: !1 },
    rounded: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    passwordReveal: { type: Boolean, default: !1 },
    maxlength: { default: void 0 },
    counter: { type: Boolean, default: () => n("input.counter", !1) },
    autosize: { type: Boolean, default: !1 },
    iconPack: { default: () => n("input.iconPack") },
    icon: { default: () => n("input.icon") },
    iconClickable: { type: Boolean, default: !1 },
    iconRight: { default: () => n("input.iconRight") },
    iconRightClickable: { type: Boolean, default: !1 },
    iconRightVariant: { default: void 0 },
    clearable: { type: Boolean, default: () => n("input.clearable", !1) },
    clearIcon: { default: () => n("input.clearIcon", "close-circle") },
    statusIcon: { type: Boolean, default: () => n("statusIcon", !0) },
    debounce: { default: () => n("autocomplete.debounce", 400) },
    autocomplete: { default: () => n("input.autocomplete", "off") },
    id: { default: () => Le() },
    useHtml5Validation: { type: Boolean, default: () => n("useHtml5Validation", !0) },
    customValidity: { type: [String, Function], default: "" },
    rootClass: {},
    sizeClass: {},
    variantClass: {},
    expandedClass: {},
    roundedClass: {},
    disabledClass: {},
    textareaClass: {},
    hasIconRightClass: {},
    inputClass: {},
    iconLeftSpaceClass: {},
    iconRightSpaceClass: {},
    placeholderClass: {},
    iconLeftClass: {},
    iconRightClass: {},
    counterClass: {}
  }, {
    modelValue: {
      // cast incomming value to string
      default: void 0
    },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:model-value", "input", "focus", "blur", "invalid", "icon-click", "icon-right-click"], ["update:modelValue"]),
  setup(t, { expose: l, emit: a }) {
    var J;
    const e = t, s = a, d = Me("inputElement"), {
      checkHtml5Validity: g,
      onBlur: u,
      onFocus: c,
      onInvalid: y,
      setFocus: f,
      isValid: v,
      isFocused: I
    } = et(d, s, e), { parentField: C, statusVariant: B, statusVariantIcon: P } = Ge(), h = Pe(t, "modelValue", {
      // cast incomming value to string
      get: (j) => ke(j) ? String(j) : "",
      // cast outgoing value to number if prop number is true
      set: (j) => ke(j) ? we(e.number) ? Number(j) : String(j) : j
    });
    e.id && ((J = C == null ? void 0 : C.value) == null || J.setInputId(e.id));
    const z = o(
      () => typeof h.value == "string" || typeof h.value == "number" ? String(h.value).length : 0
    );
    st(() => {
      be(
        () => h.value,
        (j) => {
          C != null && C.value && C.value.setFilled(!!j), e.autosize && O(), v.value || g();
        },
        { immediate: !0, flush: "post" }
      );
    });
    const F = ne("auto");
    function O() {
      F.value = "auto", ze(() => {
        if (e.type !== "textarea" || !d.value) return;
        const j = d.value.scrollHeight;
        F.value = j + "px";
      });
    }
    const K = o(
      () => e.type === "textarea" && e.autosize ? {
        resize: "none",
        height: F.value,
        overflow: "hidden"
      } : {}
    );
    let U;
    be(
      () => e.debounce,
      (j) => U = Ca(S, j || 0),
      { immediate: !0 }
    );
    function S(j) {
      s("input", h.value, j);
    }
    const T = o(
      () => !ke(h.value) || h.value === ""
    ), w = o(() => !!(e.passwordReveal || e.statusIcon && P.value || e.clearable && h.value && e.clearIcon || e.iconRight)), V = o(() => e.passwordReveal ? q.value : e.clearable && h.value && e.clearIcon ? e.clearIcon : e.iconRight ? e.iconRight : P.value), $ = o(
      () => e.passwordReveal || e.iconRight ? e.iconRightVariant || e.variant : B.value
    );
    function Y(j) {
      s("icon-click", j), ze(() => f());
    }
    function E(j) {
      e.passwordReveal ? k() : e.clearable && (h.value = we(e.number) ? 0 : ""), e.iconRightClickable && (s("icon-right-click", j), ze(() => f()));
    }
    const Z = ne(!1), _ = o(() => e.passwordReveal ? Z.value ? "text" : "password" : e.type), q = o(
      () => Z.value ? "eye-off" : "eye"
    );
    function k() {
      Z.value = !Z.value, ze(() => f());
    }
    const r = it(), m = o(() => {
      var j;
      return {
        ...(j = C == null ? void 0 : C.value) == null ? void 0 : j.inputAttrs,
        ...r
      };
    }), R = M(
      ["rootClass", "o-input"],
      [
        "sizeClass",
        "o-input--",
        o(() => e.size),
        o(() => !!e.size)
      ],
      [
        "variantClass",
        "o-input--",
        o(() => B.value || e.variant),
        o(() => !!B.value || !!e.variant)
      ],
      [
        "expandedClass",
        "o-input--expanded",
        null,
        o(() => e.expanded)
      ],
      [
        "disabledClass",
        "o-input--disabled",
        null,
        o(() => e.disabled)
      ],
      ["roundedClass", "o-input--rounded", null, o(() => e.rounded)],
      ["hasIconRightClass", "o-input--icon-right", null, w],
      [
        "textareaClass",
        "o-input--textarea",
        null,
        o(() => e.type === "textarea")
      ]
    ), L = M(
      ["inputClass", "o-input__input"],
      [
        "iconLeftSpaceClass",
        "o-input__input--iconspace-left",
        null,
        o(() => !!e.icon)
      ],
      [
        "iconRightSpaceClass",
        "o-input__input--iconspace-right",
        null,
        w
      ],
      [
        "placeholderClass",
        "o-input__input--placeholder",
        null,
        T
      ]
    ), te = M(["iconLeftClass", "o-input__icon-left"]), W = M([
      "iconRightClass",
      "o-input__icon-right"
    ]), H = M(["counterClass", "o-input__counter"]);
    return l({ focus: f, value: h }), (j, ye) => (p(), A("div", {
      "data-oruga": "input",
      class: N(i(R))
    }, [
      j.icon ? (p(), se(Te, {
        key: 0,
        class: N(i(te)),
        clickable: j.iconClickable,
        icon: j.icon,
        pack: j.iconPack,
        size: j.size,
        onClick: Y
      }, null, 8, ["class", "clickable", "icon", "pack", "size"])) : Q("", !0),
      j.type !== "textarea" ? Be((p(), A("input", fe({ key: 1 }, m.value, {
        id: j.id,
        ref: "inputElement",
        "onUpdate:modelValue": ye[0] || (ye[0] = (Se) => h.value = Se),
        type: _.value,
        "data-oruga-input": _.value,
        class: i(L),
        maxlength: j.maxlength,
        autocomplete: j.autocomplete,
        placeholder: j.placeholder,
        disabled: j.disabled,
        onBlur: ye[1] || (ye[1] = //@ts-ignore
        (...Se) => i(u) && i(u)(...Se)),
        onFocus: ye[2] || (ye[2] = //@ts-ignore
        (...Se) => i(c) && i(c)(...Se)),
        onInvalid: ye[3] || (ye[3] = //@ts-ignore
        (...Se) => i(y) && i(y)(...Se)),
        onInput: ye[4] || (ye[4] = //@ts-ignore
        (...Se) => i(U) && i(U)(...Se))
      }), null, 16, ko)), [
        [ql, h.value]
      ]) : Be((p(), A("textarea", fe({ key: 2 }, m.value, {
        id: j.id,
        ref: "inputElement",
        "onUpdate:modelValue": ye[5] || (ye[5] = (Se) => h.value = Se),
        "data-oruga-input": "textarea",
        class: i(L),
        maxlength: j.maxlength,
        style: K.value,
        placeholder: j.placeholder,
        disabled: j.disabled,
        onBlur: ye[6] || (ye[6] = //@ts-ignore
        (...Se) => i(u) && i(u)(...Se)),
        onFocus: ye[7] || (ye[7] = //@ts-ignore
        (...Se) => i(c) && i(c)(...Se)),
        onInvalid: ye[8] || (ye[8] = //@ts-ignore
        (...Se) => i(y) && i(y)(...Se)),
        onInput: ye[9] || (ye[9] = //@ts-ignore
        (...Se) => i(U) && i(U)(...Se))
      }), null, 16, wo)), [
        [jl, h.value]
      ]),
      w.value ? (p(), se(Te, {
        key: 3,
        class: N(i(W)),
        clickable: j.passwordReveal || j.clearable || j.iconRightClickable,
        icon: V.value,
        pack: j.iconPack,
        size: j.size,
        variant: $.value,
        both: "",
        onClick: E
      }, null, 8, ["class", "clickable", "icon", "pack", "size", "variant"])) : Q("", !0),
      j.maxlength && j.counter && i(I) && j.type !== "number" ? (p(), A("small", {
        key: 4,
        class: N(i(H))
      }, ce(z.value) + " / " + ce(j.maxlength), 3)) : Q("", !0)
    ], 2));
  }
}), at = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "ODropdownItem",
  configField: "dropdown",
  __name: "DropdownItem",
  props: {
    override: { type: Boolean, default: void 0 },
    value: { default: void 0 },
    label: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    clickable: { type: Boolean, default: !0 },
    hidden: { type: Boolean, default: !1 },
    tag: { default: () => n("dropdown.itemTag", "div") },
    itemClass: {},
    itemSelectedClass: {},
    itemFocusedClass: {},
    itemClickableClass: {},
    itemDisabledClass: {}
  },
  emits: ["click"],
  setup(t, { emit: l }) {
    const a = t, e = l, s = a.value ?? Le(), d = Me("rootElement"), g = o(() => ({
      ...a,
      $el: d.value,
      value: s,
      selectItem: I
    })), { parent: u, item: c } = pt({ data: g }), y = o(
      () => !u.value.disabled && !a.disabled && a.clickable
    ), f = o(() => ke(u.value.selected) ? u.value.multiple && Array.isArray(u.value.selected) ? u.value.selected.some(
      (P) => Qt(s, P)
    ) : Qt(s, u.value.selected) : !1), v = o(
      () => c.value.identifier === u.value.focsuedIdentifier
    );
    function I(P) {
      y.value && (u.value.selectItem(c.value, P), e("click", s, P));
    }
    function C() {
      u.value.focusItem(c.value);
    }
    const B = M(
      ["itemClass", "o-dropdown__item"],
      [
        "itemDisabledClass",
        "o-dropdown__item--disabled",
        null,
        o(() => u.value.disabled || a.disabled)
      ],
      ["itemSelectedClass", "o-dropdown__item--active", null, f],
      ["itemClickableClass", "o-dropdown__item--clickable", null, y],
      ["itemFocusedClass", "o-dropdown__item--focused", null, v]
    );
    return (P, h) => (p(), se(xe(P.tag), {
      id: `${i(u).menuId}-${i(c).identifier}`,
      ref: "rootElement",
      "data-oruga": "dropdown-item",
      "data-id": `dropdown-${i(c).identifier}`,
      class: N(i(B)),
      role: i(u).selectable ? "option" : "menuitem",
      "aria-selected": i(u).selectable ? f.value : void 0,
      "aria-disabled": P.disabled,
      onClick: I,
      onMouseenter: C,
      onKeydown: [
        oe(I, ["enter"]),
        oe(I, ["space"])
      ]
    }, {
      default: de(() => [
        ae(P.$slots, "default", {}, () => [
          Ve(ce(P.label), 1)
        ])
      ]),
      _: 3
    }, 40, ["id", "data-id", "class", "role", "aria-selected", "aria-disabled"]));
  }
}), tl = /* @__PURE__ */ Ce({
  inheritAttrs: !1,
  __name: "PositionWrapper",
  props: {
    teleport: {
      type: [Boolean, String, Object],
      required: !0
    },
    trigger: {
      type: Object,
      default: void 0
    },
    /**
     * Position of the component relative to the trigger
     * @values auto, top, bottom, left, right, top-right, top-left, bottom-left, bottom-right
     */
    position: {
      type: String,
      validator: (t) => [
        "auto",
        "top",
        "bottom",
        "left",
        "right",
        "top-right",
        "top-left",
        "bottom-left",
        "bottom-right"
      ].includes(t),
      required: !0
    },
    /** Used for calculation position auto */
    defaultPosition: {
      type: String,
      validator: (t) => ["top", "bottom", "left", "right"].includes(t),
      default: "top"
    },
    /** disable the position calculation */
    disabled: { type: Boolean, default: !1 },
    /** update positioning on teleport */
    disablePositioning: { type: Boolean, default: !0 }
  },
  emits: ["update:position"],
  setup(t, { emit: l }) {
    const a = {
      top: "bottom",
      bottom: "top",
      right: "left",
      left: "right"
    }, e = t, s = l, d = o(
      () => typeof e.teleport == "boolean" ? { to: la(), disabled: !e.teleport } : { to: e.teleport, disabled: !1 }
    ), g = ne();
    function u(z) {
      return g.value = z, ze(() => {
        C(), v();
      }), z;
    }
    const c = e.position, y = ne();
    let f;
    Ee && window.ResizeObserver && (f = new window.ResizeObserver(C)), be(
      () => e.disabled,
      () => {
        e.disabled ? I() : v();
      },
      { immediate: !0, flush: "post" }
    ), be(
      [
        () => !!e.trigger,
        () => e.disablePositioning,
        () => e.disabled
      ],
      () => C(),
      { immediate: !0, flush: "post" }
    ), ba(() => I());
    function v() {
      Ee && !y.value && g.value && (y.value = yo(We(g)), y.value && y.value !== document.documentElement ? (y.value.addEventListener(
        "scroll",
        C,
        { passive: !0 }
      ), window.ResizeObserver && f && f.observe(y.value)) : (document.addEventListener("scroll", C, {
        passive: !0
      }), window.addEventListener("resize", C)));
    }
    function I() {
      Ee && (window.ResizeObserver && f && f.disconnect(), window.removeEventListener("resize", C), document.removeEventListener("scroll", C), y.value = void 0);
    }
    function C() {
      if (e.disabled) return;
      let z = e.position;
      if (c === "auto" && (z = B(), z != e.position && s("update:position", z)), !e.teleport) return;
      const F = We(g), O = We(e.trigger);
      if (F && O) {
        const K = O.getBoundingClientRect();
        let U = K.top + window.scrollY, S = K.left + window.scrollX;
        z.includes("bottom") ? U += O.clientHeight : z.includes("top") && (U -= F.clientHeight), z === "left" ? S -= F.clientWidth : z === "right" ? S += O.clientWidth : z.includes("-right") && (S += O.clientWidth - F.clientWidth), (z === "top" || z === "bottom") && (S += O.clientWidth / 2), (z === "left" || z === "right") && (U += O.clientHeight / 2), e.disablePositioning ? (F.style.position = "relative", F.style.top = `${U}px`, F.style.left = `${S}px`) : (F.style.position = "", F.style.top = "", F.style.left = "");
      }
    }
    function B() {
      let z = e.defaultPosition;
      if (!e.trigger || !g.value || !y.value) return z;
      const F = new DOMRect(
        y.value.offsetLeft,
        y.value.offsetTop,
        y.value.clientWidth,
        y.value.clientHeight
      ), O = We(g).getBoundingClientRect(), K = We(e.trigger).getBoundingClientRect(), U = h(K), S = h(O), T = (Z) => {
        const _ = U[Z], q = S[a[Z]];
        return new DOMRect(
          O.x + (_.x - q.x),
          O.y + (_.y - q.y),
          O.width,
          O.height
        );
      }, w = a[e.defaultPosition], V = e.defaultPosition === "top" || e.defaultPosition === "bottom" ? "left" : "top", $ = a[V], Y = [
        e.defaultPosition,
        w,
        V,
        $
      ];
      let E = 0;
      for (const Z of Y) {
        const _ = P(
          F,
          T(Z)
        );
        _ > E && (E = _, z = Z);
      }
      return z;
    }
    function P(z, F) {
      const O = Math.max(z.left, F.left), K = Math.min(z.right, F.right), U = Math.max(z.top, F.top), S = Math.min(z.bottom, F.bottom);
      return Math.max(K - O, 0) * Math.max(S - U, 0);
    }
    const h = (z) => ({
      top: { x: (z.left + z.right) * 0.5, y: z.top },
      bottom: { x: (z.left + z.right) * 0.5, y: z.bottom },
      left: { x: z.left, y: (z.top + z.bottom) * 0.5 },
      right: { x: z.right, y: (z.top + z.bottom) * 0.5 }
    });
    return (z, F) => (p(), se(ga, {
      to: d.value.to,
      disabled: d.value.disabled
    }, [
      d.value.disabled ? ae(z.$slots, "default", {
        key: 0,
        setContent: u
      }) : (p(), A("div", fe({ key: 1 }, z.$attrs, { style: { position: "absolute", left: "0px", top: "0px" } }), [
        ae(z.$slots, "default", { setContent: u })
      ], 16))
    ], 8, ["to", "disabled"]));
  }
});
function Po(t, l) {
  const a = We(l), e = We(t), { offsetHeight: s, offsetTop: d } = e, { offsetHeight: g, scrollTop: u } = a, c = d < u, y = d + s > u + g;
  c ? a.scrollTo(0, d) : y && a.scrollTo(0, d - g + s);
}
function Do(t, l, a) {
  Ee && mt(t, "scroll", e);
  function e() {
    const s = We(t);
    if (!s) return;
    const d = s.offsetTop;
    s.clientHeight !== s.scrollHeight && (Math.ceil(
      s.scrollTop + s.clientHeight + d
    ) >= s.scrollHeight ? l() : s.scrollTop <= d && a());
  }
  return { checkScroll: e };
}
const So = { key: 1 }, wa = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "ODropdown",
  configField: "dropdown",
  __name: "Dropdown",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    multiple: {},
    options: { default: void 0 },
    active: { type: Boolean, default: !1 },
    label: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    inline: { type: Boolean, default: !1 },
    selectable: { type: Boolean, default: !1 },
    scrollable: { type: Boolean, default: !1 },
    checkScroll: { type: Boolean, default: () => n("dropdown.checkScroll", !1) },
    maxHeight: { default: () => n("dropdown.maxHeight", 200) },
    position: { default: () => n("dropdown.position", "bottom-left") },
    animation: { default: () => n("dropdown.animation", "fade") },
    expanded: { type: Boolean, default: !1 },
    menuId: { default: () => Le() },
    menuTag: { default: () => n("dropdown.menuTag", "div") },
    triggerTag: { default: () => n("dropdown.triggerTag", "div") },
    triggers: { default: () => n("dropdown.triggers", ["click"]) },
    delay: { default: void 0 },
    keepOpen: { type: Boolean, default: () => n("dropdown.keepOpen", !1) },
    keepFirst: { type: Boolean, default: () => n("dropdown.keepFirst", !1) },
    closeOnOutside: { type: Boolean, default: () => n("dropdown.closeOnOutside", !0) },
    closeOnScroll: { type: Boolean, default: () => n("dropdown.closeOnScroll", !1) },
    selectOnFocus: { type: Boolean, default: () => n("dropdown.selectOnFocus", !1) },
    selectOnClose: { type: Boolean, default: () => n("dropdown.selectOnClose", !1) },
    mobileModal: { type: Boolean, default: () => n("dropdown.mobileModal", !0) },
    desktopModal: { type: Boolean, default: () => n("dropdown.desktopModal", !1) },
    mobileBreakpoint: { default: () => n("dropdown.mobileBreakpoint") },
    teleport: { type: [Boolean, String, Object], default: () => n("dropdown.teleport", !1) },
    clipScroll: { type: Boolean, default: () => n("dropdown.clipScroll", !1) },
    labelledby: {},
    ariaLabel: {},
    rootClass: {},
    mobileClass: {},
    modalClass: {},
    teleportClass: {},
    inlineClass: {},
    disabledClass: {},
    expandedClass: {},
    positionClass: {},
    activeClass: {},
    hoverableClass: {},
    triggerClass: {},
    menuClass: {},
    menuPositionClass: {},
    menuActiveClass: {},
    overlayClass: {},
    scrollClipClass: {},
    scrollKeepClass: {}
  }, {
    modelValue: { default: void 0 },
    modelModifiers: {},
    active: { type: Boolean, default: !1 },
    activeModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:model-value", "update:active", "select", "change", "open", "close", "scroll-start", "scroll-end"], ["update:modelValue", "update:active"]),
  setup(t, { expose: l, emit: a }) {
    var G;
    const e = t, s = a, d = ne(), g = ne(), u = o(() => {
      var D;
      return {
        disabled: e.disabled,
        multiple: we(e.multiple),
        selectable: e.selectable,
        menuId: e.menuId,
        selected: C.value,
        focsuedIdentifier: (D = R.value) == null ? void 0 : D.identifier,
        selectItem: m,
        focusItem: L
      };
    }), { childItems: c } = bt({
      rootRef: g,
      data: u
    }), { nextSequence: y } = ut(), f = o(() => {
      const D = dt(e.options, y);
      return ha(D, y());
    }), v = o(() => c.value.some(Qe)), { parentField: I } = Ge(), C = Pe(t, "modelValue"), B = Pe(t, "active"), P = e.labelledby ?? ((G = I.value) == null ? void 0 : G.labelId), h = ne(e.position);
    be(
      () => e.position,
      (D) => h.value = D
    );
    const { isMobile: z } = rt(e.mobileBreakpoint), F = Ee && ct.any(), O = o(
      () => !e.inline && (z.value && e.mobileModal || !z.value && e.desktopModal)
    ), K = o(() => ({
      maxHeight: e.scrollable ? wt(e.maxHeight) : null,
      overflow: e.scrollable ? "auto" : null
    })), U = o(() => e.triggers.includes("hover")), S = aa(e.clipScroll);
    Ee && e.scrollable && e.checkScroll && Do(
      g,
      () => s("scroll-end"),
      () => s("scroll-start")
    ), Ee && e.closeOnOutside && ta([g, d], T, {
      trigger: B,
      passive: !0
    }), Ee && e.closeOnScroll && mt(window, "scroll", w, { passive: !0 }), be(
      B,
      (D) => {
        D && !e.inline && e.keepFirst && !R.value && te(1), O.value && S(D);
      },
      { flush: "post" }
    ), be(
      c,
      () => {
        B.value && !e.inline && e.keepFirst && (R.value = void 0, te(1));
      },
      { deep: !0, flush: "post" }
    );
    function T(D) {
      !B.value || e.inline || e.closeOnOutside && r("outside", D);
    }
    function w(D) {
      !B.value || e.inline || e.closeOnScroll && r("scroll", D);
    }
    function V(D) {
      F && U.value && _("click", D), e.triggers.includes("click") && _("click", D);
    }
    function $(D) {
      e.triggers.includes("contextmenu") && (D.preventDefault(), k("contextmenu", D));
    }
    function Y(D) {
      e.triggers.includes("focus") && k("focus", D);
    }
    function E(D) {
      F || e.triggers.includes("hover") && k("hover", D);
    }
    function Z(D) {
      F || e.triggers.includes("hover") && r("outside", D);
    }
    function _(D, le) {
      e.disabled || (B.value ? r(D, le) : k(D, le));
    }
    let q;
    function k(D, le) {
      e.disabled || B.value || (e.delay ? q = setTimeout(() => {
        B.value = !0, s("open", D, le), q = void 0;
      }, e.delay) : (ze(() => B.value = !0), s("open", D, le)));
    }
    function r(D, le) {
      var me, Fe;
      B.value && (s("close", D, le), e.selectOnClose && ((Fe = (me = R.value) == null ? void 0 : me.data) != null && Fe.value) && m(R.value), B.value = !1, R.value = void 0, q && clearTimeout(q));
    }
    function m(D, le) {
      var Fe;
      const me = D.data.value;
      s("select", me), e.selectable && (we(e.multiple) ? (C.value && Array.isArray(C.value) ? C.value.includes(me) ? C.value = C.value.filter(
        (He) => He !== me
      ) : C.value = [...C.value, me] : C.value = [me], ze(() => s("change", C.value))) : C.value !== me && (C.value = me, ze(() => s("change", C.value)))), (Fe = d.value) == null || Fe.focus(), !(e.keepOpen || !B.value || !le) && r("content", le);
    }
    const R = ne();
    function L(D) {
      R.value = D;
    }
    function te(D) {
      var me;
      if (!v.value) return;
      const le = Ue(((me = R.value) == null ? void 0 : me.index) || 0, D);
      W(le);
    }
    function W(D) {
      var Fe, He;
      e.selectOnFocus && ((Fe = D.data) != null && Fe.value) && m(D, new Event("focus"));
      const le = We(g), me = We((He = D.data) == null ? void 0 : He.$el);
      !le || !me || (R.value = D, Po(me, le));
    }
    function H(D) {
      if (!B.value) return k("keydown", D);
      te(-1);
    }
    function J(D) {
      if (!B.value) return k("keydown", D);
      te(1);
    }
    function j(D) {
      var le;
      B.value && R.value && (W(R.value), (le = R.value.data) == null || le.selectItem(D));
    }
    function ye(D) {
      if (k("keydown", D), !v.value) return;
      const le = Ue(0, 1);
      W(le);
    }
    function Se(D) {
      if (k("keydown", D), !v.value) return;
      const le = Ue(c.value.length - 1, -1);
      W(le);
    }
    function Ne(D) {
      r("escape", D);
    }
    function Ue(D, le) {
      var Fe, He;
      let me = ot(
        ((Fe = R.value) == null ? void 0 : Fe.index) == D ? D + le : D,
        c.value.length
      );
      for (; me !== ((He = R.value) == null ? void 0 : He.index) && !Qe(c.value[me]); me = ot(me + le, c.value.length))
        ;
      return c.value[me];
    }
    function Qe(D) {
      var le, me, Fe;
      return !((le = D.data) != null && le.disabled) && !((me = D.data) != null && me.hidden) && !!((Fe = D.data) != null && Fe.clickable);
    }
    const je = M(
      ["rootClass", "o-dropdown"],
      [
        "disabledClass",
        "o-dropdown--disabled",
        null,
        o(() => e.disabled)
      ],
      [
        "expandedClass",
        "o-dropdown--expanded",
        null,
        o(() => e.expanded)
      ],
      ["inlineClass", "o-dropdown--inline", null, o(() => e.inline)],
      ["mobileClass", "o-dropdown--mobile", null, z],
      ["modalClass", "o-dropdown--modal", null, O],
      ["hoverableClass", "o-dropdown--hoverable", null, U],
      [
        "positionClass",
        "o-dropdown--position-",
        h,
        o(() => !!h.value)
      ],
      [
        "activeClass",
        "o-dropdown--active",
        null,
        o(() => B.value || e.inline)
      ]
    ), gt = M(["triggerClass", "o-dropdown__trigger"]), yt = M([
      "teleportClass",
      "o-dropdown--teleport",
      null,
      o(() => !!e.teleport)
    ]), ue = M(["overlayClass", "o-dropdown__overlay"]), X = M(
      ["menuClass", "o-dropdown__menu"],
      [
        "menuPositionClass",
        "o-dropdown__menu--",
        h,
        o(() => !!h.value)
      ],
      [
        "menuActiveClass",
        "o-dropdown__menu--active",
        null,
        o(() => B.value || e.inline)
      ]
    );
    return l({ $trigger: d, $content: g, value: C }), (D, le) => (p(), A("div", {
      "data-oruga": "dropdown",
      class: N(i(je)),
      onMouseleave: Z,
      onFocusout: Z
    }, [
      D.inline ? Q("", !0) : (p(), se(xe(D.triggerTag), {
        key: 0,
        ref_key: "triggerRef",
        ref: d,
        class: N(i(gt)),
        role: D.selectable ? "combobox" : void 0,
        tabindex: D.disabled ? -1 : null,
        "aria-haspopup": D.selectable ? "listbox" : "menu",
        "aria-expanded": D.selectable ? B.value : void 0,
        "aria-activedescendant": R.value ? `${D.menuId}-${R.value.identifier}` : void 0,
        "aria-disabled": D.disabled,
        "aria-controls": D.menuId,
        "aria-labelledby": D.selectable ? i(P) : void 0,
        "aria-label": D.selectable ? D.ariaLabel : void 0,
        onClick: V,
        onContextmenu: $,
        onMouseenter: E,
        onFocusCapture: Y,
        onKeydown: [
          oe(Ne, ["tab"]),
          oe(Ne, ["escape"]),
          oe(j, ["enter"]),
          oe(j, ["space"]),
          oe(re(H, ["prevent"]), ["up"]),
          oe(re(J, ["prevent"]), ["down"]),
          oe(re(ye, ["prevent"]), ["home"]),
          oe(re(Se, ["prevent"]), ["end"])
        ]
      }, {
        default: de(() => [
          ae(D.$slots, "trigger", {
            active: B.value,
            value: t.modelValue,
            toggle: V
          }, () => [
            Ve(ce(D.label), 1)
          ])
        ]),
        _: 3
      }, 40, ["class", "role", "tabindex", "aria-haspopup", "aria-expanded", "aria-activedescendant", "aria-disabled", "aria-controls", "aria-labelledby", "aria-label", "onKeydown"])),
      he(tl, {
        position: h.value,
        "onUpdate:position": le[6] || (le[6] = (me) => h.value = me),
        teleport: D.teleport,
        class: N([...i(je), ...i(yt)]),
        trigger: d.value,
        disabled: !B.value,
        "default-position": "bottom",
        "disable-positioning": !O.value
      }, {
        default: de(({ setContent: me }) => [
          O.value ? (p(), se(Je, {
            key: 0,
            name: D.animation
          }, {
            default: de(() => [
              Be(pe("div", {
                class: N(i(ue)),
                tabindex: "-1",
                onClick: T
              }, null, 2), [
                [Oe, B.value]
              ])
            ]),
            _: 1
          }, 8, ["name"])) : Q("", !0),
          he(Je, { name: D.animation }, {
            default: de(() => [
              Be((p(), se(xe(D.menuTag), {
                id: D.menuId,
                ref: (Fe) => g.value = me(Fe),
                tabindex: D.inline ? 0 : -1,
                class: N(i(X)),
                style: Xe(K.value),
                role: D.selectable ? "listbox" : "menu",
                "aria-labelledby": i(P),
                "aria-label": D.ariaLabel,
                "aria-hidden": !D.inline && (D.disabled || !B.value),
                "aria-multiselectable": D.selectable ? i(we)(D.multiple) : void 0,
                onKeydown: [
                  le[0] || (le[0] = oe(re((Fe) => D.inline && j(Fe), ["prevent"]), ["enter"])),
                  le[1] || (le[1] = oe(re((Fe) => D.inline && j(Fe), ["prevent"]), ["space"])),
                  le[2] || (le[2] = oe(re((Fe) => D.inline && H(Fe), ["prevent"]), ["up"])),
                  le[3] || (le[3] = oe(re((Fe) => D.inline && J(Fe), ["prevent"]), ["down"])),
                  le[4] || (le[4] = oe(re((Fe) => D.inline && ye(Fe), ["prevent"]), ["home"])),
                  le[5] || (le[5] = oe(re((Fe) => D.inline && Se(Fe), ["prevent"]), ["end"]))
                ]
              }, {
                default: de(() => {
                  var Fe;
                  return [
                    ae(D.$slots, "default", {
                      active: B.value,
                      focusedIndex: (Fe = R.value) == null ? void 0 : Fe.index,
                      toggle: _
                    }, () => [
                      ae(D.$slots, "before"),
                      (p(!0), A(ve, null, $e(f.value, (He, na) => (p(), A(ve, null, [
                        He.label ? Be((p(), se(at, fe({
                          key: 0,
                          ref_for: !0
                        }, He.attrs, {
                          key: He.key,
                          value: He.value,
                          hidden: He.hidden,
                          role: "presentation",
                          clickable: !1
                        }), {
                          default: de(() => [
                            D.$slots.group ? ae(D.$slots, "group", {
                              key: 0,
                              group: He.label,
                              index: na
                            }) : (p(), A("span", So, ce(He.label), 1))
                          ]),
                          _: 2
                        }, 1040, ["value", "hidden"])), [
                          [Oe, !He.hidden]
                        ]) : Q("", !0),
                        (p(!0), A(ve, null, $e(He.options, (Ze) => Be((p(), se(at, fe({ ref_for: !0 }, Ze.attrs, {
                          key: Ze.key,
                          value: Ze.value,
                          hidden: Ze.hidden
                        }), {
                          default: de(() => [
                            Ve(ce(Ze.label), 1)
                          ]),
                          _: 2
                        }, 1040, ["value", "hidden"])), [
                          [Oe, !Ze.hidden]
                        ])), 128))
                      ], 64))), 256)),
                      ae(D.$slots, "after")
                    ])
                  ];
                }),
                _: 2
              }, 1064, ["id", "tabindex", "class", "style", "role", "aria-labelledby", "aria-label", "aria-hidden", "aria-multiselectable"])), [
                [Oe, !D.disabled && B.value || D.inline]
              ])
            ]),
            _: 2
          }, 1032, ["name"])
        ]),
        _: 3
      }, 8, ["position", "teleport", "class", "trigger", "disabled", "disable-positioning"])
    ], 34));
  }
}), $o = { key: 1 }, Bo = { key: 1 }, al = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OAutocomplete",
  configField: "autocomplete",
  inheritAttrs: !1,
  __name: "Autocomplete",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    input: { default: "" },
    active: { type: Boolean, default: !1 },
    options: { default: void 0 },
    backendFiltering: { type: Boolean, default: () => n("autocomplete.backendFiltering", !1) },
    filter: { type: Function, default: void 0 },
    type: { default: "text" },
    menuTag: { default: () => n("autocomplete.menuTag", "div") },
    itemTag: { default: () => n("autocomplete.itemTag", "div") },
    size: { default: () => n("autocomplete.size") },
    position: { default: () => n("autocomplete.position", "auto") },
    placeholder: { default: void 0 },
    expanded: { type: Boolean, default: !1 },
    rounded: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    maxlength: { default: void 0 },
    debounce: { default: () => n("autocomplete.debounce", 400) },
    keepFirst: { type: Boolean, default: () => n("autocomplete.keepFirst", !1) },
    keepOpen: { type: Boolean, default: () => n("autocomplete.keepOpen", !1) },
    clearOnSelect: { type: Boolean, default: () => n("autocomplete.clearOnSelect", !1) },
    openOnFocus: { type: Boolean, default: () => n("autocomplete.openOnFocus", !1) },
    selectOnClose: { type: Boolean, default: !1 },
    selectableHeader: { type: Boolean, default: !1 },
    selectableFooter: { type: Boolean, default: !1 },
    maxHeight: { default: () => n("autocomplete.maxHeight") },
    checkScroll: { type: Boolean, default: () => n("autocomplete.checkScroll", !1) },
    iconPack: { default: () => n("autocomplete.iconPack") },
    icon: { default: () => n("autocomplete.icon") },
    iconClickable: { type: Boolean, default: !1 },
    iconRight: { default: () => n("autocomplete.iconRight") },
    iconRightClickable: { type: Boolean, default: !1 },
    iconRightVariant: { default: void 0 },
    clearable: { type: Boolean, default: () => n("autocomplete.clearable", !1) },
    clearIcon: { default: () => n("autocomplete.clearIcon", "close-circle") },
    statusIcon: { type: Boolean, default: () => n("statusIcon", !0) },
    mobileModal: { type: Boolean, default: () => n("autocomplete.mobileModal", !1) },
    desktopModal: { type: Boolean, default: () => n("dropdown.desktopModal", !1) },
    animation: { default: () => n("autocomplete.animation", "fade") },
    autocomplete: { default: () => n("autocomplete.autocomplete", "off") },
    useHtml5Validation: { type: Boolean, default: () => n("useHtml5Validation", !0) },
    customValidity: { type: [String, Function], default: void 0 },
    teleport: { type: [Boolean, String, Object], default: () => n("autocomplete.teleport", !1) },
    rootClass: {},
    itemClass: {},
    itemGroupTitleClass: {},
    itemEmptyClass: {},
    itemHeaderClass: {},
    itemFooterClass: {},
    inputClasses: { default: () => n("autocomplete.inputClasses", {}) }
  }, {
    active: { type: Boolean, default: !1 },
    activeModifiers: {},
    modelValue: { default: void 0 },
    modelModifiers: {},
    input: { default: "" },
    inputModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:model-value", "update:input", "update:active", "input", "select", "select-header", "select-footer", "focus", "blur", "invalid", "icon-click", "icon-right-click", "scroll-start", "scroll-end"], ["update:active", "update:modelValue", "update:input"]),
  setup(t, { expose: l, emit: a }) {
    const e = t, s = a, d = vt(), g = Me("inputComponent"), { checkHtml5Validity: u, onInvalid: c, onFocus: y, onBlur: f, isFocused: v, setFocus: I } = et(g, s, e), { parentField: C } = Ge(), B = Pe(t, "active"), P = Pe(t, "modelValue"), h = Pe(t, "input"), z = Le(), { nextSequence: F } = ut(), O = o(() => {
      const W = dt(e.options, F);
      return ha(W, F());
    });
    e.backendFiltering || Ot(() => {
      ka(
        O,
        (W) => K(W, h)
      ), _t(O);
    });
    function K(W, H) {
      var J;
      return typeof e.filter == "function" ? e.filter(W.value, Ae(H)) : !String(W.label).toLowerCase().includes((J = Ae(H)) == null ? void 0 : J.toLowerCase());
    }
    const U = o(() => Za(O));
    be(U, (W) => {
      v.value && (B.value = !W || !!d.empty);
    });
    const S = ne();
    be(
      h,
      (W) => {
        const H = Zt(O, P);
        H && H.label !== W && (P.value = void 0, S.value = void 0), U.value && !d.empty && (B.value = !1);
      },
      { flush: "post" }
    ), be(
      P,
      (W) => {
        if (!W) return;
        const H = Zt(O, W);
        H && (h.value = e.clearOnSelect ? "" : H.label, u(), S.value = H.value);
      },
      // set initial values if selected is given
      { immediate: !0 }
    );
    function T(W) {
      let H;
      W === 0 ? s("select-header") : W === 1 ? s("select-footer") : W && (H = Co(O).find((j) => j.value === W)), P.value = H == null ? void 0 : H.value, s("select", H == null ? void 0 : H.value), e.keepOpen ? I() : B.value = !1;
    }
    function w(W, H) {
      v.value && (!B.value && W && (!U.value || d.empty) ? B.value = !0 : B.value && !W && !e.keepOpen && (B.value = !1)), s("input", W, H), u();
    }
    function V(W) {
      var H;
      e.openOnFocus && ((H = e.options) != null && H.length || d.header || d.footer) && (B.value = !0), y(W);
    }
    function $(W) {
      f(W);
    }
    const Y = o(
      () => e.clearable && h.value && e.clearIcon ? e.clearIcon : e.iconRight
    ), E = o(
      () => e.clearable ? !0 : e.iconRightClickable
    );
    function Z(W) {
      e.clearable ? h.value = "" : s("icon-right-click", W);
    }
    const _ = it(), q = o(() => {
      var W;
      return {
        ...(W = C == null ? void 0 : C.value) == null ? void 0 : W.inputAttrs,
        ..._,
        ...e.inputClasses
      };
    }), k = M(["rootClass", "o-autocomplete"]), r = M(["itemClass", "o-autocomplete__item"]), m = M([
      "itemEmptyClass",
      "o-autocomplete__item--empty"
    ]), R = M([
      "itemGroupTitleClass",
      "o-autocomplete__item-group-title"
    ]), L = M([
      "itemHeaderClass",
      "o-autocomplete__item-header"
    ]), te = M([
      "itemFooterClass",
      "o-autocomplete__item-footer"
    ]);
    return l({ focus: I, value: h }), (W, H) => (p(), se(wa, {
      modelValue: S.value,
      "onUpdate:modelValue": H[2] || (H[2] = (J) => S.value = J),
      active: B.value,
      "onUpdate:active": H[3] || (H[3] = (J) => B.value = J),
      "data-oruga": "autocomplete",
      class: N(i(k)),
      "menu-id": i(z),
      "menu-tag": W.menuTag,
      triggers: [],
      scrollable: "",
      selectable: "",
      "keep-open": W.keepOpen,
      "keep-first": W.keepFirst,
      "check-scroll": W.checkScroll,
      "select-on-close": W.selectOnClose,
      disabled: W.disabled,
      "desktop-modal": W.desktopModal,
      "mobile-modal": W.mobileModal,
      "max-height": W.maxHeight,
      animation: W.animation,
      position: W.position,
      teleport: W.teleport,
      expanded: W.expanded,
      onSelect: T,
      onScrollStart: H[4] || (H[4] = (J) => s("scroll-start")),
      onScrollEnd: H[5] || (H[5] = (J) => s("scroll-end"))
    }, {
      trigger: de(() => [
        he(Pt, fe({ ref: "inputComponent" }, q.value, {
          modelValue: h.value,
          "onUpdate:modelValue": H[0] || (H[0] = (J) => h.value = J),
          type: W.type,
          size: W.size,
          rounded: W.rounded,
          icon: W.icon,
          "icon-right": Y.value,
          "icon-right-clickable": E.value,
          "icon-pack": W.iconPack,
          placeholder: W.placeholder,
          maxlength: W.maxlength,
          autocomplete: W.autocomplete,
          expanded: W.expanded,
          disabled: W.disabled,
          "status-icon": W.statusIcon,
          debounce: W.debounce,
          "aria-autocomplete": W.keepFirst ? "both" : "list",
          "aria-controls": i(z),
          enterkeyhint: "enter",
          "use-html5-validation": !1,
          onInput: w,
          onFocus: V,
          onBlur: $,
          onInvalid: i(c),
          onIconClick: H[1] || (H[1] = (J) => s("icon-click", J)),
          onIconRightClick: Z
        }), null, 16, ["modelValue", "type", "size", "rounded", "icon", "icon-right", "icon-right-clickable", "icon-pack", "placeholder", "maxlength", "autocomplete", "expanded", "disabled", "status-icon", "debounce", "aria-autocomplete", "aria-controls", "onInvalid"])
      ]),
      default: de(() => [
        W.$slots.header ? (p(), se(at, {
          key: 0,
          tag: W.itemTag,
          value: 0,
          clickable: W.selectableHeader,
          class: N([...i(r), ...i(L)])
        }, {
          default: de(() => [
            ae(W.$slots, "header")
          ]),
          _: 3
        }, 8, ["tag", "value", "clickable", "class"])) : Q("", !0),
        (p(!0), A(ve, null, $e(O.value, (J, j) => (p(), A(ve, null, [
          J.label ? Be((p(), se(at, fe({
            key: J.key,
            ref_for: !0
          }, J.attrs, {
            hidden: J.hidden,
            value: J.value,
            tag: W.itemTag,
            role: "presentation",
            clickable: !1,
            class: [...i(r), ...i(R)]
          }), {
            default: de(() => [
              W.$slots.group ? ae(W.$slots, "group", {
                key: 0,
                group: J.label,
                index: j
              }) : (p(), A("span", $o, ce(J.label), 1))
            ]),
            _: 2
          }, 1040, ["hidden", "value", "tag", "class"])), [
            [Oe, !J.hidden]
          ]) : Q("", !0),
          (p(!0), A(ve, null, $e(J.options, (ye, Se) => Be((p(), se(at, fe({
            key: ye.key,
            ref_for: !0
          }, ye.attrs, {
            value: ye.value,
            hidden: ye.hidden,
            tag: W.itemTag,
            class: i(r)
          }), {
            default: de(() => [
              W.$slots.default ? ae(W.$slots, "default", {
                key: 0,
                option: ye,
                value: ye.value,
                index: Se
              }) : (p(), A("span", Bo, ce(ye.label), 1))
            ]),
            _: 2
          }, 1040, ["value", "hidden", "tag", "class"])), [
            [Oe, !ye.hidden]
          ])), 128))
        ], 64))), 256)),
        U.value && W.$slots.empty ? (p(), se(at, {
          key: 1,
          tag: W.itemTag,
          class: N([...i(r), ...i(m)])
        }, {
          default: de(() => [
            ae(W.$slots, "empty")
          ]),
          _: 3
        }, 8, ["tag", "class"])) : Q("", !0),
        W.$slots.footer ? (p(), se(at, {
          key: 2,
          tag: W.itemTag,
          value: 1,
          clickable: W.selectableFooter,
          class: N([...i(r), ...i(te)])
        }, {
          default: de(() => [
            ae(W.$slots, "footer")
          ]),
          _: 3
        }, 8, ["tag", "value", "clickable", "class"])) : Q("", !0)
      ]),
      _: 3
    }, 8, ["modelValue", "active", "class", "menu-id", "menu-tag", "keep-open", "keep-first", "check-scroll", "select-on-close", "disabled", "desktop-modal", "mobile-modal", "max-height", "animation", "position", "teleport", "expanded"]));
  }
}), Io = {
  install(t) {
    Ie(t, al);
  }
}, Dt = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OButton",
  configField: "button",
  __name: "Button",
  props: {
    override: { type: Boolean, default: void 0 },
    tag: { default: () => n("button.tag", "button") },
    variant: { default: () => n("button.variant") },
    size: { default: () => n("button.size") },
    label: { default: void 0 },
    iconPack: { default: () => n("button.iconPack") },
    iconLeft: { default: void 0 },
    iconRight: { default: void 0 },
    rounded: { type: Boolean, default: () => n("button.rounded", !1) },
    expanded: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    outlined: { type: Boolean, default: !1 },
    loading: { type: Boolean, default: !1 },
    inverted: { type: Boolean, default: !1 },
    type: { default: "button" },
    iconBoth: { type: Boolean, default: !1 },
    rootClass: {},
    sizeClass: {},
    variantClass: {},
    outlinedClass: {},
    invertedClass: {},
    loadingClass: {},
    expandedClass: {},
    roundedClass: {},
    disabledClass: {},
    wrapperClass: {},
    iconClass: {},
    iconLeftClass: {},
    iconRightClass: {},
    labelClass: {}
  },
  emits: ["click"],
  setup(t) {
    const l = t, a = o(
      () => typeof l.disabled < "u" && l.disabled !== !1 ? "button" : l.tag
    ), e = o(
      () => l.tag === "button" || l.tag === "input" ? l.type : null
    ), s = M(
      ["rootClass", "o-button"],
      [
        "sizeClass",
        "o-button--",
        o(() => l.size),
        o(() => !!l.size)
      ],
      [
        "variantClass",
        "o-button--",
        o(() => l.variant),
        o(() => !!l.variant && !l.outlined && !l.inverted)
      ],
      [
        "outlinedClass",
        "o-button--outlined",
        null,
        o(() => l.outlined && !l.variant)
      ],
      [
        "invertedClass",
        "o-button--inverted",
        null,
        o(() => l.inverted && !l.variant)
      ],
      [
        "outlinedClass",
        "o-button--outlined-",
        o(() => l.variant),
        o(() => l.outlined && !!l.variant)
      ],
      [
        "invertedClass",
        "o-button--inverted-",
        o(() => l.variant),
        o(() => l.inverted && !!l.variant)
      ],
      [
        "expandedClass",
        "o-button--expanded",
        null,
        o(() => l.expanded)
      ],
      ["loadingClass", "o-button--loading", null, o(() => l.loading)],
      ["roundedClass", "o-button--rounded", null, o(() => l.rounded)],
      [
        "disabledClass",
        "o-button--disabled",
        null,
        o(() => l.disabled)
      ]
    ), d = M(["wrapperClass", "o-button__wrapper"]), g = M(["labelClass", "o-button__label"]), u = M(["iconClass", "o-button__icon"]), c = M(["iconLeftClass", "o-button__icon-left"]), y = M([
      "iconRightClass",
      "o-button__icon-right"
    ]);
    return (f, v) => (p(), se(xe(a.value), {
      "data-oruga": "button",
      type: e.value,
      role: "button",
      tabindex: "0",
      class: N(i(s)),
      disabled: f.disabled ? !0 : null,
      onClick: v[0] || (v[0] = (I) => f.$emit("click", I)),
      onKeydown: [
        v[1] || (v[1] = oe((I) => f.$emit("click", I), ["enter"])),
        v[2] || (v[2] = oe((I) => f.$emit("click", I), ["space"]))
      ]
    }, {
      default: de(() => [
        pe("span", {
          class: N(i(d))
        }, [
          f.iconLeft ? (p(), se(Te, {
            key: 0,
            pack: f.iconPack,
            icon: f.iconLeft,
            size: f.size,
            both: f.iconBoth,
            class: N([...i(u), ...i(c)])
          }, null, 8, ["pack", "icon", "size", "both", "class"])) : Q("", !0),
          f.label || f.$slots.default ? (p(), A("span", {
            key: 1,
            class: N(i(g))
          }, [
            ae(f.$slots, "default", {}, () => [
              Ve(ce(f.label), 1)
            ])
          ], 2)) : Q("", !0),
          f.iconRight ? (p(), se(Te, {
            key: 2,
            pack: f.iconPack,
            icon: f.iconRight,
            size: f.size,
            both: f.iconBoth,
            class: N([...i(u), ...i(y)])
          }, null, 8, ["pack", "icon", "size", "both", "class"])) : Q("", !0)
        ], 2)
      ]),
      _: 3
    }, 40, ["type", "class", "disabled"]));
  }
}), Fo = {
  install(t) {
    Ie(t, Dt);
  }
}, Mo = ["onKeydown"], Oo = ["aria-live"], Vo = ["id", "tabindex", "aria-label", "aria-controls", "aria-selected", "onClick", "onKeydown"], Ao = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OCarousel",
  configField: "carousel",
  __name: "Carousel",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: 0 },
    dragable: { type: Boolean, default: !0 },
    autoplay: { type: Boolean, default: !1 },
    interval: { default: () => n("carousel.interval", 3500) },
    pauseHover: { type: Boolean, default: !1 },
    repeat: { type: Boolean, default: !1 },
    overlay: { type: Boolean, default: !1 },
    indicators: { type: Boolean, default: !0 },
    indicatorInside: { type: Boolean, default: !1 },
    indicatorPosition: { default: () => n("carousel.indicatorPosition", "bottom") },
    indicatorStyle: { default: () => n("carousel.indicatorStyle", "dots") },
    itemsToShow: { default: () => n("carousel.itemsToShow", 1) },
    itemsToList: { default: () => n("carousel.itemsToList", 1) },
    arrows: { type: Boolean, default: () => n("carousel.arrows", !0) },
    arrowsHover: { type: Boolean, default: () => n("carousel.arrowsHover", !0) },
    iconPack: { default: () => n("carousel.iconPack") },
    iconSize: { default: () => n("carousel.iconSize") },
    iconPrev: { default: () => n("carousel.iconPrev", "chevron-left") },
    iconNext: { default: () => n("carousel.iconNext", "chevron-right") },
    iconAutoplayPause: { default: () => n("carousel.iconAutoplayPause", "pause") },
    iconAutoplayResume: { default: () => n("carousel.iconAutoplayResume", "play") },
    breakpoints: { default: () => ({}) },
    ariaAutoplayPauseLabel: { default: () => n(
      "carousel.ariaAutoplayPauseLabel",
      "Stop Automatic Slide Show"
    ) },
    ariaAutoplayResumeLabel: { default: () => n(
      "carousel.ariaAutoplayResumeLabel",
      "Start Automatic Slide Show"
    ) },
    ariaNextLabel: { default: () => n("carousel.ariaNextLabel", "Next Slide") },
    ariaPreviousLabel: { default: () => n("carousel.ariaPreviousLabel", "Previous Slide") },
    rootClass: {},
    overlayClass: {},
    wrapperClass: {},
    itemsClass: {},
    itemsDraggingClass: {},
    iconClass: {},
    iconPrevClass: {},
    iconNextClass: {},
    iconAutoplayClass: {},
    indicatorsClass: {},
    indicatorsInsideClass: {},
    indicatorsPositionClass: {},
    indicatorClass: {},
    indicatorItemClass: {},
    indicatorItemActiveClass: {},
    indicatorItemStyleClass: {}
  }, {
    modelValue: { default: 0 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:model-value", "change", "click"], ["update:modelValue"]),
  setup(t, { emit: l }) {
    const a = t, e = l, s = Me("rootElement"), d = o(() => ({
      activeIndex: u.value,
      indicators: a.indicators,
      total: c.value,
      itemWidth: B.value,
      onDrag: L,
      onClick: (ue) => e("click", ue),
      setActive: (ue) => S(ue)
    })), { childItems: g } = bt({ rootRef: s, data: d }), u = Pe(t, "modelValue"), c = o(() => g.value.length), y = o(
      () => g.value.filter(
        (ue, X) => ot(X, C.value.itemsToList) === 0
      )
    );
    let f;
    Ee && window.ResizeObserver && (f = new window.ResizeObserver(I)), be(
      [
        () => a.itemsToList,
        () => a.itemsToShow,
        () => a.arrowsHover,
        () => a.repeat
      ],
      () => I()
    );
    const v = ne(0);
    function I() {
      u.value = 0, v.value = window.innerWidth, ze(() => _t(C));
    }
    st(() => {
      if (Ee) {
        window.ResizeObserver && f && s.value && f.observe(s.value), v.value = window.innerWidth;
        const ue = window.matchMedia(
          "(prefers-reduced-motion: reduce)"
        );
        ue != null && ue.matches || _();
      }
    }), ba(() => {
      Ee && (window.ResizeObserver && f && f.disconnect(), W(), q());
    });
    const C = o(() => {
      const X = Object.keys(a.breakpoints).map(Number).sort((D, le) => le - D).find(
        (D) => v.value >= D
      ), G = Xt(
        X ? { ...a, ...a.breakpoints[X] } : a
      );
      return G.itemsToList || (G.itemsToList = 1), G.itemsToShow || (G.itemsToShow = 1), Xl(G);
    }), B = o(() => !v.value || !s.value ? 0 : s.value.getBoundingClientRect().width / C.value.itemsToShow), P = o(
      () => C.value.arrowsHover && w.value || !C.value.arrowsHover
    ), h = o(() => C.value.repeat || u.value > 0);
    function z() {
      S(u.value - C.value.itemsToList);
    }
    const F = o(
      () => C.value.repeat || u.value < c.value - C.value.itemsToList
    );
    function O() {
      S(u.value + C.value.itemsToList);
    }
    function K() {
      S(0);
    }
    function U() {
      S(c.value - C.value.itemsToList);
    }
    function S(ue = 0) {
      C.value.repeat && (ue = ot(ue, c.value)), ue = Oa(ue, 0, c.value - 1), u.value = ue, e("change", ue);
    }
    function T(ue) {
      S(ue.index);
    }
    const w = ne(!1);
    let V;
    const $ = ne(!1);
    function Y() {
      w.value = !0, a.autoplay && a.pauseHover && q();
    }
    function E() {
      w.value = !1, a.autoplay && a.pauseHover && _();
    }
    be(
      () => a.autoplay,
      (ue) => {
        ue ? _() : q();
      }
    ), be(
      () => a.repeat,
      (ue) => {
        ue && _();
      }
    );
    function Z() {
      $.value ? ($.value = !1, _()) : ($.value = !0, q());
    }
    function _() {
      !a.autoplay || V || $.value || (V = setInterval(() => {
        !a.repeat && !F.value ? q() : O();
      }, a.interval));
    }
    function q() {
      V && (clearInterval(V), V = void 0);
    }
    const k = ne(), r = ne(0), m = o(() => ke(k.value)), R = o(
      () => -Oa(
        r.value + u.value * B.value,
        0,
        (g.value.length - C.value.itemsToShow) * B.value
      )
    );
    function L(ue) {
      m.value || !C.value.dragable || ue.button !== 0 && ue.type !== "touchstart" || (r.value = 0, k.value = ue.touches ? ue.touches[0].clientX : ue.clientX, q());
    }
    function te(ue) {
      if (!m.value) return;
      const X = ue.touches ? (ue.changedTouches[0] || ue.touches[0]).clientX : ue.clientX;
      r.value = k.value - X;
    }
    function W() {
      if (!m.value) return;
      const ue = ao(r.value), X = Math.round(Math.abs(r.value / B.value) + 0.15);
      S(u.value + ue * X), r.value = 0, k.value = void 0, _();
    }
    const H = M(
      ["rootClass", "o-carousel"],
      [
        "overlayClass",
        "o-carousel__overlay",
        null,
        o(() => a.overlay)
      ]
    ), J = M(["wrapperClass", "o-carousel__wrapper"]), j = M(
      ["itemsClass", "o-carousel__items"],
      ["itemsDraggingClass", "o-carousel__items--dragging", null, m]
    ), ye = M(
      ["iconClass", "o-carousel__icon"],
      ["iconPrevClass", "o-carousel__icon-prev"]
    ), Se = M(
      ["iconClass", "o-carousel__icon"],
      ["iconNextClass", "o-carousel__icon-next"]
    ), Ne = M(
      ["iconClass", "o-carousel__icon"],
      ["iconAutoplayClass", "o-carousel__icon-autoplay"]
    ), Ue = M(
      ["indicatorsClass", "o-carousel__indicators"],
      [
        "indicatorsInsideClass",
        "o-carousel__indicators--inside",
        null,
        o(() => !!a.indicatorInside)
      ],
      [
        "indicatorsPositionClass",
        "o-carousel__indicators--",
        o(() => a.indicatorPosition),
        o(() => !!a.indicatorPosition)
      ]
    ), Qe = M([
      "indicatorClass",
      "o-carousel__indicator"
    ]), je = M(
      ["indicatorItemClass", "o-carousel__indicator__item"],
      [
        "indicatorItemStyleClass",
        "o-carousel__indicator__item--",
        o(() => a.indicatorStyle),
        o(() => !!a.indicatorStyle)
      ]
    ), gt = M([
      "indicatorItemActiveClass",
      "o-carousel__indicator__item--active"
    ]);
    function yt(ue) {
      const X = u.value === ue.index ? gt.value : [];
      return [...je.value, ...X];
    }
    return (ue, X) => (p(), A("div", {
      ref: "rootElement",
      "data-oruga": "carousel",
      class: N(i(H)),
      role: "region",
      "aria-roledescription": "carousel",
      onMouseover: Y,
      onMouseleave: E,
      onFocusin: Y,
      onFocusout: E,
      onKeydown: [
        oe(z, ["left"]),
        oe(O, ["right"]),
        oe(re(K, ["prevent"]), ["home"]),
        oe(re(U, ["prevent"]), ["end"])
      ]
    }, [
      pe("div", {
        class: N(i(J))
      }, [
        ae(ue.$slots, "pause", {
          autoplay: !$.value,
          toggle: Z
        }, () => [
          ue.autoplay ? (p(), se(Te, {
            key: 0,
            class: N(i(Ne)),
            pack: ue.iconPack,
            icon: $.value ? ue.iconAutoplayResume : ue.iconAutoplayPause,
            size: ue.iconSize,
            both: "",
            role: "button",
            tabindex: "0",
            "aria-label": $.value ? ue.ariaAutoplayResumeLabel : ue.ariaAutoplayPauseLabel,
            onClick: Z,
            onKeydown: [
              oe(re(Z, ["prevent"]), ["enter"]),
              oe(re(Z, ["prevent"]), ["space"])
            ]
          }, null, 8, ["class", "pack", "icon", "size", "aria-label", "onKeydown"])) : Q("", !0)
        ]),
        ae(ue.$slots, "arrow", {
          hasPrev: h.value,
          prev: z,
          hasNext: F.value,
          next: O
        }, () => [
          ue.arrows ? (p(), A(ve, { key: 0 }, [
            Be(he(Te, {
              class: N(i(ye)),
              pack: ue.iconPack,
              icon: ue.iconPrev,
              size: ue.iconSize,
              both: "",
              role: "button",
              tabindex: "0",
              "aria-label": ue.ariaPreviousLabel,
              onClick: z,
              onKeydown: [
                oe(re(z, ["prevent"]), ["enter"]),
                oe(re(z, ["prevent"]), ["space"])
              ]
            }, null, 8, ["class", "pack", "icon", "size", "aria-label", "onKeydown"]), [
              [Oe, P.value && h.value]
            ]),
            Be(he(Te, {
              class: N(i(Se)),
              pack: ue.iconPack,
              icon: ue.iconNext,
              size: ue.iconSize,
              both: "",
              role: "button",
              tabindex: "0",
              "aria-label": ue.ariaNextLabel,
              onClick: O,
              onKeydown: [
                oe(re(O, ["prevent"]), ["enter"]),
                oe(re(O, ["prevent"]), ["space"])
              ]
            }, null, 8, ["class", "pack", "icon", "size", "aria-label", "onKeydown"]), [
              [Oe, P.value && F.value]
            ])
          ], 64)) : Q("", !0)
        ]),
        pe("div", {
          class: N(i(j)),
          style: Xe("transform:translateX(" + R.value + "px)"),
          "aria-roledescription": "carousel-slide",
          "aria-atomic": "false",
          "aria-live": ue.autoplay ? "off" : "polite",
          onDragend: W,
          onDragover: te,
          onTouchmove: te,
          onTouchend: W
        }, [
          ae(ue.$slots, "default")
        ], 46, Oo)
      ], 2),
      ae(ue.$slots, "indicators", {
        active: u.value,
        switchTo: S
      }, () => [
        ue.indicators ? (p(), A("div", {
          key: 0,
          class: N(i(Ue)),
          role: "tablist",
          "aria-label": "Slides"
        }, [
          (p(!0), A(ve, null, $e(y.value, (G) => (p(), A("div", {
            id: `carousel-${G.identifier}`,
            key: G.index,
            class: N(i(Qe)),
            role: "tab",
            tabindex: t.modelValue === G.index ? "0" : "-1",
            "aria-label": `Slide ${G.identifier}`,
            "aria-controls": `carouselpanel-${G.identifier}`,
            "aria-selected": t.modelValue === G.index,
            onClick: (D) => T(G),
            onKeydown: [
              oe((D) => T(G), ["enter"]),
              oe((D) => T(G), ["space"])
            ]
          }, [
            ae(ue.$slots, "indicator", {
              index: G.index
            }, () => [
              pe("span", {
                class: N(yt(G))
              }, null, 2)
            ])
          ], 42, Vo))), 128))
        ], 2)) : Q("", !0)
      ]),
      ue.overlay ? ae(ue.$slots, "overlay", { key: 0 }) : Q("", !0)
    ], 42, Mo));
  }
}), zo = ["id", "data-id", "role", "aria-labelledby", "aria-label"], To = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OCarouselItem",
  configField: "carousel",
  __name: "CarouselItem",
  props: {
    override: { type: Boolean, default: void 0 },
    clickable: { type: Boolean, default: !1 },
    itemClass: {},
    itemActiveClass: {},
    itemClickableClass: {}
  },
  setup(t) {
    const l = t, { parent: a, item: e } = pt(), s = o(() => a.value.activeIndex === e.value.index), d = o(() => ({ width: `${a.value.itemWidth}px` }));
    function g(c) {
      s.value && a.value.onClick(c), l.clickable && a.value.setActive(e.value.index);
    }
    const u = M(
      ["itemClass", "o-carousel__item"],
      ["itemActiveClass", "o-carousel__item--active", null, s],
      [
        "itemClickableClass",
        "o-carousel__item--clickable",
        null,
        o(() => l.clickable)
      ]
    );
    return (c, y) => (p(), A("div", {
      id: `carouselpanel-${i(e).identifier}`,
      "data-oruga": "carousel-item",
      "data-id": `carousel-${i(e).identifier}`,
      class: N(i(u)),
      style: Xe(d.value),
      role: i(a).indicators ? "tabpanel" : "group",
      "aria-labelledby": `carousel-${i(e).identifier}`,
      "aria-roledescription": "slide",
      "aria-label": `${i(e).index + 1} of ${i(a).total}`,
      draggable: "true",
      onClick: g,
      onKeydown: [
        oe(g, ["enter"]),
        oe(g, ["space"])
      ],
      onDragstart: y[0] || (y[0] = //@ts-ignore
      (...f) => i(a).onDrag && i(a).onDrag(...f)),
      onTouchstart: y[1] || (y[1] = //@ts-ignore
      (...f) => i(a).onDrag && i(a).onDrag(...f))
    }, [
      ae(c.$slots, "default")
    ], 46, zo));
  }
}), Ro = {
  install(t) {
    Ie(t, Ao), Ie(t, To);
  }
}, Lo = ["id", "name", "value", "true-value", "false-value", "required", "indeterminate", "disabled", "autocomplete", "aria-checked", "aria-labelledby"], Eo = ["id", "for"], Ft = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OCheckbox",
  configField: "checkbox",
  inheritAttrs: !1,
  __name: "Checkbox",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    variant: { default: () => n("checkbox.variant") },
    size: { default: () => n("checkbox.size") },
    label: { default: void 0 },
    indeterminate: { type: Boolean, default: !1 },
    nativeValue: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    name: { default: void 0 },
    trueValue: { default: void 0 },
    falseValue: { default: void 0 },
    autocomplete: { default: () => n("checkbox.autocomplete", "off") },
    id: { default: () => Le() },
    useHtml5Validation: { type: Boolean, default: () => n("useHtml5Validation", !0) },
    customValidity: { type: [String, Function], default: "" },
    rootClass: {},
    sizeClass: {},
    variantClass: {},
    disabledClass: {},
    checkedClass: {},
    indeterminateClass: {},
    inputClass: {},
    labelClass: {}
  }, {
    modelValue: { default: void 0 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:model-value", "input", "focus", "blur", "invalid"], ["update:modelValue"]),
  setup(t, { expose: l, emit: a }) {
    var K, U;
    const e = t, s = a, d = Me("inputElement"), { onBlur: g, onFocus: u, onInvalid: c, setFocus: y } = et(
      d,
      s,
      e
    ), { parentField: f } = Ge(), v = f.value || e.label || vt().default ? ((K = f.value) == null ? void 0 : K.labelId) || Le() : void 0;
    !e.label && e.id && ((U = f.value) == null || U.setInputId(e.id));
    const I = Pe(t, "modelValue"), C = o(
      () => I.value === (e.trueValue ?? !0) || Array.isArray(I.value) && I.value.includes(e.nativeValue)
    );
    function B(S) {
      s("input", I.value, S);
    }
    const P = it(), h = o(() => {
      var S;
      return {
        ...(S = f.value) == null ? void 0 : S.inputAttrs,
        ...P
      };
    }), z = M(
      ["rootClass", "o-checkbox"],
      [
        "sizeClass",
        "o-checkbox--",
        o(() => e.size),
        o(() => !!e.size)
      ],
      [
        "variantClass",
        "o-checkbox--",
        o(() => e.variant),
        o(() => !!e.variant)
      ],
      [
        "disabledClass",
        "o-checkbox--disabled",
        null,
        o(() => e.disabled)
      ],
      ["checkedClass", "o-checkbox--checked", null, C],
      [
        "indeterminateClass",
        "o-checkbox--indeterminate",
        null,
        o(() => e.indeterminate)
      ]
    ), F = M(["inputClass", "o-checkbox__input"]), O = M(["labelClass", "o-checkbox__label"]);
    return l({ focus: y, value: I }), (S, T) => (p(), A("div", {
      "data-oruga": "checkbox",
      class: N(i(z))
    }, [
      Be(pe("input", fe(h.value, {
        id: S.id,
        ref: "inputElement",
        "onUpdate:modelValue": T[0] || (T[0] = (w) => I.value = w),
        type: "checkbox",
        "data-oruga-input": "checkbox",
        class: i(F),
        name: S.name,
        value: S.nativeValue,
        "true-value": S.trueValue ?? !0,
        "false-value": S.falseValue ?? !1,
        required: S.required,
        indeterminate: S.indeterminate,
        disabled: S.disabled,
        autocomplete: S.autocomplete,
        "aria-checked": S.indeterminate ? "mixed" : C.value,
        "aria-labelledby": i(v),
        onBlur: T[1] || (T[1] = //@ts-ignore
        (...w) => i(g) && i(g)(...w)),
        onFocus: T[2] || (T[2] = //@ts-ignore
        (...w) => i(u) && i(u)(...w)),
        onInvalid: T[3] || (T[3] = //@ts-ignore
        (...w) => i(c) && i(c)(...w)),
        onChange: B
      }), null, 16, Lo), [
        [Ya, I.value]
      ]),
      S.label || S.$slots.default ? (p(), A("label", {
        key: 0,
        id: i(v),
        for: S.id,
        class: N(i(O))
      }, [
        ae(S.$slots, "default", {}, () => [
          Ve(ce(S.label), 1)
        ])
      ], 10, Eo)) : Q("", !0)
    ], 2));
  }
}), Ho = {
  install(t) {
    Ie(t, Ft);
  }
}, No = ["id", "aria-controls", "aria-expanded"], xo = ["id", "aria-labelledby"], Yo = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OCollapse",
  configField: "collapse",
  __name: "Collapse",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    open: { type: Boolean, default: !0 },
    animation: { default: () => n("collapse.animation", "fade") },
    position: { default: () => n("collapse.position", "top") },
    expanded: { type: Boolean, default: !1 },
    contentId: { default: () => Le() },
    triggerId: { default: () => Le() },
    rootClass: {},
    expandedClass: {},
    positionClass: {},
    triggerClass: {},
    contentClass: {}
  }, {
    open: { type: Boolean, default: !0 },
    openModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:open", "open", "close"], ["update:open"]),
  setup(t, { emit: l }) {
    const a = t, e = l, s = Pe(t, "open");
    function d() {
      s.value = !s.value, s.value ? e("open") : e("close");
    }
    const g = M(
      ["rootClass", "o-collapse"],
      [
        "positionClass",
        "o-collapse--",
        o(() => a.position),
        o(() => !!a.position)
      ]
    ), u = M(
      ["triggerClass", "o-collapse__trigger"],
      [
        "expandedClass",
        "o-collapse__trigger--expanded",
        null,
        o(() => a.expanded)
      ]
    ), c = M(["contentClass", "o-collapse__content"]);
    return (y, f) => (p(), A("div", {
      "data-oruga": "collapse",
      class: N(i(g))
    }, [
      pe("div", {
        id: y.triggerId,
        class: N(i(u)),
        role: "button",
        tabindex: "0",
        "aria-controls": y.contentId,
        "aria-expanded": s.value,
        onClick: d,
        onKeydown: [
          oe(d, ["enter"]),
          oe(d, ["space"])
        ]
      }, [
        ae(y.$slots, "trigger", { open: s.value })
      ], 42, No),
      he(Je, { name: y.animation }, {
        default: de(() => [
          Be(pe("div", {
            id: y.contentId,
            class: N(i(c)),
            "aria-labelledby": y.triggerId
          }, [
            ae(y.$slots, "default")
          ], 10, xo), [
            [Oe, s.value]
          ])
        ]),
        _: 3
      }, 8, ["name"])
    ], 2));
  }
}), Wo = {
  install(t) {
    Ie(t, Yo);
  }
}, Ko = ["id", "autocomplete", "multiple", "size", "disabled", "required"], Uo = {
  key: 0,
  value: "",
  disabled: "",
  hidden: ""
}, qo = ["label", "value"], jo = ["value", "selected"], Xo = ["value", "selected"], ft = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OSelect",
  configField: "select",
  inheritAttrs: !1,
  __name: "Select",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    multiple: {},
    options: { default: void 0 },
    size: { default: () => n("select.size") },
    variant: { default: () => n("select.variant") },
    placeholder: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    expanded: { type: Boolean, default: !1 },
    rounded: { type: Boolean, default: !1 },
    nativeSize: { default: void 0 },
    iconPack: { default: () => n("select.iconPack") },
    icon: { default: () => n("select.icon") },
    iconClickable: { type: Boolean, default: !1 },
    iconRight: { default: () => n("select.iconRight") },
    iconRightClickable: { type: Boolean, default: !1 },
    iconRightVariant: { default: void 0 },
    id: { default: () => Le() },
    autocomplete: { default: () => n("select.autocomplete", "off") },
    statusIcon: { type: Boolean, default: () => n("statusIcon", !0) },
    useHtml5Validation: { type: Boolean, default: () => n("useHtml5Validation", !0) },
    customValidity: {},
    rootClass: {},
    sizeClass: {},
    variantClass: {},
    expandedClass: {},
    disabledClass: {},
    roundedClass: {},
    hasIconRightClass: {},
    multipleClass: {},
    selectClass: {},
    placeholderClass: {},
    arrowedClass: {},
    iconLeftSpaceClass: {},
    iconRightSpaceClass: {},
    iconLeftClass: {},
    iconRightClass: {}
  }, {
    modelValue: {
      default: void 0
    },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:model-value", "focus", "blur", "invalid", "icon-click", "icon-right-click"], ["update:modelValue"]),
  setup(t, { expose: l, emit: a }) {
    var q;
    const e = t, s = a, d = Me("selectElement"), { checkHtml5Validity: g, onBlur: u, onFocus: c, onInvalid: y, setFocus: f, isValid: v } = et(d, s, e), { parentField: I, statusVariant: C, statusVariantIcon: B } = Ge();
    e.id && ((q = I == null ? void 0 : I.value) == null || q.setInputId(e.id));
    const P = Pe(t, "modelValue", {
      get: (k) => typeof k < "u" ? k : e.multiple ? [] : "",
      set: (k) => typeof k < "u" ? k : e.multiple ? [] : void 0
    });
    be(
      P,
      (k) => {
        I != null && I.value && I.value.setFilled(!!k), v.value || g();
      },
      { immediate: !0, flush: "post" }
    );
    const { nextSequence: h } = ut(), z = o(
      () => dt(e.options, h)
    ), F = o(
      () => !we(e.multiple) && (!ke(P.value) || P.value === "")
    ), O = o(
      () => !!e.iconRight && !we(e.multiple) || e.statusIcon && !!B.value
    ), K = o(
      () => e.iconRight ? e.iconRight : B.value
    ), U = o(
      () => e.iconRight ? e.iconRightVariant || e.variant : C.value
    );
    function S(k, r) {
      s(k, r), ze(() => f());
    }
    function T(k) {
      e.iconClickable && S("icon-click", k);
    }
    function w(k) {
      e.iconRightClickable && S("icon-right-click", k);
    }
    const V = it(), $ = o(() => {
      var k;
      return {
        ...(k = I == null ? void 0 : I.value) == null ? void 0 : k.inputAttrs,
        ...V
      };
    }), Y = M(
      ["rootClass", "o-select"],
      [
        "sizeClass",
        "o-select--",
        o(() => e.size),
        o(() => !!e.size)
      ],
      [
        "variantClass",
        "o-select--",
        o(() => C.value || e.variant),
        o(() => !!C.value || !!e.variant)
      ],
      [
        "expandedClass",
        "o-select--expanded",
        null,
        o(() => e.expanded)
      ],
      [
        "disabledClass",
        "o-select--disabled",
        null,
        o(() => we(e.disabled))
      ],
      [
        "roundedClass",
        "o-select--rounded",
        null,
        o(() => we(e.rounded))
      ],
      ["hasIconRightClass", "o-select--icon-right", null, O],
      [
        "multipleClass",
        "o-select--multiple",
        null,
        o(() => we(e.multiple))
      ]
    ), E = M(
      ["selectClass", "o-select__input"],
      [
        "iconLeftSpaceClass",
        "o-select__input--iconspace-left",
        null,
        o(() => !!e.icon)
      ],
      [
        "iconRightSpaceClass",
        "o-select__input--iconspace-right",
        null,
        O
      ],
      [
        "placeholderClass",
        "o-select__input--placeholder",
        null,
        F
      ],
      [
        "arrowedClass",
        "o-select__input--arrowed",
        null,
        o(() => !O.value && !we(e.multiple))
      ]
    ), Z = M(["iconLeftClass", "o-select__icon-left"]), _ = M([
      "iconRightClass",
      "o-select__icon-right"
    ]);
    return l({ focus: f, value: P }), (k, r) => (p(), A("div", {
      "data-oruga": "select",
      class: N(i(Y))
    }, [
      k.icon ? (p(), se(Te, {
        key: 0,
        class: N(i(Z)),
        clickable: k.iconClickable,
        icon: k.icon,
        pack: k.iconPack,
        size: k.size,
        onClick: r[0] || (r[0] = (m) => T(m))
      }, null, 8, ["class", "clickable", "icon", "pack", "size"])) : Q("", !0),
      Be(pe("select", fe($.value, {
        id: k.id,
        ref: "selectElement",
        "onUpdate:modelValue": r[1] || (r[1] = (m) => P.value = m),
        "data-oruga-input": "select",
        class: i(E),
        autocomplete: k.autocomplete,
        multiple: e.multiple,
        size: k.nativeSize,
        disabled: k.disabled,
        required: k.required,
        onBlur: r[2] || (r[2] = //@ts-ignore
        (...m) => i(u) && i(u)(...m)),
        onFocus: r[3] || (r[3] = //@ts-ignore
        (...m) => i(c) && i(c)(...m)),
        onInvalid: r[4] || (r[4] = //@ts-ignore
        (...m) => i(y) && i(y)(...m))
      }), [
        k.placeholder || k.$slots.placeholder ? (p(), A(ve, { key: 0 }, [
          F.value ? (p(), A("option", Uo, [
            ae(k.$slots, "placeholder", {}, () => [
              Ve(ce(k.placeholder), 1)
            ])
          ])) : Q("", !0)
        ], 64)) : Q("", !0),
        ae(k.$slots, "default", {}, () => [
          (p(!0), A(ve, null, $e(z.value, (m) => (p(), A(ve, {
            key: m.key
          }, [
            i(Bt)(m) ? Be((p(), A("optgroup", fe({
              key: 0,
              ref_for: !0
            }, m.attrs, {
              label: m.label,
              value: m.value
            }), [
              (p(!0), A(ve, null, $e(m.options, (R) => Be((p(), A("option", fe({ ref_for: !0 }, R.attrs, {
                key: R.key,
                value: R.value,
                selected: m.value === P.value
              }), ce(R.label), 17, jo)), [
                [Oe, !R.hidden]
              ])), 128))
            ], 16, qo)), [
              [Oe, !m.hidden]
            ]) : Be((p(), A("option", fe({
              key: 1,
              ref_for: !0
            }, m.attrs, {
              value: m.value,
              selected: m.value === P.value
            }), ce(m.label), 17, Xo)), [
              [Oe, !m.hidden]
            ])
          ], 64))), 128))
        ])
      ], 16, Ko), [
        [Gl, P.value]
      ]),
      O.value ? (p(), se(Te, {
        key: 1,
        class: N(i(_)),
        clickable: k.iconRightClickable,
        icon: K.value,
        pack: k.iconPack,
        size: k.size,
        variant: U.value,
        both: "",
        onClick: w
      }, null, 8, ["class", "clickable", "icon", "pack", "size", "variant"])) : Q("", !0)
    ], 2));
  }
}), Go = ["data-oruga"], ll = /* @__PURE__ */ Ce({
  name: "OPickerWrapper",
  __name: "PickerWrapper",
  props: /* @__PURE__ */ ge({
    /** the internal input value */
    value: {
      type: [Date, Array],
      default: void 0
    },
    /** the active state of the dropdown */
    active: { type: Boolean, default: !1 },
    /** parent picker component props  */
    pickerProps: { type: Object, required: !0 },
    /** data-oruga attribute value */
    dataOruga: { type: String, required: !0 },
    /** format props value to input value */
    formatter: {
      type: Function,
      required: !0
    },
    /** parse input value to props value */
    parser: {
      type: Function,
      required: !0
    },
    type: { type: String, required: !0 },
    step: { type: String, default: void 0 },
    min: { type: Date, default: void 0 },
    max: { type: Date, default: void 0 },
    stayOpen: { type: Boolean, default: !1 },
    /** the DateTimeFormat object to watch for to update the parsed input value */
    dtf: { type: Object, default: void 0 },
    rootClasses: { type: Array, required: !0 },
    dropdownClasses: { type: Array, required: !0 },
    boxClass: { type: Array, required: !0 }
  }, {
    active: { type: Boolean, default: !1 },
    activeModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:value", "update:active", "focus", "blur", "invalid", "icon-click", "icon-right-click", "left", "right"], ["update:active"]),
  setup(t, { expose: l, emit: a }) {
    const e = t, s = a, d = o(
      () => !we(e.pickerProps.inline) && we(e.pickerProps.mobileNative) && ct.any()
    ), { parentField: g } = Ge(), u = Me("dropdownComponent"), c = Me("inputComponent"), y = Me("nativeInputComponent"), f = o(
      () => d.value ? y.value : c.value
    ), {
      input: v,
      checkHtml5Validity: I,
      setFocus: C,
      onBlur: B,
      onFocus: P,
      onInvalid: h,
      isValid: z
    } = et(f, s, e.pickerProps), F = !ke(e.pickerProps.placeholder) || we(e.value) ? e.type : "text", O = ne("");
    be(
      () => e.value,
      (L) => {
        O.value = e.formatter(L, d.value), !d.value && !e.stayOpen && V(!1), z.value || I();
      },
      { immediate: !0 }
    ), be(
      () => e.dtf,
      () => K(O.value)
    );
    function K(L) {
      let te = e.parser(L, d.value);
      Array.isArray(te) ? te = te.map(U) : ke(te) && (te = U(te)), ze(
        () => (
          // reparse to string for internal value
          O.value = e.formatter(te, d.value)
        )
      ), s("update:value", te);
    }
    function U(L) {
      return lt(L) && (e.min && L < e.min ? L = e.min : e.max && L > e.max && (L = e.max)), L;
    }
    const S = Pe(t, "active");
    be(S, Y);
    const T = o(
      () => we(e.pickerProps.openOnFocus) ? ["click"] : []
    );
    Ee && mt(document, "keyup", w);
    function w(L) {
      S.value && (L.key === "Escape" || L.key === "Esc") && V(!1);
    }
    function V(L) {
      u.value && (L || we(e.pickerProps.closeOnClick)) && ze(() => S.value = L);
    }
    function $(L) {
      S.value && L.stopPropagation();
    }
    function Y(L) {
      L ? P(new Event("focus")) : L || B(new Event("blur"));
    }
    function E(L) {
      K(L.target.value);
    }
    function Z(L) {
      !d.value || !v.value || v.value.type === "text" && (L.preventDefault(), L.stopPropagation(), v.value.blur(), setTimeout(() => {
        v.value && (v.value.readOnly = !1, v.value.type = e.type, C());
      }, 50));
    }
    function _(L) {
      !d.value || !v.value || (v.value.type === "text" ? (L.preventDefault(), L.stopPropagation()) : P(L));
    }
    function q(L) {
      !d.value || !v.value || (v.value.value || (v.value.readOnly = !0, v.value.type = "text"), B(L));
    }
    function k(L) {
      const te = L.target.value ? L.target.value : "";
      !te && v.value && (v.value.value = te, v.value.blur()), K(te);
    }
    const r = it(), m = o(() => {
      var L;
      return {
        ...(L = g == null ? void 0 : g.value) == null ? void 0 : L.inputAttrs,
        ...r,
        inputClass: e.pickerProps.inputClass,
        ...e.pickerProps.inputClasses
      };
    }), R = o(() => ({
      "root-class": Ke(e.dropdownClasses),
      "teleport-class": Ke(e.rootClasses),
      ...e.pickerProps.dropdownClasses
    }));
    return l({ focus: C }), (L, te) => (p(), A("div", {
      "data-oruga": t.dataOruga,
      class: N(t.rootClasses),
      onClick: Z
    }, [
      d.value ? ae(L.$slots, "trigger", { key: 1 }, () => [
        he(Pt, fe({ ref: "nativeInputComponent" }, m.value, {
          modelValue: O.value,
          "onUpdate:modelValue": te[7] || (te[7] = (W) => O.value = W),
          type: i(F),
          min: t.formatter(t.min, !0),
          max: t.formatter(t.max, !0),
          step: t.step,
          placeholder: t.pickerProps.placeholder,
          size: t.pickerProps.size,
          "icon-pack": t.pickerProps.iconPack,
          icon: t.pickerProps.icon,
          "icon-right": t.pickerProps.iconRight,
          "icon-right-clickable": t.pickerProps.iconRightClickable,
          rounded: t.pickerProps.rounded,
          disabled: t.pickerProps.disabled,
          readonly: i(F) == "text",
          autocomplete: "off",
          "use-html5-validation": !1,
          onChange: k,
          onFocus: _,
          onBlur: q,
          onInvalid: i(h),
          onIconClick: te[8] || (te[8] = (W) => L.$emit("icon-click", W)),
          onIconRightClick: te[9] || (te[9] = (W) => L.$emit("icon-right-click", W))
        }), null, 16, ["modelValue", "type", "min", "max", "step", "placeholder", "size", "icon-pack", "icon", "icon-right", "icon-right-clickable", "rounded", "disabled", "readonly", "onInvalid"])
      ]) : (p(), se(wa, fe({
        key: 0,
        ref: "dropdownComponent"
      }, R.value, {
        active: S.value,
        "onUpdate:active": te[6] || (te[6] = (W) => S.value = W),
        triggers: T.value,
        position: t.pickerProps.position,
        disabled: t.pickerProps.disabled,
        inline: t.pickerProps.inline,
        "mobile-modal": t.pickerProps.mobileModal,
        "desktop-modal": t.pickerProps.desktopModal,
        "mobile-breakpoint": t.pickerProps.mobileBreakpoint,
        teleport: t.pickerProps.teleport
      }), Vt({
        default: de(() => [
          he(at, {
            override: "",
            tag: "div",
            "item-class": t.boxClass,
            disabled: t.pickerProps.disabled,
            clickable: !1,
            onKeydown: [
              te[4] || (te[4] = oe((W) => L.$emit("left", W), ["left"])),
              te[5] || (te[5] = oe((W) => L.$emit("right", W), ["right"]))
            ]
          }, {
            default: de(() => [
              ae(L.$slots, "default")
            ]),
            _: 3
          }, 8, ["item-class", "disabled"])
        ]),
        _: 2
      }, [
        t.pickerProps.inline ? void 0 : {
          name: "trigger",
          fn: de(() => [
            ae(L.$slots, "trigger", {}, () => [
              he(Pt, fe({ ref: "inputComponent" }, m.value, {
                modelValue: O.value,
                "onUpdate:modelValue": te[0] || (te[0] = (W) => O.value = W),
                placeholder: t.pickerProps.placeholder,
                size: t.pickerProps.size,
                "icon-pack": t.pickerProps.iconPack,
                icon: t.pickerProps.icon,
                "icon-right": t.pickerProps.iconRight,
                "icon-right-clickable": t.pickerProps.iconRightClickable,
                expanded: t.pickerProps.expanded,
                rounded: t.pickerProps.rounded,
                disabled: t.pickerProps.disabled,
                readonly: t.pickerProps.readonly,
                autocomplete: "off",
                "use-html5-validation": !1,
                onInvalid: i(h),
                onClick: $,
                onKeyup: te[1] || (te[1] = oe((W) => V(!0), ["enter"])),
                onChange: E,
                onFocus: i(P),
                onBlur: i(B),
                onIconClick: te[2] || (te[2] = (W) => L.$emit("icon-click", W)),
                onIconRightClick: te[3] || (te[3] = (W) => L.$emit("icon-right-click", W))
              }), null, 16, ["modelValue", "placeholder", "size", "icon-pack", "icon", "icon-right", "icon-right-clickable", "expanded", "rounded", "disabled", "readonly", "onInvalid", "onFocus", "onBlur"])
            ])
          ]),
          key: "0"
        }
      ]), 1040, ["active", "triggers", "position", "disabled", "inline", "mobile-modal", "desktop-modal", "mobile-breakpoint", "teleport"]))
    ], 10, Go));
  }
});
function Qo(t, l = "long") {
  const a = [];
  for (let s = 0; s < 12; s++)
    a.push(new Date(2e3, s, 15));
  const e = new Intl.DateTimeFormat(t, {
    month: l
  });
  return a.map((s) => e.format(s));
}
function Jo(t, l = 0, a = "narrow") {
  const e = [];
  for (let d = 1, g = 0; g < 7; d++) {
    const u = new Date(2e3, 0, d);
    (u.getDay() === l || g > 0) && (e.push(u), g++);
  }
  const s = new Intl.DateTimeFormat(t, {
    weekday: a
  });
  return e.map((d) => s.format(d));
}
function Pa(t, l) {
  var e;
  const a = l.match(t);
  return (
    // get the pattern as a string
    (e = t.toString().match(/<(.+?)>/g)) == null ? void 0 : e.map((s) => {
      const d = s.match(/<(.+)>/);
      if (!d || d.length <= 0)
        return null;
      const g = s.match(/<(.+)>/);
      return g && (g == null ? void 0 : g.length) > 1 ? g[1] : null;
    }).reduce((s, d, g) => (d === null || (a && a.length > g ? s[d] = a[g + 1] : s[d] = null), s), {})
  );
}
function Zo(t, l, a, e) {
  const s = new Date(a, l), d = [], g = new Date(a, l, t).getDay(), u = g >= e ? g - e : 7 - e + g;
  let c = 1;
  for (let f = 0; f < u; f++)
    d.unshift(
      new Date(
        s.getFullYear(),
        s.getMonth(),
        t - c
      )
    ), c++;
  d.push(new Date(a, l, t));
  let y = 1;
  for (; d.length < 7; )
    d.push(new Date(a, l, t + y)), y++;
  return d;
}
function va(t, l, a) {
  const e = 7 + l - a;
  return -((7 + new Date(t, 0, e).getDay() - l) % 7) + e - 1;
}
function _o(t) {
  return t % 4 === 0 && t % 100 !== 0 || t % 400 === 0 ? 366 : 365;
}
function ua(t, l, a) {
  const e = va(t, l, a), s = va(t + 1, l, a);
  return (_o(t) - e + s) / 7;
}
function oa(t) {
  function l(f, v) {
    const I = [];
    if (t.minDate && I.push(f >= t.minDate), t.maxDate && I.push(f <= t.maxDate), t.nearbyMonthDays && !t.nearbySelectableMonthDays && I.push(f.getMonth() === v), t.selectableDates)
      if (typeof t.selectableDates == "function") {
        if (t.selectableDates(f)) return !0;
        I.push(!1);
      } else
        for (let C = 0; C < t.selectableDates.length; C++) {
          const B = t.selectableDates[C];
          if (f.getDate() === B.getDate() && f.getFullYear() === B.getFullYear() && f.getMonth() === B.getMonth())
            return !0;
          I.push(!1);
        }
    if (t.unselectableDates)
      if (typeof t.unselectableDates == "function")
        I.push(!t.unselectableDates(f));
      else
        for (let C = 0; C < t.unselectableDates.length; C++) {
          const B = t.unselectableDates[C];
          I.push(
            f.getDate() !== B.getDate() || f.getFullYear() !== B.getFullYear() || f.getMonth() !== B.getMonth()
          );
        }
    if (t.unselectableDaysOfWeek)
      for (let C = 0; C < t.unselectableDaysOfWeek.length; C++) {
        const B = t.unselectableDaysOfWeek[C];
        I.push(f.getDay() !== B);
      }
    return I.indexOf(!1) < 0;
  }
  const a = o(() => t.type === "month"), e = o(
    () => new Intl.DateTimeFormat(t.locale, {
      year: "numeric",
      month: "numeric"
    }).resolvedOptions()
  ), s = o(
    () => new Intl.DateTimeFormat(
      t.locale
      /*, { timeZone: 'UTC' }*/
    )
  ), d = o(
    () => new Intl.DateTimeFormat(t.locale, {
      year: e.value.year || "numeric",
      month: e.value.month || "2-digit"
      // timeZone: 'UTC'
    })
  ), g = o(() => {
    const f = u();
    return f.setHours(10), f.setSeconds(0), f.setMinutes(0), f.setMilliseconds(0), f;
  });
  function u() {
    return typeof t.creator == "function" ? t.creator() : /* @__PURE__ */ new Date();
  }
  function c(f) {
    if (typeof t.formatter == "function") return t.formatter(f);
    if (!f) return "";
    const v = Array.isArray(f) ? f : [f];
    if (!v.length) return "";
    const I = v.map((C) => {
      const B = new Date(
        C.getFullYear(),
        C.getMonth(),
        C.getDate(),
        12
      );
      return a.value ? d.value.format(B) : s.value.format(B);
    });
    return !we(t.multiple) && !we(t.range) ? I.join(" - ") : I.join(", ");
  }
  function y(f) {
    if (typeof t.parser == "function") return t.parser(f);
    if (!f) return;
    const v = we(t.multiple) || we(t.range), C = (v ? f.split(", ") : [f]).map((B) => {
      if (s.value.formatToParts && typeof s.value.formatToParts == "function") {
        const F = (a.value ? d.value : s.value).formatToParts(g.value).map((K) => K.type === "literal" ? K.value : `((?!=<${K.type}>)\\d+)`).join(""), O = Pa(F, B);
        if (O.year && O.year.length === 4 && O.month && O.month <= 12) {
          if (a.value)
            return new Date(O.year, O.month - 1);
          if (O.day && O.day <= 31)
            return new Date(
              O.year,
              O.month - 1,
              O.day,
              12
            );
        }
      }
      if (!a.value) return new Date(Date.parse(B));
      const P = B.split("/"), h = P[0].length === 4 ? P[0] : P[1], z = P[0].length === 2 ? P[0] : P[1];
      if (h && z)
        return new Date(
          parseInt(h, 10),
          parseInt(z, 10) - 1,
          1,
          0,
          0,
          0,
          0
        );
    });
    return v ? C : C[0];
  }
  return {
    dtf: s,
    isDateSelectable: l,
    dateCreator: u,
    dateParser: y,
    dateFormatter: c
  };
}
const en = ["tabindex"], tn = ["tabindex", "onClick", "onMouseenter", "onFocus", "onKeydown"], an = /* @__PURE__ */ Ce({
  name: "ODatepickerTableRow",
  configField: "datepicker",
  __name: "DatepickerTableRow",
  props: {
    day: { type: Number, required: !0 },
    week: { type: Array, required: !0 },
    month: { type: Number, required: !0 },
    selectedDate: {
      type: [Date, Array],
      default: void 0
    },
    events: { type: Array, default: void 0 },
    hoveredDateRange: { type: Array, required: !0 },
    pickerProps: {
      type: Object,
      required: !0
    }
  },
  emits: ["select", "hover-enddate", "change-focus", "week-number-click"],
  setup(t, { emit: l }) {
    const a = t, e = l, { isDateSelectable: s, dateCreator: d } = oa(
      a.pickerProps
    ), g = o(() => {
      var $;
      return !!(($ = a.events) != null && $.length);
    }), u = ne(/* @__PURE__ */ new Map());
    function c($, Y) {
      const E = `day-${$.getMonth()}-${$.getDate()}`;
      Y && u.value.set(E, Y);
    }
    be(
      () => a.day,
      ($) => {
        a.week.map((Y) => Y.getDate()).includes($) && ze(() => {
          const Y = `day-${a.month}-${$}`, E = u.value.get(Y);
          E && E.focus();
        });
      }
    ), be(
      () => a.month,
      // clear day refs on month change
      () => u.value = /* @__PURE__ */ new Map()
    );
    function y($) {
      a.pickerProps.weekNumberClickable && e("week-number-click", $);
    }
    function f($) {
      return Math.round(
        ($.getTime() - new Date($.getFullYear(), 0, 1).getTime()) / 864e5
      ) + 1;
    }
    function v($) {
      const Y = a.pickerProps.firstDayOfWeek, E = a.pickerProps.rulesForFirstWeek, Z = va($.getFullYear(), Y, E), _ = Math.floor((f($) - Z - 1) / 7) + 1;
      let q, k;
      return _ < 1 ? (k = $.getFullYear() - 1, q = _ + ua(k, Y, E)) : _ > ua($.getFullYear(), Y, E) ? (q = _ - ua($.getFullYear(), Y, E), k = $.getFullYear() + 1) : (k = $.getFullYear(), q = _), q;
    }
    function I($) {
      var Y;
      return (Y = a.events) != null && Y.length ? a.events.filter((E) => E.date.getDay() === $.getDay()) : [];
    }
    function C($, Y) {
      let E = !0;
      switch ($.key) {
        case "Tab": {
          E = !1;
          break;
        }
        case " ":
        case "Space":
        case "Spacebar":
        case "Enter": {
          B(Y);
          break;
        }
        case "ArrowLeft":
        case "Left": {
          P(Y, -1);
          break;
        }
        case "ArrowRight":
        case "Right": {
          P(Y, 1);
          break;
        }
        case "ArrowUp":
        case "Up": {
          P(Y, -7);
          break;
        }
        case "ArrowDown":
        case "Down": {
          P(Y, 7);
          break;
        }
      }
      E && $.preventDefault();
    }
    function B($) {
      a.pickerProps.disabled || a.pickerProps.readonly || s($, a.month) && e("select", $);
    }
    function P($, Y) {
      const E = new Date($.getTime());
      for (E.setDate($.getDate() + Y); a.pickerProps.minDate && E < a.pickerProps.minDate || a.pickerProps.maxDate && E > a.pickerProps.maxDate || !s(E, E.getMonth()); )
        E.setDate(E.getDate() - Math.sign(Y));
      h(E), e("change-focus", E);
    }
    function h($) {
      we(a.pickerProps.range) && e("hover-enddate", $);
    }
    function z($, Y, E = !1) {
      return !$ || !Y || E ? !1 : Array.isArray(Y) ? Y.some(
        (Z) => $.getDate() === Z.getDate() && $.getFullYear() === Z.getFullYear() && $.getMonth() === Z.getMonth()
      ) : $.getDate() === Y.getDate() && $.getFullYear() === Y.getFullYear() && $.getMonth() === Y.getMonth();
    }
    function F($, Y, E = !1) {
      return !Array.isArray(Y) || E ? !1 : $ > Y[0] && $ < Y[1];
    }
    const O = ma();
    ea(() => O.stop());
    function K($) {
      const Y = M(
        [
          "tableCellSelectedClass",
          "o-datepicker__table__cell--selected",
          null,
          z($, a.selectedDate) || F(
            $,
            a.selectedDate,
            we(a.pickerProps.multiple)
          )
        ],
        [
          "tableCellFirstSelectedClass",
          "o-datepicker__table__cell--first-selected",
          null,
          z(
            $,
            Array.isArray(a.selectedDate) ? a.selectedDate[0] : void 0,
            we(a.pickerProps.multiple)
          )
        ],
        [
          "tableCellWithinSelectedClass",
          "o-datepicker__table__cell--within-selected",
          null,
          F(
            $,
            a.selectedDate,
            we(a.pickerProps.multiple)
          )
        ],
        [
          "tableCellLastSelectedClass",
          "o-datepicker__table__cell--last-selected",
          null,
          z(
            $,
            Array.isArray(a.selectedDate) ? a.selectedDate[1] : void 0,
            we(a.pickerProps.multiple)
          )
        ],
        [
          "tableCellFirstHoveredClass",
          "o-datepicker__table__cell--first-hovered",
          null,
          z(
            $,
            Array.isArray(a.hoveredDateRange) ? a.hoveredDateRange[0] : void 0
          )
        ],
        [
          "tableCellWithinHoveredClass",
          "o-datepicker__table__cell--within-hovered",
          null,
          F($, a.hoveredDateRange)
        ],
        [
          "tableCellLastHoveredClass",
          "o-datepicker__table__cell--last-hovered",
          null,
          z(
            $,
            Array.isArray(a.hoveredDateRange) ? a.hoveredDateRange[1] : void 0
          )
        ],
        [
          "tableCellTodayClass",
          "o-datepicker__table__cell--today",
          null,
          z($, d())
        ],
        [
          "tableCellSelectableClass",
          "o-datepicker__table__cell--selectable",
          null,
          s($, a.month) && !a.pickerProps.disabled && !a.pickerProps.readonly
        ],
        [
          "tableCellUnselectableClass",
          "o-datepicker__table__cell--unselectable",
          null,
          !s($, a.month) || a.pickerProps.disabled
        ],
        [
          "tableCellInvisibleClass",
          "o-datepicker__table__cell--invisible",
          null,
          !a.pickerProps.nearbyMonthDays && $.getMonth() !== a.month
        ],
        [
          "tableCellNearbyClass",
          "o-datepicker__table__cell--nearby",
          null,
          a.pickerProps.nearbySelectableMonthDays && $.getMonth() !== a.month
        ],
        // pass effect scope for rectivity binding
        { scope: O }
      );
      return [
        ...T.value,
        ...V.value,
        ...Y.value
      ];
    }
    function U($) {
      return M(
        ["tableEventClass", "o-datepicker__table__event"],
        [
          "tableEventVariantClass",
          "o-datepicker__table__event--",
          $.type,
          !!$.type
        ],
        [
          "tableEventIndicatorClass",
          "o-datepicker__table__event--",
          a.pickerProps.indicators,
          !!a.pickerProps.indicators
        ],
        // pass effect scope for rectivity binding
        { scope: O }
      ).value;
    }
    const S = M(
      ["tableRowClass", "o-datepicker__table__row"],
      // passing the picker props will add reactivity to property changes
      { props: a.pickerProps }
    ), T = M(
      ["tableCellClass", "o-datepicker__table__cell"],
      // passing the picker props will add reactivity to property changes
      { props: a.pickerProps }
    ), w = M(
      ["tableEventsClass", "o-datepicker__table__events"],
      // passing the picker props will add reactivity to property changes
      { props: a.pickerProps }
    ), V = M(
      [
        "tableCellEventsClass",
        "o-datepicker__table__cell--events",
        null,
        g
      ],
      // passing the picker props will add reactivity to property changes
      { props: a.pickerProps }
    );
    return ($, Y) => (p(), A("div", {
      class: N(i(S))
    }, [
      t.pickerProps.showWeekNumber ? (p(), A("div", {
        key: 0,
        class: N(i(T)),
        style: Xe({
          cursor: t.pickerProps.weekNumberClickable ? "pointer" : "auto"
        }),
        tabindex: t.pickerProps.weekNumberClickable ? 0 : void 0,
        role: "button",
        onClick: Y[0] || (Y[0] = re((E) => y(v(t.week[6])), ["prevent"])),
        onKeydown: Y[1] || (Y[1] = oe(re((E) => y(v(t.week[6])), ["prevent"]), ["enter"]))
      }, [
        pe("span", null, ce(v(t.week[6])), 1)
      ], 46, en)) : Q("", !0),
      (p(!0), A(ve, null, $e(t.week, (E, Z) => (p(), A(ve, { key: Z }, [
        !t.pickerProps.disabled && !t.pickerProps.readonly && i(s)(E, t.month) ? (p(), A("div", {
          key: 0,
          ref_for: !0,
          ref: (_) => c(E, _),
          class: N(K(E)),
          role: "button",
          tabindex: t.day === E.getDate() && t.month === E.getMonth() ? void 0 : 0,
          onClick: re((_) => B(E), ["prevent"]),
          onMouseenter: (_) => h(E),
          onFocus: (_) => h(E),
          onKeydown: oe(re((_) => C(_, E), ["prevent"]), ["enter"])
        }, [
          pe("span", null, ce(E.getDate()), 1),
          I(E).length ? (p(), A("div", {
            key: 0,
            class: N(i(w))
          }, [
            (p(!0), A(ve, null, $e(I(E), (_, q) => (p(), A("div", {
              key: q,
              class: N(U(_))
            }, null, 2))), 128))
          ], 2)) : Q("", !0)
        ], 42, tn)) : (p(), A("div", {
          key: 1,
          class: N(K(E))
        }, [
          pe("span", null, ce(E.getDate()), 1)
        ], 2))
      ], 64))), 128))
    ], 2));
  }
}), ln = /* @__PURE__ */ Ce({
  name: "ODatepickerTable",
  configField: "datepicker",
  __name: "DatepickerTable",
  props: /* @__PURE__ */ ge({
    modelValue: {
      type: [Date, Array],
      default: void 0
    },
    focusedDate: { type: Object, required: !0 },
    dayNames: { type: Array, required: !0 },
    monthNames: { type: Array, required: !0 },
    pickerProps: {
      type: Object,
      required: !0
    }
  }, {
    focusedDate: {
      required: !0
    },
    focusedDateModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:model-value", "update:focusedDate", "range-start", "range-end", "week-number-click"], ["update:focusedDate"]),
  setup(t, { emit: l }) {
    const a = t, e = l, { isDateSelectable: s } = oa(a.pickerProps), d = Pe(t, "focusedDate"), g = ne(), u = ne(), c = ne(), y = o(() => {
      const V = [];
      let $ = a.pickerProps.firstDayOfWeek || 0;
      for (; V.length < a.dayNames.length; ) {
        const Y = a.dayNames[$ % a.dayNames.length];
        V.push(Y), $++;
      }
      return a.pickerProps.showWeekNumber && V.unshift(""), V;
    }), f = o(() => a.pickerProps.events ? a.pickerProps.events.map(
      (V) => !V.date && V instanceof Date ? { date: V } : V
    ).filter(
      (V) => V.date.getMonth() === d.value.month && V.date.getFullYear() === d.value.year
    ) : []), v = o(() => {
      B();
      const V = d.value.month, $ = d.value.year, Y = [];
      let E = 1;
      for (; Y.length < 6; ) {
        const Z = Zo(
          E,
          V,
          $,
          a.pickerProps.firstDayOfWeek || 0
        );
        Y.push(Z), E += 7;
      }
      return Y;
    });
    function I(V) {
      return a.pickerProps.events ? f.value.filter(($) => {
        const Y = new Date($.date);
        Y.setHours(0, 0, 0, 0);
        const E = Y.getTime();
        return V.some((Z) => Z.getTime() === E);
      }) : [];
    }
    const C = o(() => !we(a.pickerProps.range) || u.value ? [] : ((c.value || 0) < (g.value || 0) ? [c.value, g.value] : [g.value, c.value]).filter(ke));
    function B() {
      const V = new Date(
        d.value.year,
        d.value.month,
        d.value.day
      );
      if (s(V, d.value.month)) return;
      let $ = 0;
      const Y = new Date(
        d.value.year,
        d.value.month + 1,
        0
      ).getDate();
      let E;
      for (; !E && ++$ < Y; ) {
        const Z = new Date(
          d.value.year,
          d.value.month,
          $
        );
        s(Z, d.value.month) && (E = V, d.value = {
          day: Z.getDate(),
          month: Z.getMonth(),
          year: Z.getFullYear()
        });
      }
    }
    function P(V) {
      a.pickerProps.disabled || (we(a.pickerProps.range) ? h(V) : we(a.pickerProps.multiple) ? z(V) : e("update:model-value", V));
    }
    function h(V) {
      g.value && u.value ? (g.value = V, u.value = void 0, e("range-start", V)) : g.value && !u.value ? (g.value > V ? (u.value = g.value, g.value = V) : u.value = V, e("range-end", V), e("update:model-value", [
        g.value,
        u.value
      ])) : (g.value = V, e("range-start", V));
    }
    function z(V) {
      let $ = Array.isArray(a.modelValue) ? a.modelValue : [];
      $.filter(
        (E) => E.getDate() === V.getDate() && E.getFullYear() === V.getFullYear() && E.getMonth() === V.getMonth()
      ).length ? $ = $.filter(
        (E) => E.getDate() !== V.getDate() || E.getFullYear() !== V.getFullYear() || E.getMonth() !== V.getMonth()
      ) : $ = [...$, V], e("update:model-value", $);
    }
    function F(V) {
      c.value = V;
    }
    function O(V) {
      d.value = {
        day: V.getDate(),
        month: V.getMonth(),
        year: V.getFullYear()
      };
    }
    const K = M(
      ["tableClass", "o-datepicker__table"],
      // passing the picker props will add reactivity to property changes
      { props: a.pickerProps }
    ), U = M(
      ["tableHeadClass", "o-datepicker__table__head"],
      // passing the picker props will add reactivity to property changes
      { props: a.pickerProps }
    ), S = M(
      ["tableCellClass", "o-datepicker__table__cell"],
      // passing the picker props will add reactivity to property changes
      { props: a.pickerProps }
    ), T = M(
      ["tableHeadCellClass", "o-datepicker__table__head-cell"],
      // passing the picker props will add reactivity to property changes
      { props: a.pickerProps }
    ), w = M(
      ["tableBodyClass", "o-datepicker__table__body"],
      // passing the picker props will add reactivity to property changes
      { props: a.pickerProps }
    );
    return (V, $) => (p(), A("section", {
      class: N(i(K))
    }, [
      pe("header", {
        class: N(i(U))
      }, [
        (p(!0), A(ve, null, $e(y.value, (Y, E) => (p(), A("div", {
          key: E,
          class: N([...i(S), ...i(T)])
        }, [
          pe("span", null, ce(Y), 1)
        ], 2))), 128))
      ], 2),
      pe("div", {
        class: N(i(w))
      }, [
        (p(!0), A(ve, null, $e(v.value, (Y, E) => (p(), se(an, {
          key: E,
          "selected-date": t.modelValue,
          day: d.value.day,
          week: Y,
          month: d.value.month,
          events: I(Y),
          "hovered-date-range": C.value,
          "picker-props": a.pickerProps,
          onSelect: P,
          onHoverEnddate: F,
          onChangeFocus: O,
          onWeekNumberClick: $[0] || ($[0] = (Z) => V.$emit("week-number-click", Z))
        }, null, 8, ["selected-date", "day", "week", "month", "events", "hovered-date-range", "picker-props"]))), 128))
      ], 2)
    ], 2));
  }
}), on = ["tabindex", "onClick", "onMouseenter", "onFocus", "onKeydown"], nn = /* @__PURE__ */ Ce({
  name: "ODatepickerMonth",
  configField: "datepicker",
  inheritAttrs: !1,
  __name: "DatepickerMonth",
  props: {
    modelValue: {
      type: [Date, Array],
      default: void 0
    },
    monthNames: { type: Array, required: !0 },
    focusedDate: { type: Object, required: !0 },
    pickerProps: {
      type: Object,
      required: !0
    }
  },
  emits: ["update:model-value", "update:focusedDate", "range-start", "range-end"],
  setup(t, { emit: l }) {
    const a = t, e = l, { dateCreator: s } = oa(a.pickerProps), d = ne(), g = ne(), u = ne(), c = o(() => {
      var r;
      return !!((r = a.pickerProps.events) != null && r.length);
    }), y = ne(/* @__PURE__ */ new Map());
    function f(r, m) {
      const R = `month-${r.getMonth()}`;
      m && y.value.set(R, m);
    }
    be(
      () => a.focusedDate.month,
      (r) => {
        const m = `month-${r}`;
        ze(() => {
          const R = y.value.get(m);
          (R == null ? void 0 : R.length) > 0 && R[0] && R[0].focus();
        });
      }
    );
    const v = o(() => a.pickerProps.events ? a.pickerProps.events.map((r) => (!r.date && r instanceof Date && (r = { date: r }), r.type || (r.type = "is-primary"), r)).filter((r) => r.date.getFullYear() === a.focusedDate.year) : []), I = o(() => {
      const r = a.focusedDate.year, m = [];
      for (let R = 0; R < 12; R++) {
        const L = new Date(r, R, 1);
        L.setHours(0, 0, 0, 0), m.push(L);
      }
      return m;
    }), C = o(() => !we(a.pickerProps.range) || !g.value ? [] : (u.value && d.value && u.value < d.value ? [u.value, d.value] : [d.value, u.value]).filter(ke));
    function B(r) {
      return v.value.length ? v.value.filter(
        (m) => m.date.getMonth() === r.getMonth()
      ) : [];
    }
    function P(r) {
      const m = [];
      if (a.pickerProps.minDate && m.push(r >= a.pickerProps.minDate), a.pickerProps.maxDate && m.push(r <= a.pickerProps.maxDate), m.push(r.getFullYear() === a.focusedDate.year), a.pickerProps.selectableDates)
        if (typeof a.pickerProps.selectableDates == "function") {
          if (a.pickerProps.selectableDates(r)) return !0;
          m.push(!1);
        } else
          for (let R = 0; R < a.pickerProps.selectableDates.length; R++) {
            const L = a.pickerProps.selectableDates[R];
            if (r.getFullYear() === L.getFullYear() && r.getMonth() === L.getMonth())
              return !0;
            m.push(!1);
          }
      if (a.pickerProps.unselectableDates)
        if (typeof a.pickerProps.unselectableDates == "function")
          m.push(!a.pickerProps.unselectableDates(r));
        else
          for (let R = 0; R < a.pickerProps.unselectableDates.length; R++) {
            const L = a.pickerProps.unselectableDates[R];
            m.push(
              r.getFullYear() !== L.getFullYear() || r.getMonth() !== L.getMonth()
            );
          }
      if (a.pickerProps.unselectableDaysOfWeek)
        for (let R = 0; R < a.pickerProps.unselectableDaysOfWeek.length; R++) {
          const L = a.pickerProps.unselectableDaysOfWeek[R];
          m.push(r.getDay() !== L);
        }
      return m.indexOf(!1) < 0;
    }
    function h(r, m) {
      let R = !0;
      switch (r.key) {
        case "Tab": {
          R = !1;
          break;
        }
        case " ":
        case "Space":
        case "Spacebar":
        case "Enter": {
          z(m);
          break;
        }
        case "ArrowLeft":
        case "Left": {
          U(m, -1);
          break;
        }
        case "ArrowRight":
        case "Right": {
          U(m, 1);
          break;
        }
        case "ArrowUp":
        case "Up": {
          U(m, -7);
          break;
        }
        case "ArrowDown":
        case "Down": {
          U(m, 7);
          break;
        }
      }
      R && r.preventDefault();
    }
    function z(r) {
      a.pickerProps.disabled || a.pickerProps.readonly || P(r) && (we(a.pickerProps.range) ? F(r) : we(a.pickerProps.multiple) ? K(r) : e("update:model-value", r));
    }
    function F(r) {
      d.value && g.value ? (d.value = r, g.value = void 0, e("range-start", r)) : d.value && !g.value ? (d.value > r ? (g.value = d.value, d.value = r) : g.value = r, e("range-end", r), e("update:model-value", [
        d.value,
        g.value
      ])) : (d.value = r, e("range-start", r));
    }
    const O = o(
      () => we(a.pickerProps.multiple) && a.modelValue ? a.modelValue : []
    );
    function K(r) {
      if (!Array.isArray(a.modelValue)) return;
      let m = a.modelValue;
      m.filter(
        (L) => L.getDate() === r.getDate() && L.getFullYear() === r.getFullYear() && L.getMonth() === r.getMonth()
      ).length ? m = m.filter(
        (L) => L.getDate() !== r.getDate() || L.getFullYear() !== r.getFullYear() || L.getMonth() !== r.getMonth()
      ) : m.push(r), e("update:model-value", m);
    }
    function U(r, m) {
      r.setMonth(r.getMonth() + m);
      const R = {
        day: r.getDate(),
        month: r.getMonth(),
        year: r.getFullYear()
      };
      e("update:focusedDate", R);
    }
    function S(r) {
      we(a.pickerProps.range) && (u.value = r);
    }
    function T(r, m, R = !1) {
      return !r || !m || R ? !1 : Array.isArray(m) ? m.some(
        (L) => r.getFullYear() === L.getFullYear() && r.getMonth() === L.getMonth()
      ) : r.getFullYear() === m.getFullYear() && r.getMonth() === m.getMonth();
    }
    function w(r, m, R = !1) {
      return !Array.isArray(m) || R ? !1 : r > m[0] && r < m[1];
    }
    function V(r, m, R = !1) {
      return !Array.isArray(m) || !R ? !1 : m.some(
        (L) => r.getDate() === L.getDate() && r.getFullYear() === L.getFullYear() && r.getMonth() === L.getMonth()
      );
    }
    const $ = M(
      ["monthClass", "o-datepicker__month"],
      // passing the picker props will add reactivity to property changes
      { props: a.pickerProps }
    ), Y = M(
      ["monthTableClass", "o-datepicker__month__table"],
      // passing the picker props will add reactivity to property changes
      { props: a.pickerProps }
    ), E = M(
      ["monthCellClass", "o-datepicker__month__cell"],
      [
        "monthCellEventsClass",
        "o-datepicker__month__cell--events",
        null,
        c
      ],
      // passing the picker props will add reactivity to property changes
      { props: a.pickerProps }
    ), Z = ma();
    ea(() => Z.stop());
    function _(r) {
      const m = M(
        [
          "monthCellSelectedClass",
          "o-datepicker__month__cell--selected",
          null,
          T(
            r,
            a.modelValue,
            we(a.pickerProps.multiple)
          ) || w(
            r,
            a.modelValue,
            we(a.pickerProps.multiple)
          ) || V(
            r,
            O.value,
            we(a.pickerProps.multiple)
          )
        ],
        [
          "monthCellFirstSelectedClass",
          "o-datepicker__month__cell--first-selected",
          null,
          T(
            r,
            Array.isArray(a.modelValue) && a.modelValue[0],
            we(a.pickerProps.multiple)
          )
        ],
        [
          "monthCellWithinSelectedClass",
          "o-datepicker__month__cell--within-selected",
          null,
          w(
            r,
            a.modelValue,
            we(a.pickerProps.multiple)
          )
        ],
        [
          "monthCellLastSelectedClass",
          "o-datepicker__month__cell--last-selected",
          null,
          T(
            r,
            Array.isArray(a.modelValue) && a.modelValue[1],
            we(a.pickerProps.multiple)
          )
        ],
        [
          "monthCellWithinHoveredRangeClass",
          "o-datepicker__month__cell--within-hovered-range",
          null,
          C.value && C.value.length === 2 && (T(r, C.value) || w(r, C.value))
        ],
        [
          "monthCellFirstHoveredClass",
          "o-datepicker__month__cell--first-hovered",
          null,
          T(
            r,
            Array.isArray(C.value) && C.value[0]
          )
        ],
        [
          "monthCellWithinHoveredClass",
          "o-datepicker__month__cell--within-hovered",
          null,
          w(r, C.value)
        ],
        [
          "monthCellLastHoveredClass",
          "o-datepicker__month__cell--last-hovered",
          null,
          T(
            r,
            Array.isArray(C.value) && C.value[1]
          )
        ],
        [
          "monthCellTodayClass",
          "o-datepicker__month__cell--today",
          null,
          T(r, s())
        ],
        [
          "monthCellSelectableclass",
          "o-datepicker__month__cell--selectable",
          null,
          P(r) && !a.pickerProps.disabled && !a.pickerProps.readonly
        ],
        [
          "monthCellUnselectableClass",
          "o-datepicker__month__cell--unselectable",
          null,
          !P(r) || a.pickerProps.disabled
        ],
        // pass effect scope for rectivity binding
        { scope: Z }
      );
      return [...E.value, ...m.value];
    }
    const q = M(
      ["monthEventsClass", "o-datepicker__month__events"],
      // passing the picker props will add reactivity to property changes
      { props: a.pickerProps }
    );
    function k(r) {
      return M(
        ["monthEventClass", "o-datepicker__month__event"],
        [
          "monthEventTypeClass",
          "o-datepicker__month__event--",
          r.type,
          !!r.type
        ],
        [
          "monthEventIndicatorClass",
          "o-datepicker__month__event--",
          a.pickerProps.indicators,
          !!a.pickerProps.indicators
        ],
        // pass effect scope for rectivity binding
        { scope: Z }
      ).value;
    }
    return (r, m) => (p(), A("section", {
      class: N(i($))
    }, [
      pe("div", {
        class: N(i(Y))
      }, [
        (p(!0), A(ve, null, $e(I.value, (R, L) => (p(), A(ve, { key: L }, [
          !t.pickerProps.disabled && !t.pickerProps.readonly && P(R) ? (p(), A("div", {
            key: 0,
            ref_for: !0,
            ref: (te) => f(R, te),
            class: N(_(R)),
            role: "button",
            tabindex: t.focusedDate.month === R.getMonth() ? void 0 : 0,
            onClick: re((te) => z(R), ["prevent"]),
            onMouseenter: (te) => S(R),
            onFocus: (te) => S(R),
            onKeydown: re((te) => h(te, R), ["prevent"])
          }, [
            Ve(ce(t.monthNames[R.getMonth()]) + " ", 1),
            B(R).length ? (p(), A("div", {
              key: 0,
              class: N(i(q))
            }, [
              (p(!0), A(ve, null, $e(B(R), (te, W) => (p(), A("div", {
                key: W,
                class: N(k(te))
              }, null, 2))), 128))
            ], 2)) : Q("", !0)
          ], 42, on)) : (p(), A("div", {
            key: 1,
            class: N(_(R))
          }, [
            Ve(ce(t.monthNames[R.getMonth()]) + " ", 1),
            B(R).length ? (p(), A("div", {
              key: 0,
              class: N(i(q))
            }, [
              (p(!0), A(ve, null, $e(B(R), (te, W) => (p(), A("div", {
                key: W,
                class: N(k(te))
              }, null, 2))), 128))
            ], 2)) : Q("", !0)
          ], 2))
        ], 64))), 128))
      ], 2)
    ], 2));
  }
}), ol = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "ODatepicker",
  configField: "datepicker",
  __name: "Datepicker",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    range: {},
    multiple: {},
    active: { type: Boolean, default: !1 },
    type: { default: "date" },
    dayNames: { default: () => n("datepicker.dayNames") },
    monthNames: { default: () => n("datepicker.monthNames") },
    size: { default: () => n("datepicker.size") },
    focusedDate: { default: void 0 },
    events: { default: void 0 },
    indicators: { default: "dots" },
    minDate: { default: void 0 },
    maxDate: { default: void 0 },
    expanded: { type: Boolean, default: !1 },
    rounded: { type: Boolean, default: !1 },
    inline: { type: Boolean, default: !1 },
    placeholder: { default: void 0 },
    readonly: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    openOnFocus: { type: Boolean, default: () => n("datepicker.openOnFocus", !0) },
    closeOnClick: { type: Boolean, default: () => n("datepicker.closeOnClick", !0) },
    locale: { default: () => n("locale") },
    formatter: { type: Function, default: n("datepicker.formatter") },
    parser: { type: Function, default: n("datepicker.parser") },
    creator: { type: Function, default: n("datepicker.creator") },
    selectableDates: { type: [Array, Function], default: void 0 },
    unselectableDates: { type: [Array, Function], default: void 0 },
    unselectableDaysOfWeek: { default: () => n("datepicker.unselectableDaysOfWeek") },
    nearbyMonthDays: { type: Boolean, default: () => n("datepicker.nearbyMonthDays", !0) },
    nearbySelectableMonthDays: { type: Boolean, default: () => n("datepicker.nearbySelectableMonthDays", !1) },
    showWeekNumber: { type: Boolean, default: () => n("datepicker.showWeekNumber", !1) },
    weekNumberClickable: { type: Boolean, default: () => n("datepicker.weekNumberClickable", !1) },
    firstDayOfWeek: { default: () => n("datepicker.firstDayOfWeek", 0) },
    rulesForFirstWeek: { default: 4 },
    yearsRange: { default: () => n("datepicker.yearsRange", [-100, 10]) },
    position: { default: void 0 },
    iconPack: { default: () => n("datepicker.iconPack") },
    icon: { default: () => n("datepicker.icon") },
    iconRight: { default: () => n("datepicker.iconRight") },
    iconRightClickable: { type: Boolean, default: !1 },
    iconPrev: { default: () => n("datepicker.iconPrev", "chevron-left") },
    iconNext: { default: () => n("datepicker.iconNext", "chevron-right") },
    mobileModal: { type: Boolean, default: () => n("datepicker.mobileModal", !0) },
    desktopModal: { type: Boolean, default: () => n("datepicker.desktopModal", !1) },
    mobileNative: { type: Boolean, default: () => n("datepicker.mobileNative", !1) },
    mobileBreakpoint: { default: () => n("datepicker.mobileBreakpoint") },
    teleport: { type: [Boolean, String, Object], default: () => n("datepicker.teleport", !1) },
    useHtml5Validation: { type: Boolean, default: () => n("useHtml5Validation", !0) },
    customValidity: { type: [String, Function], default: "" },
    ariaNextLabel: { default: () => n("datepicker.ariaNextLabel", "Next Page") },
    ariaPreviousLabel: { default: () => n("datepicker.ariaNextLabel", "Previous Page") },
    ariaSelectMonthLabel: { default: () => n("datepicker.ariaSelectMonthLabel", "Select Month") },
    ariaSelectYearLabel: { default: () => n("datepicker.ariaSelectYearLabel", "Select Year") },
    rootClass: {},
    mobileClass: {},
    sizeClass: {},
    expandedClass: {},
    boxClass: {},
    headerClass: {},
    prevButtonClass: {},
    nextButtonClass: {},
    listsClass: {},
    footerClass: {},
    tableClass: {},
    tableHeadClass: {},
    tableHeadCellClass: {},
    tableBodyClass: {},
    tableRowClass: {},
    tableCellClass: {},
    tableCellInvisibleClass: {},
    tableCellSelectedClass: {},
    tableCellFirstSelectedClass: {},
    tableCellWithinSelectedClass: {},
    tableCellLastSelectedClass: {},
    tableCellFirstHoveredClass: {},
    tableCellWithinHoveredClass: {},
    tableCellLastHoveredClass: {},
    tableCellTodayClass: {},
    tableCellSelectableClass: {},
    tableCellUnselectableClass: {},
    tableCellNearbyClass: {},
    tableCellEventsClass: {},
    tableEventsClass: {},
    tableEventClass: {},
    tableEventVariantClass: {},
    tableEventIndicatorClass: {},
    monthClass: {},
    monthTableClass: {},
    monthCellClass: {},
    monthCellSelectedClass: {},
    monthCellFirstSelectedClass: {},
    monthCellWithinSelectedClass: {},
    monthCellLastSelectedClass: {},
    monthCellWithinHoveredRangeClass: {},
    monthCellFirstHoveredClass: {},
    monthCellWithinHoveredClass: {},
    monthCellLastHoveredClass: {},
    monthCellTodayClass: {},
    monthCellSelectableClass: {},
    monthCellUnselectableClass: {},
    monthCellEventsClass: {},
    monthEventsClass: {},
    monthEventClass: {},
    monthEventVariantClass: {},
    monthEventIndicatorClass: {},
    dropdownClass: {},
    inputClass: {},
    inputClasses: { default: () => n("datepicker.inputClasses") },
    dropdownClasses: { default: () => n("datepicker.dropdownClasses") },
    selectClasses: { default: () => n("datepicker.selectClasses") }
  }, {
    modelValue: { default: void 0 },
    modelModifiers: {},
    active: { type: Boolean, default: !1 },
    activeModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:model-value", "update:active", "range-start", "range-end", "change-month", "change-year", "focus", "blur", "invalid", "icon-click", "icon-right-click"], ["update:modelValue", "update:active"]),
  setup(t, { expose: l, emit: a }) {
    const e = t, s = a, { dtf: d, dateCreator: g, dateFormatter: u, dateParser: c } = oa(e), { isMobile: y } = rt(e.mobileBreakpoint), f = Me("pickerComponent"), v = Pe(t, "modelValue"), I = Pe(t, "active"), C = o(() => e.type === "month");
    be(
      () => e.modelValue,
      (H) => {
        const J = Array.isArray(H), j = J ? H.length ? H[H.length - 1] : g() : H || g();
        (!J || J && Array.isArray(v.value) && H.length > v.value.length) && (P.value = {
          day: j.getDate(),
          month: j.getMonth(),
          year: j.getFullYear()
        });
      }
    ), be(
      () => e.focusedDate,
      (H) => {
        H && (P.value = {
          day: H.getDate(),
          month: H.getMonth(),
          year: H.getFullYear()
        });
      }
    );
    const B = (Array.isArray(e.modelValue) ? e.modelValue[0] : e.modelValue) || e.focusedDate || g();
    !e.modelValue && e.maxDate && e.maxDate.getFullYear() < B.getFullYear() && B.setFullYear(e.maxDate.getFullYear());
    const P = ne({
      day: B.getDate(),
      month: B.getMonth(),
      year: B.getFullYear()
    });
    be(
      () => P.value.month,
      (H) => s("change-month", H)
    ), be(
      () => P.value.year,
      (H) => s("change-year", H)
    );
    const h = o(
      () => Array.isArray(e.monthNames) ? e.monthNames : Qo(e.locale)
    ), z = o(() => {
      let H = 0, J = 12;
      return e.minDate && P.value.year === e.minDate.getFullYear() && (H = e.minDate.getMonth()), e.maxDate && P.value.year === e.maxDate.getFullYear() && (J = e.maxDate.getMonth()), h.value.map((j, ye) => ({
        label: j,
        value: ye,
        attrs: { disabled: ye < H || ye > J }
      }));
    }), F = o(
      () => Array.isArray(e.dayNames) ? e.dayNames : Jo(e.locale)
    ), O = o(() => {
      let H = B.getFullYear() + e.yearsRange[1];
      e.maxDate && e.maxDate.getFullYear() < H && (H = Math.max(
        e.maxDate.getFullYear(),
        P.value.year
      ));
      let J = B.getFullYear() + e.yearsRange[0];
      return e.minDate && e.minDate.getFullYear() > J && (J = Math.min(
        e.minDate.getFullYear(),
        P.value.year
      )), Array.from(
        { length: H - J + 1 || 1 },
        (j, ye) => J + ye
      ).reverse().map((j) => ({
        label: String(j),
        value: j
      }));
    }), K = o(() => {
      if (!e.minDate) return !0;
      if (C.value)
        return P.value.year > e.minDate.getFullYear();
      const H = new Date(
        P.value.year,
        P.value.month
      ), J = new Date(
        e.minDate.getFullYear(),
        e.minDate.getMonth()
      );
      return H > J;
    });
    function U() {
      e.disabled || (C.value ? P.value.year -= 1 : P.value.month > 0 ? P.value.month -= 1 : (P.value.month = 11, P.value.year -= 1));
    }
    const S = o(() => {
      if (!e.maxDate) return !0;
      if (C.value)
        return P.value.year < e.maxDate.getFullYear();
      const H = new Date(
        P.value.year,
        P.value.month
      ), J = new Date(
        e.maxDate.getFullYear(),
        e.maxDate.getMonth()
      );
      return H < J;
    });
    function T() {
      e.disabled || (C.value ? P.value.year += 1 : P.value.month < 11 ? P.value.month += 1 : (P.value.month = 0, P.value.year += 1));
    }
    function w(H, J) {
      if (J) return V(H);
      const j = Array.isArray(H) ? [...H] : H;
      return u(j);
    }
    function V(H) {
      if (Array.isArray(H) && (H = H[0]), !H) return "";
      const J = new Date(H);
      if (!lt(J)) return "";
      if (C.value) {
        const j = J.getFullYear(), ye = J.getMonth() + 1;
        return j + "-" + tt(ye);
      } else {
        const j = J.getFullYear(), ye = J.getMonth() + 1, Se = J.getDate();
        return j + "-" + tt(ye) + "-" + tt(Se);
      }
    }
    function $(H, J) {
      if (J) return Y(H);
      const j = c(H);
      return lt(j) || Array.isArray(j) && j.length === 2 && lt(j[0]) && lt(j[1]) ? j : void 0;
    }
    function Y(H) {
      const J = H ? H.split("-") : [];
      if (J.length !== 3) return;
      const j = parseInt(J[0], 10), ye = parseInt(J[1]) - 1, Se = parseInt(J[2]);
      return new Date(j, ye, Se);
    }
    function E() {
      if (!e.disabled)
        if (C.value)
          P.value.year -= 1;
        else {
          const H = new Date(
            P.value.year,
            P.value.month,
            P.value.day
          );
          H.setDate(H.getDate() - 1), P.value.day = H.getDate(), P.value.month = H.getMonth(), P.value.year = H.getFullYear();
        }
    }
    function Z() {
      if (!e.disabled)
        if (C.value)
          P.value.year += 1;
        else {
          const H = new Date(
            P.value.year,
            P.value.month,
            P.value.day
          );
          H.setDate(H.getDate() + 1), P.value.day = H.getDate(), P.value.month = H.getMonth(), P.value.year = H.getFullYear();
        }
    }
    const _ = M(
      ["rootClass", "o-datepicker"],
      [
        "sizeClass",
        "o-datepicker--",
        o(() => e.size),
        o(() => !!e.size)
      ],
      ["mobileClass", "o-datepicker--mobile", null, y],
      [
        "expandedClass",
        "o-datepicker--expanded",
        null,
        o(() => e.expanded)
      ]
    ), q = M(["boxClass", "o-datepicker__box"]), k = o(() => Ke(q)), r = M(["headerClass", "o-datepicker__header"]), m = M([
      "prevButtonClass",
      "o-datepicker__header__previous"
    ]), R = M([
      "nextButtonClass",
      "o-datepicker__header__next"
    ]), L = M([
      "listsClass",
      "o-datepicker__header__list"
    ]), te = M(["footerClass", "o-datepicker__footer"]), W = M([
      "dropdownClass",
      "o-datepicker__dropdown"
    ]);
    return l({ focus: () => {
      var H;
      return (H = f.value) == null ? void 0 : H.focus();
    }, value: v }), (H, J) => (p(), se(ll, {
      ref: "pickerComponent",
      active: I.value,
      "onUpdate:active": J[12] || (J[12] = (j) => I.value = j),
      value: v.value,
      "onUpdate:value": J[13] || (J[13] = (j) => v.value = j),
      "data-oruga": "datepicker",
      "picker-props": e,
      formatter: w,
      parser: $,
      type: C.value ? "month" : "date",
      max: H.maxDate,
      min: H.minDate,
      "stay-open": e.multiple,
      "root-classes": i(_),
      "dropdown-classes": i(W),
      "box-class": k.value,
      dtf: i(d),
      onFocus: J[14] || (J[14] = (j) => H.$emit("focus", j)),
      onBlur: J[15] || (J[15] = (j) => H.$emit("blur", j)),
      onInvalid: J[16] || (J[16] = (j) => H.$emit("invalid", j)),
      onLeft: E,
      onRight: Z,
      onIconClick: J[17] || (J[17] = (j) => H.$emit("icon-click", j)),
      onIconRightClick: J[18] || (J[18] = (j) => H.$emit("icon-right-click", j))
    }, Vt({
      default: de(() => [
        pe("header", {
          class: N(i(r))
        }, [
          ae(H.$slots, "header", {}, () => [
            H.disabled ? Q("", !0) : (p(), se(Dt, {
              key: 0,
              class: N(i(m)),
              disabled: !K.value,
              "icon-pack": H.iconPack,
              "icon-left": H.iconPrev,
              size: H.size,
              "aria-label": H.ariaPreviousLabel,
              onClick: re(U, ["prevent"]),
              onKeydown: [
                oe(re(U, ["prevent"]), ["enter"]),
                oe(re(U, ["prevent"]), ["space"])
              ]
            }, null, 8, ["class", "disabled", "icon-pack", "icon-left", "size", "aria-label", "onKeydown"])),
            H.disabled ? Q("", !0) : (p(), se(Dt, {
              key: 1,
              class: N(i(R)),
              disabled: !S.value,
              "icon-pack": H.iconPack,
              "icon-left": H.iconNext,
              size: H.size,
              "aria-label": H.ariaNextLabel,
              onClick: re(T, ["prevent"]),
              onKeydown: [
                oe(re(T, ["prevent"]), ["enter"]),
                oe(re(T, ["prevent"]), ["space"])
              ]
            }, null, 8, ["class", "disabled", "icon-pack", "icon-left", "size", "aria-label", "onKeydown"])),
            pe("div", {
              class: N(i(L))
            }, [
              C.value ? Q("", !0) : (p(), se(ft, fe({ key: 0 }, H.selectClasses, {
                modelValue: P.value.month,
                "onUpdate:modelValue": J[0] || (J[0] = (j) => P.value.month = j),
                disabled: H.disabled,
                size: H.size,
                options: z.value,
                "aria-label": H.ariaSelectMonthLabel,
                "use-html5-validation": !1,
                onKeydown: [
                  oe(re(U, ["stop", "prevent"]), ["left"]),
                  oe(re(T, ["stop", "prevent"]), ["right"])
                ]
              }), null, 16, ["modelValue", "disabled", "size", "options", "aria-label", "onKeydown"])),
              he(ft, fe(H.selectClasses, {
                modelValue: P.value.year,
                "onUpdate:modelValue": J[1] || (J[1] = (j) => P.value.year = j),
                disabled: H.disabled,
                size: H.size,
                options: O.value,
                "aria-label": H.ariaSelectYearLabel,
                "use-html5-validation": !1,
                onKeydown: [
                  oe(re(U, ["stop", "prevent"]), ["left"]),
                  oe(re(T, ["stop", "prevent"]), ["right"]),
                  J[2] || (J[2] = oe(re((j) => P.value.year += 1, ["stop", "prevent"]), ["up"])),
                  J[3] || (J[3] = oe(re((j) => P.value.year -= 1, ["stop", "prevent"]), ["down"]))
                ]
              }), null, 16, ["modelValue", "disabled", "size", "options", "aria-label", "onKeydown"])
            ], 2)
          ])
        ], 2),
        ae(H.$slots, "body", {}, () => [
          C.value ? (p(), se(nn, {
            key: 0,
            modelValue: v.value,
            "onUpdate:modelValue": J[4] || (J[4] = (j) => v.value = j),
            "focused-date": P.value,
            "onUpdate:focusedDate": J[5] || (J[5] = (j) => P.value = j),
            "month-names": h.value,
            "picker-props": e,
            onRangeStart: J[6] || (J[6] = (j) => H.$emit("range-start", j)),
            onRangeEnd: J[7] || (J[7] = (j) => H.$emit("range-end", j))
          }, null, 8, ["modelValue", "focused-date", "month-names"])) : (p(), se(ln, {
            key: 1,
            modelValue: v.value,
            "onUpdate:modelValue": J[8] || (J[8] = (j) => v.value = j),
            "focused-date": P.value,
            "onUpdate:focusedDate": J[9] || (J[9] = (j) => P.value = j),
            "day-names": F.value,
            "month-names": h.value,
            "picker-props": e,
            onRangeStart: J[10] || (J[10] = (j) => H.$emit("range-start", j)),
            onRangeEnd: J[11] || (J[11] = (j) => H.$emit("range-end", j))
          }, null, 8, ["modelValue", "focused-date", "day-names", "month-names"]))
        ]),
        H.$slots.footer ? (p(), A("footer", {
          key: 0,
          class: N(i(te))
        }, [
          ae(H.$slots, "footer")
        ], 2)) : Q("", !0)
      ]),
      _: 2
    }, [
      H.$slots.trigger ? {
        name: "trigger",
        fn: de(() => [
          ae(H.$slots, "trigger")
        ]),
        key: "0"
      } : void 0
    ]), 1032, ["active", "value", "type", "max", "min", "stay-open", "root-classes", "dropdown-classes", "box-class", "dtf"]));
  }
}), sn = {
  install(t) {
    Ie(t, ol);
  }
}, Nt = "AM", xt = "PM", rn = "24", da = "12";
function un(t) {
  const l = o(
    () => new Intl.DateTimeFormat(t.locale, {
      hour: "numeric",
      minute: "numeric",
      second: t.enableSeconds ? "numeric" : void 0
    }).resolvedOptions()
  ), a = o(
    () => t.hourFormat && t.hourFormat === rn || !t.hourFormat && !l.value.hour12
  ), e = o(
    () => new Intl.DateTimeFormat(t.locale, {
      hour: l.value.hour || "numeric",
      minute: l.value.minute || "numeric",
      second: t.enableSeconds ? l.value.second || "numeric" : void 0,
      hourCycle: a.value ? "h23" : "h12"
    })
  ), s = o(() => {
    const B = v();
    return B.setHours(10), B.setSeconds(0), B.setMinutes(0), B.setMilliseconds(0), B;
  }), d = o(() => {
    if (e.value.formatToParts && typeof e.value.formatToParts == "function") {
      const B = new Date(s.value);
      B.setHours(10);
      const P = e.value.formatToParts(B).find((h) => h.type === "dayPeriod");
      if (P) return P.value;
    }
    return Nt;
  }), g = o(() => {
    if (e.value.formatToParts && typeof e.value.formatToParts == "function") {
      const B = new Date(s.value);
      B.setHours(20);
      const P = e.value.formatToParts(B).find((h) => h.type === "dayPeriod");
      if (P)
        return P.value;
    }
    return xt;
  }), u = o(() => [d.value, g.value]), c = o(() => {
    if (e.value.formatToParts && typeof e.value.formatToParts == "function") {
      const B = new Date(s.value), P = e.value.formatToParts(B), h = P.find(
        (z, F) => F > 0 && P[F - 1].type === "hour"
      );
      if (h) return h.value;
    }
    return ":";
  }), y = o(() => {
    if (e.value.formatToParts && typeof e.value.formatToParts == "function") {
      const B = new Date(s.value), P = e.value.formatToParts(B), h = P.find(
        (z, F) => F > 0 && P[F - 1].type === "minute"
      );
      if (h) return h.value;
    }
    return ":";
  }), f = o(() => {
    if (e.value.formatToParts && typeof e.value.formatToParts == "function") {
      const B = new Date(s.value), P = e.value.formatToParts(B), h = P.find(
        (z, F) => F > 0 && P[F - 1].type === "second"
      );
      if (h) return h.value;
    }
  });
  function v() {
    return typeof t.creator == "function" ? t.creator() : /* @__PURE__ */ new Date();
  }
  function I(B) {
    return typeof t.formatter == "function" ? t.formatter(B) : B ? e.value.format(B) : "00:00";
  }
  function C(B) {
    if (typeof t.parser == "function") return t.parser(B);
    if (!B) return;
    if (e.value.formatToParts && typeof e.value.formatToParts == "function") {
      const U = e.value.formatToParts(s.value).map((T) => T.type === "literal" ? T.value.replace(/ /g, "\\s?") : T.type === "dayPeriod" ? `((?!=<${T.type}>)(${d.value}|${g.value}|${Nt}|${xt}|${Nt.toLowerCase()}|${xt.toLowerCase()})?)` : `((?!=<${T.type}>)\\d+)`).join(""), S = Pa(U, B);
      if (S.hour = S.hour ? parseInt(S.hour, 10) : null, S.minute = S.minute ? parseInt(S.minute, 10) : null, S.second = S.second ? parseInt(S.second, 10) : null, S.hour && S.hour >= 0 && S.hour < 24 && S.minute && S.minute >= 0 && S.minute < 59) {
        S.dayPeriod && (S.dayPeriod.toLowerCase() === g.value.toLowerCase() || S.dayPeriod.toLowerCase() === xt.toLowerCase()) && S.hour < 12 && (S.hour += 12);
        const T = new Date(s.value);
        return T.setHours(S.hour), T.setMinutes(S.minute), T.setSeconds(S.second || 0), T;
      }
    }
    let P = !1;
    if (t.hourFormat === da) {
      const U = B.split(" ");
      B = U[0], P = U[1] === d.value || U[1] === Nt;
    }
    const h = B.split(":");
    let z = parseInt(h[0], 10);
    const F = parseInt(h[1], 10), O = t.enableSeconds && h.length >= 3 ? parseInt(h[2], 10) : 0;
    if (isNaN(z) || z < 0 || z > 23 || t.hourFormat === da && (z < 1 || z > 12) || isNaN(F) || F < 0 || F > 59)
      return;
    const K = new Date(s.value);
    return K.setSeconds(O), K.setMinutes(F), t.hourFormat === da && (P && z === 12 ? z = 0 : !P && z !== 12 && (z += 12)), K.setHours(z), new Date(K.getTime());
  }
  return {
    dtf: e,
    timeCreator: v,
    timeFormatter: I,
    timeParser: C,
    pmString: g,
    amString: d,
    meridiens: u,
    isHourFormat24: a,
    hourLiteral: c,
    minuteLiteral: y,
    secondLiteral: f
  };
}
const dn = ["value", "disabled"], cn = ["value", "disabled"], fn = ["value", "disabled"], nl = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OTimepicker",
  configField: "timepicker",
  __name: "Timepicker",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    active: { type: Boolean, default: !1 },
    minTime: { default: void 0 },
    maxTime: { default: void 0 },
    inline: { type: Boolean, default: !1 },
    placeholder: { default: void 0 },
    expanded: { type: Boolean, default: !1 },
    rounded: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    size: { default: () => n("timepicker.size") },
    hourFormat: { default: void 0 },
    incrementHours: { default: 1 },
    incrementMinutes: { default: 1 },
    incrementSeconds: { default: 1 },
    openOnFocus: { type: Boolean, default: () => n("timepicker.openOnFocus", !0) },
    closeOnClick: { type: Boolean, default: () => n("timepicker.closeOnClick", !0) },
    enableSeconds: { type: Boolean, default: !1 },
    defaultMinutes: { default: void 0 },
    defaultSeconds: { default: void 0 },
    locale: { default: () => n("locale") },
    formatter: { type: Function, default: n("timepicker.formatter") },
    parser: { type: Function, default: n("timepicker.parser") },
    creator: { type: Function, default: n("timepicker.creator") },
    unselectableTimes: { type: [Array, Function], default: void 0 },
    resetOnMeridianChange: { type: Boolean, default: !1 },
    position: { default: void 0 },
    iconPack: { default: () => n("timepicker.iconPack") },
    icon: { default: () => n("timepicker.icon") },
    iconRight: { default: () => n("timepicker.iconRight") },
    iconRightClickable: { type: Boolean, default: !1 },
    mobileModal: { type: Boolean, default: () => n("timepicker.mobileModal", !0) },
    desktopModal: { type: Boolean, default: () => n("timepicker.desktopModal", !1) },
    mobileNative: { type: Boolean, default: () => n("timepicker.mobileNative", !0) },
    mobileBreakpoint: { default: () => n("timepicker.mobileBreakpoint") },
    teleport: { type: [Boolean, String, Object], default: () => n("timepicker.teleport", !1) },
    useHtml5Validation: { type: Boolean, default: () => n("useHtml5Validation", !0) },
    customValidity: { type: [String, Function], default: "" },
    ariaSelectSecondsLabel: { default: () => n("timepicker.ariaSelectSecondLabel", "Select Second") },
    ariaSelectMinutesLabel: { default: () => n("timepicker.ariaSelectMinuteLabel", "Select Minute") },
    ariaSelectHoursLabel: { default: () => n("timepicker.ariaSelectHourLabel", "Select Hour") },
    rootClass: {},
    mobileClass: {},
    sizeClass: {},
    boxClass: {},
    separatorClass: {},
    footerClass: {},
    dropdownClass: {},
    inputClass: {},
    inputClasses: { default: () => n("timepicker.inputClasses") },
    dropdownClasses: { default: () => n("timepicker.dropdownClasses") },
    selectClasses: { default: () => n("timepicker.selectClasses") }
  }, {
    modelValue: { default: void 0 },
    modelModifiers: {},
    active: { type: Boolean, default: !1 },
    activeModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:model-value", "update:active", "focus", "blur", "invalid", "icon-click", "icon-right-click"], ["update:modelValue", "update:active"]),
  setup(t, { expose: l }) {
    const a = t, { isMobile: e } = rt(a.mobileBreakpoint), {
      dtf: s,
      timeCreator: d,
      timeFormatter: g,
      timeParser: u,
      pmString: c,
      amString: y,
      meridiens: f,
      isHourFormat24: v,
      hourLiteral: I,
      minuteLiteral: C,
      secondLiteral: B
    } = un(a), P = Me("pickerComponent"), h = Pe(t, "modelValue"), z = Pe(t, "active"), F = ne(), O = ne(), K = ne(), U = ne();
    be(
      () => a.modelValue,
      (X) => S(X),
      { immediate: !0 }
    );
    function S(X) {
      if (Array.isArray(X)) return S(X[0]);
      h.value !== X && (h.value = X), X ? (F.value = X.getHours(), O.value = X.getMinutes(), K.value = X.getSeconds(), U.value = X.getHours() >= 12 ? c.value : y.value) : (F.value = void 0, O.value = void 0, K.value = void 0, U.value = y.value);
    }
    const T = o(() => a.enableSeconds ? "1" : void 0);
    be(
      () => a.hourFormat,
      () => {
        ke(F.value) && (U.value = (F.value || 0) >= 12 ? c.value : y.value);
      }
    ), be(
      () => a.locale,
      (X) => {
        X || (U.value = y.value);
      }
    );
    function w(X, G) {
      return v.value || G ? tt(X) : String(X);
    }
    const V = o(() => {
      if (!a.incrementHours || a.incrementHours < 1)
        throw new Error("Hour increment cannot be null or less than 1.");
      const X = [], G = v.value ? 24 : 12;
      for (let D = 0; D < G; D += a.incrementHours) {
        let le = D, me = le;
        v.value || (le = D + 1, me = le, U.value === y.value ? le === 12 && (le = 0) : U.value === c.value && le !== 12 && (le += 12)), X.push({
          label: w(me, !1),
          value: le
        });
      }
      return X;
    }), $ = o(() => {
      if (!a.incrementMinutes || a.incrementMinutes < 1)
        throw new Error("Minute increment cannot be null or less than 1.");
      const X = [];
      for (let G = 0; G < 60; G += a.incrementMinutes)
        X.push({
          label: w(G, !0),
          value: G
        });
      return X;
    }), Y = o(() => {
      if (!a.incrementSeconds || a.incrementSeconds < 1)
        throw new Error("Second increment cannot be null or less than 1.");
      const X = [];
      for (let G = 0; G < 60; G += a.incrementSeconds)
        X.push({
          label: w(G, !0),
          value: G
        });
      return X;
    });
    function E(X) {
      let G = !1;
      if (a.minTime) {
        const D = a.minTime.getHours(), le = $.value.every((me) => Z(X, me.value));
        G = X < D || le;
      }
      if (a.maxTime && !G) {
        const D = a.maxTime.getHours();
        G = X > D;
      }
      if (a.unselectableTimes && !G)
        if (typeof a.unselectableTimes == "function") {
          const D = /* @__PURE__ */ new Date();
          return D.setHours(X), D.setMinutes(O.value || 0), D.setSeconds(K.value || 0), a.unselectableTimes(D);
        } else
          a.unselectableTimes.filter((le) => a.enableSeconds && ke(K.value) ? le.getHours() === X && le.getMinutes() === O.value && le.getSeconds() === K.value : ke(O.value) ? le.getHours() === X && le.getMinutes() === O.value : !1).length > 0 ? G = !0 : G = $.value.every((le) => a.unselectableTimes.filter((me) => me.getHours() === X && me.getMinutes() === le.value).length > 0);
      return G;
    }
    function Z(X, G) {
      let D = !1;
      if (a.minTime) {
        const le = a.minTime.getHours(), me = a.minTime.getMinutes();
        D = X === le && G < me;
      }
      if (a.maxTime && !D) {
        const le = a.maxTime.getHours(), me = a.maxTime.getMinutes();
        D = X === le && G > me;
      }
      return D;
    }
    function _(X) {
      if (F.value === void 0) return !1;
      let G = E(F.value) || Z(F.value, X);
      if (a.unselectableTimes && !G)
        if (typeof a.unselectableTimes == "function") {
          const D = /* @__PURE__ */ new Date();
          return D.setHours(F.value), D.setMinutes(X), D.setSeconds(K.value || 0), a.unselectableTimes(D);
        } else
          G = a.unselectableTimes.filter((le) => a.enableSeconds && ke(K.value) ? le.getHours() === F.value && le.getMinutes() === X && le.getSeconds() === K.value : le.getHours() === F.value && le.getMinutes() === X).length > 0;
      return G;
    }
    function q(X) {
      if (!ke(O.value)) return !1;
      let G = !1;
      if (_(O.value))
        G = !0;
      else {
        if (a.minTime) {
          const D = a.minTime.getHours(), le = a.minTime.getMinutes(), me = a.minTime.getSeconds();
          G = F.value === D && O.value === le && X < me;
        }
        if (a.maxTime && !G) {
          const D = a.maxTime.getHours(), le = a.maxTime.getMinutes(), me = a.maxTime.getSeconds();
          G = F.value === D && O.value === le && X > me;
        }
      }
      if (a.unselectableTimes && !G)
        if (typeof a.unselectableTimes == "function") {
          const D = /* @__PURE__ */ new Date();
          return D.setHours(F.value || 0), D.setMinutes(O.value), D.setSeconds(X), a.unselectableTimes(D);
        } else
          G = a.unselectableTimes.filter((le) => le.getHours() === F.value && le.getMinutes() === O.value && le.getSeconds() === X).length > 0;
      return G;
    }
    function k(X) {
      const G = X == "AM" ? 0 : 12;
      for (let D = 0; D < 12; D++)
        if (!E(D + G)) return !1;
      return !0;
    }
    function r(X, G, D, le) {
      if (ke(X) && ke(G) && (!ke(v.value) && ke(le) || ke(v.value))) {
        let me;
        h.value ? me = new Date(h.value) : (me = d(), me.setMilliseconds(0)), me.setHours(X), me.setMinutes(G), me.setSeconds(D), isNaN(me.getTime()) || (h.value = new Date(me.getTime()));
      }
    }
    function m(X, G) {
      return Array.isArray(X) ? m(X[0], G) : G ? R(X) : g(X);
    }
    function R(X) {
      if (Array.isArray(X)) return R(X[0]);
      if (!X) return "";
      const G = new Date(X);
      if (!lt(G)) return "";
      const D = G.getHours(), le = G.getMinutes(), me = G.getSeconds();
      return w(D, !0) + ":" + w(le, !0) + ":" + w(me, !0);
    }
    function L(X, G) {
      if (G) return te(X);
      const D = u(X);
      return lt(D) ? D : void 0;
    }
    function te(X) {
      if (!X) return;
      let G;
      h.value ? G = new Date(h.value) : (G = d(), G.setMilliseconds(0));
      const D = X.split(":");
      return G.setHours(parseInt(D[0], 10)), G.setMinutes(parseInt(D[1], 10)), G.setSeconds(D[2] ? parseInt(D[2], 10) : 0), new Date(G.getTime());
    }
    function W(X) {
      ke(F.value) && a.resetOnMeridianChange ? (F.value = void 0, O.value = void 0, K.value = void 0, h.value = void 0) : ke(F.value) && (X === c.value ? F.value += 12 : X === y.value && (F.value -= 12)), r(
        F.value || 0,
        O.value || 0,
        a.enableSeconds && K.value || 0,
        X
      );
    }
    function H(X) {
      !O.value && typeof a.defaultMinutes < "u" && (O.value = a.defaultMinutes), !K.value && typeof a.defaultSeconds < "u" && (K.value = a.defaultSeconds), r(
        parseInt(X, 10),
        O.value || 0,
        a.enableSeconds && K.value || 0,
        U.value
      );
    }
    function J(X) {
      !K.value && a.defaultSeconds && (K.value = a.defaultSeconds), r(
        F.value || 0,
        parseInt(X, 10),
        a.enableSeconds && K.value || 0,
        U.value
      );
    }
    function j(X) {
      r(
        F.value || 0,
        O.value || 0,
        parseInt(X, 10),
        U.value
      );
    }
    const ye = M(
      ["rootClass", "o-timepicker"],
      [
        "sizeClass",
        "o-timepicker--",
        o(() => a.size),
        o(() => !!a.size)
      ],
      ["mobileClass", "o-timepicker--mobile", null, e]
    ), Se = M([
      "separatorClass",
      "o-timepicker__separtor"
    ]), Ne = M(["footerClass", "o-timepicker__footer"]), Ue = M([
      "dropdownClass",
      "o-timepicker__dropdown"
    ]), Qe = M(["boxClass", "o-timepicker__box"]), je = o(() => Ke(Qe)), gt = M([
      "selectClasses.selectClass",
      "o-timepicker__select"
    ]), yt = M([
      "selectClasses.placeholderClass",
      "o-timepicker__select-placeholder"
    ]), ue = o(() => ({
      "select-class": Ke(gt),
      "placeholder-class": Ke(yt),
      ...a.selectClasses
    }));
    return l({ focus: () => {
      var X;
      return (X = P.value) == null ? void 0 : X.focus();
    }, value: h }), (X, G) => (p(), se(ll, {
      ref: "pickerComponent",
      active: z.value,
      "onUpdate:active": G[8] || (G[8] = (D) => z.value = D),
      value: h.value,
      "data-oruga": "timepicker",
      "picker-props": a,
      formatter: m,
      parser: L,
      type: "time",
      max: X.maxTime,
      min: X.minTime,
      step: T.value,
      "root-classes": i(ye),
      "dropdown-classes": i(Ue),
      "box-class": je.value,
      dtf: i(s),
      "onUpdate:value": S,
      onFocus: G[9] || (G[9] = (D) => X.$emit("focus", D)),
      onBlur: G[10] || (G[10] = (D) => X.$emit("blur", D)),
      onInvalid: G[11] || (G[11] = (D) => X.$emit("invalid", D)),
      onIconClick: G[12] || (G[12] = (D) => X.$emit("icon-click", D)),
      onIconRightClick: G[13] || (G[13] = (D) => X.$emit("icon-right-click", D))
    }, Vt({
      default: de(() => [
        he(ft, fe(ue.value, {
          modelValue: F.value,
          "onUpdate:modelValue": G[0] || (G[0] = (D) => F.value = D),
          options: V.value,
          override: "",
          disabled: X.disabled,
          placeholder: "00",
          "aria-label": X.ariaSelectHoursLabel,
          "use-html5-validation": !1,
          onChange: G[1] || (G[1] = (D) => H(D.target.value))
        }), null, 16, ["modelValue", "options", "disabled", "aria-label"]),
        pe("span", {
          class: N(i(Se))
        }, ce(i(I)), 3),
        he(ft, fe(ue.value, {
          modelValue: O.value,
          "onUpdate:modelValue": G[2] || (G[2] = (D) => O.value = D),
          override: "",
          disabled: X.disabled,
          placeholder: "00",
          "aria-label": X.ariaSelectMinutesLabel,
          "use-html5-validation": !1,
          onChange: G[3] || (G[3] = (D) => J(D.target.value))
        }), {
          default: de(() => [
            (p(!0), A(ve, null, $e($.value, (D) => (p(), A("option", {
              key: D.value,
              value: D.value,
              disabled: _(D.value)
            }, ce(D.label), 9, dn))), 128))
          ]),
          _: 1
        }, 16, ["modelValue", "disabled", "aria-label"]),
        X.enableSeconds ? (p(), A(ve, { key: 0 }, [
          pe("span", {
            class: N(i(Se))
          }, ce(i(C)), 3),
          he(ft, fe(ue.value, {
            modelValue: K.value,
            "onUpdate:modelValue": G[4] || (G[4] = (D) => K.value = D),
            override: "",
            disabled: X.disabled,
            placeholder: "00",
            "aria-label": X.ariaSelectSecondsLabel,
            "use-html5-validation": !1,
            onChange: G[5] || (G[5] = (D) => j(D.target.value))
          }), {
            default: de(() => [
              (p(!0), A(ve, null, $e(Y.value, (D) => (p(), A("option", {
                key: D.value,
                value: D.value,
                disabled: q(D.value)
              }, ce(D.label), 9, cn))), 128))
            ]),
            _: 1
          }, 16, ["modelValue", "disabled", "aria-label"]),
          pe("span", {
            class: N(i(Se))
          }, ce(i(B)), 3)
        ], 64)) : Q("", !0),
        i(v) ? Q("", !0) : (p(), se(ft, fe({ key: 1 }, ue.value, {
          modelValue: U.value,
          "onUpdate:modelValue": G[6] || (G[6] = (D) => U.value = D),
          override: "",
          disabled: X.disabled,
          "use-html5-validation": !1,
          onChange: G[7] || (G[7] = (D) => W(D.target.value))
        }), {
          default: de(() => [
            (p(!0), A(ve, null, $e(i(f), (D) => (p(), A("option", {
              key: D,
              value: D,
              disabled: k(D)
            }, ce(D), 9, fn))), 128))
          ]),
          _: 1
        }, 16, ["modelValue", "disabled"])),
        X.$slots.footer ? (p(), A("footer", {
          key: 2,
          class: N(i(Ne))
        }, [
          ae(X.$slots, "footer")
        ], 2)) : Q("", !0)
      ]),
      _: 2
    }, [
      X.$slots.trigger ? {
        name: "trigger",
        fn: de(() => [
          ae(X.$slots, "trigger")
        ]),
        key: "0"
      } : void 0
    ]), 1032, ["active", "value", "max", "min", "step", "root-classes", "dropdown-classes", "box-class", "dtf"]));
  }
}), ca = "AM", fa = "PM", pn = "24";
function vn(t) {
  const l = o(
    () => {
      var y;
      return new Intl.DateTimeFormat(t.locale, {
        year: "numeric",
        month: "numeric",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: (y = t.timepicker) != null && y.enableSeconds ? "numeric" : void 0
      }).resolvedOptions();
    }
  ), a = o(
    () => {
      var y, f;
      return ((y = t.timepicker) == null ? void 0 : y.hourFormat) && t.timepicker.hourFormat === pn || !((f = t.timepicker) != null && f.hourFormat) && !l.value.hour12;
    }
  ), e = o(
    () => {
      var y;
      return new Intl.DateTimeFormat(t.locale, {
        year: l.value.year || "numeric",
        month: l.value.month || "numeric",
        day: l.value.day || "numeric",
        hour: l.value.hour || "numeric",
        minute: l.value.minute || "numeric",
        second: (y = t.timepicker) != null && y.enableSeconds ? l.value.second || "numeric" : void 0,
        hourCycle: a.value ? "h23" : "h12"
      });
    }
  ), s = o(() => {
    if (e.value.formatToParts && typeof e.value.formatToParts == "function") {
      const y = g();
      y.setHours(10);
      const f = e.value.formatToParts(y).find((v) => v.type === "dayPeriod");
      if (f) return f.value;
    }
    return ca;
  }), d = o(() => {
    if (e.value.formatToParts && typeof e.value.formatToParts == "function") {
      const y = g();
      y.setHours(20);
      const f = e.value.formatToParts(y).find((v) => v.type === "dayPeriod");
      if (f) return f.value;
    }
    return fa;
  });
  function g() {
    return typeof t.creator == "function" ? t.creator() : /* @__PURE__ */ new Date();
  }
  function u(y) {
    return typeof t.formatter == "function" ? t.formatter(y) : y ? e.value.format(y) : "";
  }
  function c(y) {
    if (typeof t.parser == "function") return t.parser(y);
    if (y) {
      if (e.value.formatToParts && typeof e.value.formatToParts == "function") {
        const f = [
          ca,
          fa,
          ca.toLowerCase(),
          fa.toLowerCase(),
          s.value,
          d.value
        ], v = e.value.formatToParts(/* @__PURE__ */ new Date()), I = v.map((B, P) => B.type === "literal" ? P + 1 < v.length && v[P + 1].type === "hour" ? "[^\\d]+" : B.value.replace(/ /g, "\\s?") : B.type === "dayPeriod" ? `((?!=<${B.type}>)(${f.join(
          "|"
        )})?)` : `((?!=<${B.type}>)\\d+)`).join(""), C = Pa(I, y);
        if (C.year && C.year.length === 4 && C.month && C.month <= 12 && C.day && C.day <= 31 && C.hour && C.hour >= 0 && C.hour < 24 && C.minute && C.minute >= 0 && C.minute <= 59)
          return new Date(
            C.year,
            C.month - 1,
            C.day,
            C.hour,
            C.minute,
            C.second || 0
          );
      }
      return new Date(Date.parse(y));
    }
  }
  return {
    dtf: e,
    datetimeCreator: g,
    datetimeFormatter: u,
    datetimeParser: c
  };
}
const mn = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "ODatetimepicker",
  configField: "datetimepicker",
  inheritAttrs: !1,
  __name: "Datetimepicker",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    active: { type: Boolean, default: !1 },
    datepicker: { default: void 0 },
    timepicker: { default: void 0 },
    minDatetime: { default: void 0 },
    maxDatetime: { default: void 0 },
    size: { default: () => n("datetimepicker.size") },
    expanded: { type: Boolean, default: !1 },
    rounded: { type: Boolean, default: !1 },
    placeholder: { default: void 0 },
    readonly: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    inline: { type: Boolean, default: !1 },
    openOnFocus: { type: Boolean, default: () => n("datetimepicker.openOnFocus", !0) },
    locale: { default: () => n("locale") },
    formatter: { type: Function, default: n("datetimepicker.dateFormatter") },
    parser: { type: Function, default: n("datetimepicker.dateParser") },
    creator: { type: Function, default: n("datetimepicker.datetimeCreator") },
    position: { default: void 0 },
    iconPack: { default: () => n("datetimepicker.iconPack") },
    icon: { default: () => n("datetimepicker.icon") },
    iconRight: { default: () => n("datetimepicker.iconRight") },
    iconRightClickable: { type: Boolean, default: !1 },
    mobileModal: { type: Boolean, default: () => n("datetimepicker.mobileModal", !0) },
    desktopModal: { type: Boolean, default: () => n("datetimepicker.desktopModal", !1) },
    mobileNative: { type: Boolean, default: () => n("datetimepicker.mobileNative", !0) },
    teleport: { type: [Boolean, String, Object], default: () => n("datetimepicker.teleport", !1) },
    useHtml5Validation: { type: Boolean, default: () => n("useHtml5Validation", !0) },
    customValidity: { type: [String, Function], default: "" },
    datepickerWrapperClass: {},
    timepickerWrapperClass: {}
  }, {
    active: { type: Boolean, default: !1 },
    activeModifiers: {},
    modelValue: { default: void 0 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:model-value", "update:active", "range-start", "range-end", "change-month", "change-year", "focus", "blur", "invalid", "icon-click", "icon-right-click"], ["update:active", "update:modelValue"]),
  setup(t, { expose: l, emit: a }) {
    const e = t, s = a, d = Me("datepickerComponent"), g = Me("nativeInputComponent"), u = ne(e.timepicker);
    be(
      () => e.timepicker,
      (r) => u.value = r,
      { deep: !0 }
    );
    const c = ne(e.datepicker);
    be(
      () => e.datepicker,
      (r) => c.value = r,
      { deep: !0 }
    );
    const y = o(
      () => e.mobileNative && ct.any()
    ), f = o(
      () => y.value ? g.value : d.value
    ), { setFocus: v, onBlur: I, onFocus: C, onInvalid: B } = et(
      f,
      s,
      e
    ), { datetimeFormatter: P, datetimeParser: h } = vn(e), z = Pe(t, "active"), F = Pe(t, "modelValue");
    function O(r) {
      if (Array.isArray(r)) return O(r[0]);
      if (!r) {
        F.value = void 0;
        return;
      }
      let m = new Date(r.getTime());
      e.modelValue && (r.getDate() !== e.modelValue.getDate() || r.getMonth() !== e.modelValue.getMonth() || r.getFullYear() !== e.modelValue.getFullYear()) && r.getHours() === 0 && r.getMinutes() === 0 && r.getSeconds() === 0 && m.setHours(
        e.modelValue.getHours(),
        e.modelValue.getMinutes(),
        e.modelValue.getSeconds(),
        0
      ), e.minDatetime && m < e.minDatetime ? m = e.minDatetime : e.maxDatetime && m > e.maxDatetime && (m = e.maxDatetime), F.value = new Date(m.getTime());
    }
    const K = o(() => {
      var r;
      return e.minDatetime ? new Date(
        e.minDatetime.getFullYear(),
        e.minDatetime.getMonth(),
        e.minDatetime.getDate(),
        0,
        0,
        0,
        0
      ) : (r = c.value) == null ? void 0 : r.minDate;
    }), U = o(() => {
      var r;
      return e.maxDatetime ? new Date(
        e.maxDatetime.getFullYear(),
        e.maxDatetime.getMonth(),
        e.maxDatetime.getDate(),
        0,
        0,
        0,
        0
      ) : (r = c.value) == null ? void 0 : r.maxDate;
    }), S = o(() => {
      var r;
      return !e.minDatetime || F.value === null || typeof F.value > "u" || F.value.getFullYear() != e.minDatetime.getFullYear() || F.value.getMonth() != e.minDatetime.getMonth() || F.value.getDate() != e.minDatetime.getDate() ? (r = u.value) == null ? void 0 : r.minTime : e.minDatetime;
    }), T = o(() => {
      var r;
      return !e.maxDatetime || F.value === null || typeof F.value > "u" || F.value.getFullYear() != e.maxDatetime.getFullYear() || F.value.getMonth() != e.maxDatetime.getMonth() || F.value.getDate() != e.maxDatetime.getDate() ? (r = u.value) == null ? void 0 : r.maxTime : e.maxDatetime;
    }), w = o(
      () => {
        var r;
        return ((r = c.value) == null ? void 0 : r.size) || e.size;
      }
    ), V = o(
      () => {
        var r;
        return ((r = u.value) == null ? void 0 : r.size) || e.size;
      }
    ), $ = o(
      () => {
        var r;
        return ((r = u.value) == null ? void 0 : r.disabled) || e.disabled;
      }
    );
    function Y(r) {
      return P(r);
    }
    function E(r) {
      const m = h(r);
      return lt(m) ? m : void 0;
    }
    function Z(r) {
      const m = r ? new Date(r) : void 0;
      if (m && lt(m)) {
        const R = m.getFullYear(), L = m.getMonth() + 1, te = m.getDate(), W = m.getHours(), H = m.getMinutes(), J = m.getSeconds();
        return R + "-" + tt(L) + "-" + tt(te) + "T" + tt(W) + ":" + tt(H) + ":" + tt(J);
      }
      return "";
    }
    function _(r) {
      const m = r.target.value, R = m ? m.split(/\D/) : [];
      if (R.length >= 5) {
        const L = parseInt(R[0], 10), te = parseInt(R[1], 10) - 1, W = parseInt(R[2], 10), H = parseInt(R[3], 10), J = parseInt(R[4], 10);
        O(new Date(L, te, W, H, J));
      } else
        O(void 0);
    }
    const q = M([
      "datepickerWrapperClass",
      "o-datetimepicker__date"
    ]), k = M([
      "timepickerWrapperClass",
      "o-datetimepicker__time"
    ]);
    return l({ focus: v, value: F }), (r, m) => !y.value || r.inline ? (p(), se(ol, fe({
      key: 0,
      ref: "datepickerComponent"
    }, { ...r.$attrs, ...r.datepicker }, {
      active: z.value,
      "onUpdate:active": m[1] || (m[1] = (R) => z.value = R),
      "model-value": F.value,
      "data-oruga": "datetimepicker",
      class: i(q),
      rounded: r.rounded,
      "open-on-focus": r.openOnFocus,
      position: r.position,
      inline: r.inline,
      readonly: r.readonly,
      expanded: r.expanded,
      "close-on-click": !1,
      formatter: Y,
      parser: E,
      "min-date": K.value,
      "max-date": U.value,
      icon: r.icon,
      "icon-right": r.iconRight,
      "icon-right-clickable": r.iconRightClickable,
      "icon-pack": r.iconPack,
      size: w.value,
      placeholder: r.placeholder,
      range: !1,
      multiple: !1,
      disabled: r.disabled,
      "desktop-modal": r.desktopModal,
      "mobile-modal": r.mobileModal,
      "mobile-native": y.value,
      locale: r.locale,
      teleport: r.teleport,
      "use-html5-validation": !1,
      "onUpdate:modelValue": O,
      onFocus: i(C),
      onBlur: i(I),
      onInvalid: i(B),
      onChangeMonth: m[2] || (m[2] = (R) => r.$emit("change-month", R)),
      onChangeYear: m[3] || (m[3] = (R) => r.$emit("change-year", R)),
      onIconClick: m[4] || (m[4] = (R) => r.$emit("icon-click", R)),
      onIconRightClick: m[5] || (m[5] = (R) => r.$emit("icon-right-click", R))
    }), {
      footer: de(() => [
        pe("div", {
          class: N(i(k))
        }, [
          he(nl, fe(r.timepicker, {
            modelValue: F.value,
            "onUpdate:modelValue": m[0] || (m[0] = (R) => F.value = R),
            inline: "",
            readonly: r.readonly,
            "min-time": S.value,
            "max-time": T.value,
            size: V.value,
            disabled: $.value,
            "mobile-native": y.value,
            locale: r.locale
          }), null, 16, ["modelValue", "readonly", "min-time", "max-time", "size", "disabled", "mobile-native", "locale"])
        ], 2),
        r.$slots.footer ? ae(r.$slots, "footer", { key: 0 }) : Q("", !0)
      ]),
      _: 3
    }, 16, ["active", "model-value", "class", "rounded", "open-on-focus", "position", "inline", "readonly", "expanded", "min-date", "max-date", "icon", "icon-right", "icon-right-clickable", "icon-pack", "size", "placeholder", "disabled", "desktop-modal", "mobile-modal", "mobile-native", "locale", "teleport", "onFocus", "onBlur", "onInvalid"])) : (p(), se(Pt, fe({ key: 1 }, r.$attrs, {
      ref: "nativeInputComponent",
      type: "datetime-local",
      autocomplete: "off",
      value: Z(F.value),
      max: Z(U.value),
      min: Z(K.value),
      placeholder: r.placeholder,
      size: w.value,
      "icon-pack": r.iconPack,
      icon: r.icon,
      rounded: r.rounded,
      disabled: r.disabled,
      readonly: !1,
      "use-html5-validation": !1,
      onChange: _,
      onFocus: i(C),
      onBlur: i(I),
      onInvalid: i(B)
    }), null, 16, ["value", "max", "min", "placeholder", "size", "icon-pack", "icon", "rounded", "disabled", "onFocus", "onBlur", "onInvalid"]));
  }
}), bn = {
  install(t) {
    Ie(t, mn);
  }
}, gn = {
  install(t) {
    Ie(t, wa), Ie(t, at);
  }
}, yn = ["id", "for"], Cn = ["id", "for"], sl = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OField",
  configField: "field",
  __name: "Field",
  props: {
    override: { type: Boolean, default: void 0 },
    variant: { default: void 0 },
    label: { default: void 0 },
    labelSize: { default: () => n("field.labelsize") },
    labelFor: { default: void 0 },
    labelId: { default: () => Le() },
    message: { default: void 0 },
    messageTag: { default: () => n("field.messageTag", "p") },
    messageId: { default: () => Le() },
    grouped: { type: Boolean, default: !1 },
    addons: { type: Boolean, default: !1 },
    multiline: { type: Boolean, default: !1 },
    horizontal: { type: Boolean, default: !1 },
    mobileBreakpoint: { default: () => n("field.mobileBreakpoint") },
    rootClass: {},
    mobileClass: {},
    focusedClass: {},
    filledClass: {},
    bodyClass: {},
    groupedClass: {},
    addonsClass: {},
    multilineClass: {},
    horizontalClass: {},
    horizontalLabelClass: {},
    horizontalBodyClass: {},
    labelClass: {},
    labelSizeClass: {},
    labelVariantClass: {},
    messageClass: {},
    messageVariantClass: {}
  },
  setup(t) {
    const l = t, { isMobile: a } = rt(l.mobileBreakpoint), e = ne(l.labelFor);
    be(
      () => l.labelFor,
      (k) => e.value = k
    );
    const s = ne(l.variant);
    be(
      () => l.variant,
      (k) => s.value = k
    );
    const d = ne(l.message);
    be(
      () => l.message,
      (k) => d.value = k
    ), be(d, (k) => {
      y.value && y.value.hasInnerField && (y.value.variant || y.value.setVariant(s.value), y.value.message || y.value.setMessage(k));
    });
    const g = ne(!1), u = ne(!1), c = ne(!1), { parentField: y } = Ge();
    y.value && y.value.addInnerField();
    const f = vt(), v = o(() => l.label || !!f.label), I = o(() => !!d.value || !!f.message), C = o(
      () => l.grouped || l.multiline || c.value || B.value
    ), B = o(
      () => l.addons && !l.horizontal && !!f.default
    );
    function P(k) {
      const r = k();
      return r.length === 1 && Array.isArray(r[0].children) ? r[0].children : r;
    }
    const h = Me("rootElement");
    function z() {
      c.value = !0;
    }
    function F(k) {
      g.value = k;
    }
    function O(k) {
      u.value = k;
    }
    function K(k) {
      s.value = k;
    }
    function U(k) {
      d.value = k;
    }
    function S(k) {
      e.value = k;
    }
    const T = o(() => ({
      "aria-labelledby": l.labelId,
      ...s.value === "error" ? { "aria-errormessage": l.messageId } : { "aria-describedby": l.messageId }
    })), w = o(() => ({
      $el: h.value,
      props: l,
      hasInnerField: c.value,
      variant: s.value,
      message: d.value,
      labelId: l.labelId,
      inputAttrs: T.value,
      addInnerField: z,
      setInputId: S,
      setFocus: F,
      setFilled: O,
      setVariant: K,
      setMessage: U
    }));
    mo(w);
    const V = M(
      ["rootClass", "o-field"],
      [
        "horizontalClass",
        "o-field--horizontal",
        null,
        o(() => !!l.horizontal)
      ],
      ["mobileClass", "o-field--mobile", null, a],
      ["focusedClass", "o-field--focused", null, g],
      ["filledClass", "o-field--filled", null, u]
    ), $ = M(
      ["labelClass", "o-field__label"],
      [
        "labelSizeClass",
        "o-field__label-",
        o(() => l.labelSize),
        o(() => !!l.labelSize)
      ],
      [
        "labelVariantClass",
        "o-field__label-",
        s,
        o(() => !!s.value)
      ]
    ), Y = M([
      "horizontalLabelClass",
      "o-field__horizontal-label"
    ]), E = M([
      "horizontalBodyClass",
      "o-field__horizontal-body"
    ]), Z = M(["bodyClass", "o-field__body"]), _ = M(
      ["rootClass", "o-field"],
      ["groupedClass", "o-field--grouped", null, o(() => l.grouped)],
      [
        "addonsClass",
        "o-field--addons",
        null,
        o(() => !l.grouped && B.value)
      ],
      [
        "multilineClass",
        "o-field--multiline",
        null,
        o(() => l.multiline)
      ]
    ), q = M(
      ["messageClass", "o-field__message"],
      [
        "messageVariantClass",
        "o-field__message-",
        s,
        o(() => !!s.value)
      ]
    );
    return (k, r) => {
      const m = Wa("OField");
      return p(), A("div", {
        ref: "rootElement",
        "data-oruga": "field",
        class: N(i(V))
      }, [
        k.horizontal ? (p(), A("div", {
          key: 0,
          class: N(i(Y))
        }, [
          v.value ? (p(), A("label", {
            key: 0,
            id: k.labelId,
            for: e.value,
            class: N(i($))
          }, [
            ae(k.$slots, "label", { label: k.label }, () => [
              Ve(ce(k.label), 1)
            ])
          ], 10, yn)) : Q("", !0)
        ], 2)) : (p(), A(ve, { key: 1 }, [
          v.value ? (p(), A("label", {
            key: 0,
            id: k.labelId,
            for: e.value,
            class: N(i($))
          }, [
            ae(k.$slots, "label", { label: k.label }, () => [
              Ve(ce(k.label), 1)
            ])
          ], 10, Cn)) : Q("", !0)
        ], 64)),
        k.horizontal ? (p(), A("div", {
          key: 2,
          class: N(i(E))
        }, [
          (p(!0), A(ve, null, $e(P(k.$slots.default), (R, L) => (p(), A(ve, { key: L }, [
            i(qa)(R) ? (p(), se(xe(R), { key: 0 })) : (p(), se(m, {
              key: 1,
              variant: s.value,
              addons: !1,
              "label-id": k.labelId,
              "message-id": k.messageId,
              "message-tag": k.messageTag,
              "message-class": k.messageClass
            }, Vt({
              default: de(() => [
                (p(), se(xe(R)))
              ]),
              _: 2
            }, [
              L === 0 ? {
                name: "message",
                fn: de(() => [
                  ae(k.$slots, "message", { message: d.value }, () => [
                    Ve(ce(d.value), 1)
                  ])
                ]),
                key: "0"
              } : void 0
            ]), 1032, ["variant", "label-id", "message-id", "message-tag", "message-class"]))
          ], 64))), 128))
        ], 2)) : C.value ? (p(), A("div", {
          key: 3,
          class: N(i(Z))
        }, [
          pe("div", {
            class: N(i(_))
          }, [
            ae(k.$slots, "default")
          ], 2)
        ], 2)) : ae(k.$slots, "default", { key: 4 }),
        I.value && !k.horizontal ? (p(), se(xe(k.messageTag), {
          key: 5,
          id: k.messageId,
          class: N(i(q))
        }, {
          default: de(() => [
            ae(k.$slots, "message", { message: d.value }, () => [
              Ve(ce(d.value), 1)
            ])
          ]),
          _: 3
        }, 8, ["id", "class"])) : Q("", !0)
      ], 2);
    };
  }
}), hn = {
  install(t) {
    Ie(t, sl);
  }
}, kn = {
  install(t) {
    Ie(t, Te);
  }
}, wn = {
  install(t) {
    Ie(t, Pt);
  }
}, Da = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OLoading",
  configField: "loading",
  inheritAttrs: !1,
  __name: "Loading",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    active: { type: Boolean, default: !1 },
    fullPage: { type: Boolean, default: !0 },
    label: { default: void 0 },
    animation: { default: () => n("loading.animation", "fade") },
    cancelable: { type: Boolean, default: !1 },
    icon: { default: () => n("loading.icon", "loading") },
    iconSpin: { type: Boolean, default: () => n("loading.iconSpin", !0) },
    iconSize: { default: () => n("loading.iconSize", "medium") },
    clipScroll: { type: Boolean, default: () => n("loading.clipScroll", !1) },
    container: {},
    rootClass: {},
    fullPageClass: {},
    overlayClass: {},
    iconClass: {},
    labelClass: {},
    scrollClipClass: {},
    scrollKeepClass: {}
  }, {
    fullPage: { type: Boolean, default: !0 },
    fullPageModifiers: {},
    active: { type: Boolean, default: !1 },
    activeModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:active", "update:fullPage", "close"], ["update:fullPage", "update:active"]),
  setup(t, { expose: l, emit: a }) {
    const e = t, s = a, d = Me("rootElement"), g = Pe(t, "fullPage"), u = Pe(t, "active"), c = aa(e.clipScroll);
    be(u, (h) => {
      g.value && c(h);
    }), Ee && mt(d, "keyup", y, { trigger: u });
    function y(h) {
      u.value && (h.key === "Escape" || h.key === "Esc") && f("escape");
    }
    function f(h) {
      !e.cancelable || Array.isArray(e.cancelable) && !e.cancelable.includes(h) || v({ action: "cancel", method: h });
    }
    function v(...h) {
      u.value = !1, s("close", h);
    }
    const I = M(
      ["rootClass", "o-loading"],
      ["fullPageClass", "o-loading--fullpage", null, g]
    ), C = M(["overlayClass", "o-loading__overlay"]), B = M(["iconClass", "o-loading__icon"]), P = M(["labelClass", "o-loading__label"]);
    return l({ close: v }), (h, z) => (p(), se(Je, { name: h.animation }, {
      default: de(() => [
        u.value ? (p(), A("div", {
          key: 0,
          ref: "rootElement",
          "data-oruga": "loading",
          class: N(i(I)),
          role: "status",
          "aria-live": "polite"
        }, [
          pe("div", {
            class: N(i(C)),
            tabindex: -1,
            onClick: z[0] || (z[0] = (F) => f("outside"))
          }, null, 2),
          ae(h.$slots, "default", { close: v }, () => [
            he(Te, {
              icon: h.icon,
              spin: h.iconSpin,
              size: h.iconSize,
              class: N(i(B)),
              both: ""
            }, null, 8, ["icon", "spin", "size", "class"]),
            h.label ? (p(), A("span", {
              key: 0,
              class: N(i(P))
            }, ce(h.label), 3)) : Q("", !0)
          ])
        ], 2)) : Q("", !0)
      ]),
      _: 3
    }, 8, ["name"]));
  }
});
class Tt {
  constructor() {
    Fa(this, "entries");
    this.entries = [];
  }
  /** Returns the number of registered active instances. */
  count() {
    return this.entries.length;
  }
  /** Returns the first registered active instance. */
  fist() {
    return this.entries.at(0);
  }
  /** Returns the last registered active instance. */
  last() {
    return this.entries.at(-1);
  }
  /** Adds a new instance to the instance stack. */
  add(l) {
    this.entries.push(l);
  }
  /** Removes an instance from the instance stack. */
  remove(l) {
    const a = this.entries.indexOf(l);
    this.entries.splice(a, 1);
  }
  /** Call a function for every registered active instance. */
  walk(l) {
    this.entries = [...this.entries].filter((a) => l(a) !== !0);
  }
}
const Pn = Ce(
  (t, { expose: l, emit: a, slots: e }) => {
    const s = St();
    if (!s)
      throw new Error("ProgrammaticComponent initialisation failed.");
    let d;
    const g = new Promise((c) => d = c);
    st(() => {
      var c;
      return (c = t.registry) == null ? void 0 : c.add(s);
    }), ea(() => {
      var c;
      return (c = t.registry) == null ? void 0 : c.remove(s);
    });
    function u(...c) {
      a("close", ...c), d(...c), setTimeout(() => {
        Ee ? window.requestAnimationFrame(() => a("destroy")) : a("destroy");
      });
    }
    return l({ close: u, promise: g }), () => he(
      t.component,
      { ...t.props, onClose: u },
      e.default
    );
  },
  {
    name: "ProgrammaticApp",
    // manual runtime props declaration is currently still needed.
    props: ["component", "props", "registry"],
    // manual runtime emits declaration
    emits: ["close", "destroy"],
    // manual runtime slot declaration
    slots: ["default"]
  }
), Yt = new Tt(), Rt = {
  /** Returns the number of registered active instances. */
  count: Yt.count,
  /**
   * Create a new programmatic component instance.
   * @param component component to render
   * @param options render options
   */
  open(t, l) {
    l = { registry: Yt, ...l };
    const a = Ae(l.target), e = (
      // either by a given query selector / element
      a && Aa(a) || // or by the default teleport target config
      Aa(la())
    );
    if (!e)
      throw new Error("ComponentProgrammatic - no target is defined.");
    let s = document.createElement("div");
    s.id = l.appId || "programmatic-app", e.appendChild(s);
    function d() {
      g && (g.unmount(), g = void 0), s && e && (e.removeChild(s), s = void 0);
    }
    let g = Ql(Pn, {
      registry: l.registry,
      // programmatic registry instance - can be overriden by given in options
      component: t,
      // the component which should be rendered
      props: { ...l.props, container: e },
      // component props including the target as `container`
      onClose: l.onClose,
      // custom onClose handler
      onDestroy: d
      // node destory cleanup handler
    });
    return pa && (g._context = Object.assign(g._context, pa._context)), g.mount(s);
  },
  /** close the last registred instance in the global programmatic instance registry */
  close(...t) {
    var l, a;
    (a = (l = Yt.last()) == null ? void 0 : l.exposed) == null || a.close(...t);
  },
  /** close all instances in the global programmatic instance registry */
  closeAll(...t) {
    Yt.walk((l) => {
      var a;
      return (a = l.exposed) == null ? void 0 : a.close(...t);
    });
  }
}, Dn = {
  install(t) {
    $t(
      t,
      "programmatic",
      Rt
    );
  }
}, Wt = new Tt(), Sn = {
  /** Returns the number of registered active instances. */
  count: Wt.count,
  /**
   * Create a new programmatic loading component instance.
   * @param options loading label string or loading component props object
   * @param target specify a target the component get rendered into
   * @returns ProgrammaticExpose
   */
  open(t, l) {
    const a = typeof t == "string" ? { label: t } : t, e = {
      active: !0,
      // set the active default state to true
      fullPage: !1,
      // set the full page default state to false
      ...a
    };
    return Rt.open(Da, {
      registry: Wt,
      // custom programmatic instance registry
      target: l,
      // target the component get rendered into
      props: e,
      // component specific props
      onClose: a.onClose
      // on close event handler
    });
  },
  /** Close the last registred instance in the loading programmatic instance registry. */
  close(...t) {
    var l, a;
    (a = (l = Wt.last()) == null ? void 0 : l.exposed) == null || a.close(...t);
  },
  /** Close all instances in the programmatic loading instance registry. */
  closeAll(...t) {
    Wt.walk((l) => {
      var a;
      return (a = l.exposed) == null ? void 0 : a.close(...t);
    });
  }
}, $n = {
  install(t) {
    Ie(t, Da), $t(t, "loading", Sn);
  }
}, Bn = ["id", "data-id"], In = ["id"], jt = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OMenuItem",
  configField: "menu",
  inheritAttrs: !1,
  __name: "MenuItem",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    value: {},
    active: { type: Boolean, default: !1 },
    options: { default: void 0 },
    label: { default: void 0 },
    expanded: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    hidden: { type: Boolean, default: !1 },
    submenuId: { default: () => Le() },
    icon: { default: void 0 },
    iconPack: { default: () => n("menu.iconPack") },
    iconSize: { default: () => n("menu.iconSize") },
    animation: { default: () => n("menu.animation", "slide") },
    tag: { default: () => n("menu.itemTag", "button") },
    itemClass: {},
    itemActiveClass: {},
    itemFocusedClass: {},
    itemDisabledClass: {},
    itemButtonClass: {},
    itemButtonActiveClass: {},
    itemButtonFocusedClass: {},
    itemButtonDisabledClass: {},
    itemButtonIconClass: {},
    itemSubmenuClass: {}
  }, {
    active: { type: Boolean, default: !1 },
    activeModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:active", "click"], ["update:active"]),
  setup(t, { emit: l }) {
    const a = t, e = l, s = a.value ?? Le(), d = o(() => ({
      expanded: F.value,
      setExpand: O,
      triggerReset: z
    })), { childItems: g } = bt({
      key: "menu-item",
      data: d
    }), u = pt({
      key: "menu-item",
      needParent: !1
    }), c = o(() => ({
      ...a,
      value: s,
      parent: u.parent.value,
      hasChildren: B.value,
      expanded: F.value,
      setExpand: O,
      reset: K,
      selectItem: h
    })), { parent: y, item: f } = pt({ data: c }), v = y.value.nextSequence, I = o(
      () => dt(a.options, v)
    ), C = Pe(t, "active"), B = o(() => !!g.value.length), P = o(
      () => f.value.identifier === y.value.focsuedIdentifier
    );
    function h(w) {
      a.disabled || y.value.disabled || (z(), C.value = !C.value, y.value.accordion && (F.value = C.value), y.value.selectItem(C.value ? f.value : void 0), e("click", s, w));
    }
    function z(w) {
      var V;
      typeof ((V = u.parent.value) == null ? void 0 : V.triggerReset) == "function" ? u.parent.value.triggerReset(
        w ? [f.value, ...w] : [f.value]
      ) : typeof y.value.resetMenu == "function" && y.value.resetMenu(w ? [f.value, ...w] : [f.value]);
    }
    const F = ne(a.expanded);
    y.value.accordion || (F.value = !0);
    function O(w) {
      var V;
      y.value.accordion && (F.value = w, typeof ((V = u.parent.value) == null ? void 0 : V.setExpand) == "function" && u.parent.value.setExpand(w));
    }
    function K() {
      y.value.accordion && (F.value = !1), C.value = !1;
    }
    const U = M(
      ["itemClass", "o-menu__item"],
      ["itemActiveClass", "o-menu__item--active", null, C],
      ["itemFocusedClass", "o-menu__item--focused", null, P],
      [
        "itemDisabledClass",
        "o-menu__item--disabled",
        null,
        o(() => a.disabled || y.value.disabled)
      ]
    ), S = M(
      ["itemButtonClass", "o-menu__item__button"],
      ["itemButtonActiveClass", "o-menu__item__button--active", null, C],
      [
        "itemButtonFocusedClass",
        "o-menu__item__button--focused",
        null,
        P
      ],
      [
        "itemButtonDisabledClass",
        "o-menu__item__button--disabled",
        null,
        o(() => a.disabled || y.value.disabled)
      ],
      [
        "itemButtonIconClass",
        "o-menu__item__button--icon",
        null,
        o(() => !!a.icon)
      ]
    ), T = M([
      "itemSubmenuClass",
      "o-menu__item__submenu"
    ]);
    return (w, V) => {
      const $ = Wa("OMenuItem");
      return Be((p(), A("li", {
        id: `${i(y).menuId}-${i(f).identifier}`,
        "data-oruga": "menu-item",
        "data-id": `menu-${i(f).identifier}`,
        class: N(i(U)),
        role: "none"
      }, [
        (p(), se(xe(w.tag), fe(w.$attrs, {
          class: i(S),
          role: i(y).role + "item",
          disabled: w.disabled || i(y).disabled,
          tabindex: "-1",
          "aria-selected": i(y).role == "tree" ? C.value : void 0,
          "aria-disabled": w.disabled || i(y).disabled,
          "aria-expanded": B.value ? F.value : void 0,
          "aria-owns": B.value ? w.submenuId : void 0,
          onClick: h,
          onKeydown: [
            oe(h, ["enter"]),
            oe(h, ["space"])
          ]
        }), {
          default: de(() => [
            w.icon ? (p(), se(Te, {
              key: 0,
              icon: w.icon,
              pack: w.iconPack,
              size: w.iconSize
            }, null, 8, ["icon", "pack", "size"])) : Q("", !0),
            ae(w.$slots, "label", {
              expanded: F.value,
              active: C.value
            }, () => [
              pe("span", null, ce(w.label), 1)
            ])
          ]),
          _: 3
        }, 16, ["class", "role", "disabled", "aria-selected", "aria-disabled", "aria-expanded", "aria-owns"])),
        w.$slots.default || w.options ? (p(), se(Je, {
          key: 0,
          name: w.animation
        }, {
          default: de(() => [
            Be(pe("ul", {
              id: w.submenuId,
              class: N(i(T)),
              tabindex: "-1",
              role: "group"
            }, [
              ae(w.$slots, "default", {}, () => [
                (p(!0), A(ve, null, $e(I.value, (Y) => (p(), se($, fe({
                  key: Y.key,
                  ref_for: !0
                }, Y.attrs, {
                  value: Y.value,
                  label: Y.label,
                  hidden: Y.hidden
                }), null, 16, ["value", "label", "hidden"]))), 128))
              ])
            ], 10, In), [
              [Oe, F.value]
            ])
          ]),
          _: 3
        }, 8, ["name"])) : Q("", !0)
      ], 10, Bn)), [
        [Oe, !w.hidden]
      ]);
    };
  }
}), Fn = ["id"], Mn = ["id", "role", "aria-labelledby", "onKeydown"], On = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OMenu",
  configField: "menu",
  __name: "Menu",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    options: { default: void 0 },
    label: { default: void 0 },
    accordion: { type: Boolean, default: !0 },
    disabled: { type: Boolean, default: !1 },
    menuId: { default: () => Le() },
    labelId: { default: () => Le() },
    role: { default: () => n("menu.role", "tree") },
    icon: { default: void 0 },
    iconPack: { default: () => n("menu.iconPack") },
    iconSize: { default: () => n("menu.iconSize") },
    rootClass: {},
    listClass: {},
    labelClass: {}
  }, {
    modelValue: { default: void 0 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:model-value"], ["update:modelValue"]),
  setup(t) {
    const l = t, a = Me("rootElement"), e = o(() => {
      var E;
      return {
        focsuedIdentifier: (E = v.value) == null ? void 0 : E.identifier,
        menuId: l.menuId,
        accordion: l.accordion,
        disabled: l.disabled,
        role: l.role,
        nextSequence: d,
        resetMenu: u,
        selectItem: f
      };
    }), { childItems: s } = bt({ rootRef: a, data: e }), { nextSequence: d } = ut(), g = o(
      () => dt(l.options, d)
    );
    function u(E = []) {
      s.value.forEach((Z) => {
        var _;
        E.map((q) => q == null ? void 0 : q.identifier).includes(Z.identifier) || (_ = Z.data) == null || _.reset();
      });
    }
    const c = Pe(t, "modelValue"), y = ne();
    function f(E) {
      var _;
      const Z = (_ = E == null ? void 0 : E.data) == null ? void 0 : _.value;
      c.value != Z && (c.value = Z, y.value = E);
    }
    const v = ne(), I = o(() => s.value.some(T));
    function C() {
      var E, Z;
      v.value && ((E = v.value.data) != null && E.expanded ? (Z = v.value.data) == null || Z.setExpand(!1) : h(-1));
    }
    function B() {
      var E, Z, _;
      v.value && ((E = v.value.data) != null && E.hasChildren && !((Z = v.value.data) != null && Z.expanded) ? (_ = v.value.data) == null || _.setExpand(!0) : h(1));
    }
    function P(E) {
      v.value = E;
    }
    function h(E) {
      var _;
      if (!I.value) return;
      const Z = S(((_ = v.value) == null ? void 0 : _.index) || 0, E);
      P(Z);
    }
    function z() {
      h(-1);
    }
    function F() {
      h(1);
    }
    function O(E) {
      var Z;
      v.value && (P(v.value), (Z = v.value.data) == null || Z.selectItem(E));
    }
    function K() {
      if (!I.value) return;
      const E = S(0, 1);
      P(E);
    }
    function U() {
      if (!I.value) return;
      const E = S(s.value.length - 1, -1);
      P(E);
    }
    function S(E, Z) {
      var q, k;
      let _ = ot(
        ((q = v.value) == null ? void 0 : q.index) == E ? E + Z : E,
        s.value.length
      );
      for (; _ !== ((k = v.value) == null ? void 0 : k.index) && !T(s.value[_]); _ = ot(_ + Z, s.value.length))
        ;
      return s.value[_];
    }
    function T(E) {
      var Z, _, q, k;
      return !((Z = E.data) != null && Z.disabled) && !((_ = E.data) != null && _.hidden) && (((k = (q = E.data) == null ? void 0 : q.parent) == null ? void 0 : k.expanded) ?? !0);
    }
    function w() {
      v.value = void 0;
    }
    const V = M(["rootClass", "o-menu"]), $ = M(["listClass", "o-menu__list"]), Y = M(["labelClass", "o-menu__label"]);
    return (E, Z) => {
      var _, q, k, r, m, R, L, te;
      return p(), A("nav", {
        ref: "rootElement",
        "data-oruga": "menu",
        class: N(i(V)),
        onFocusout: w
      }, [
        E.label || E.$slots.label ? (p(), A("div", {
          key: 0,
          id: E.labelId,
          class: N(i(Y))
        }, [
          ae(E.$slots, "label", {
            focused: (_ = v.value) == null ? void 0 : _.data,
            focusedIndex: (q = v.value) == null ? void 0 : q.index,
            selected: (k = y.value) == null ? void 0 : k.data,
            selectedIndex: (r = y.value) == null ? void 0 : r.index
          }, () => [
            E.icon ? (p(), se(Te, {
              key: 0,
              icon: E.icon,
              pack: E.iconPack,
              size: E.iconSize
            }, null, 8, ["icon", "pack", "size"])) : Q("", !0),
            pe("span", null, ce(E.label), 1)
          ])
        ], 10, Fn)) : Q("", !0),
        pe("ul", {
          id: E.menuId,
          class: N(i($)),
          role: E.role,
          tabindex: 0,
          "aria-labelledby": E.labelId,
          onKeydown: [
            oe(C, ["left"]),
            oe(B, ["right"]),
            oe(re(O, ["prevent"]), ["enter"]),
            oe(re(O, ["prevent"]), ["space"]),
            oe(re(z, ["prevent"]), ["up"]),
            oe(re(F, ["prevent"]), ["down"]),
            oe(re(K, ["prevent"]), ["home"]),
            oe(re(U, ["prevent"]), ["end"])
          ]
        }, [
          ae(E.$slots, "default", {
            focused: (m = v.value) == null ? void 0 : m.data,
            focusedIndex: (R = v.value) == null ? void 0 : R.index,
            selected: (L = y.value) == null ? void 0 : L.data,
            selectedIndex: (te = y.value) == null ? void 0 : te.index
          }, () => [
            (p(!0), A(ve, null, $e(g.value, (W) => (p(), A(ve, {
              key: W.key
            }, [
              i(Bt)(W) ? (p(), se(jt, fe({
                key: 0,
                ref_for: !0
              }, W.attrs, {
                label: W.label,
                hidden: W.hidden
              }), {
                default: de(() => [
                  (p(!0), A(ve, null, $e(W.options, (H) => (p(), se(jt, fe({ ref_for: !0 }, H.attrs, {
                    key: H.key,
                    value: H.value,
                    label: H.label,
                    hidden: H.hidden
                  }), null, 16, ["value", "label", "hidden"]))), 128))
                ]),
                _: 2
              }, 1040, ["label", "hidden"])) : (p(), se(jt, fe({
                key: 1,
                ref_for: !0
              }, W.attrs, {
                value: W.value,
                label: W.label,
                hidden: W.hidden
              }), null, 16, ["value", "label", "hidden"]))
            ], 64))), 128))
          ])
        ], 42, Mn)
      ], 34);
    };
  }
}), Vn = {
  install(t) {
    Ie(t, On), Ie(t, jt);
  }
}, An = ["role", "aria-label", "aria-modal"], zn = { key: 0 }, il = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OModal",
  configField: "modal",
  inheritAttrs: !1,
  __name: "Modal",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    active: { type: Boolean, default: !1 },
    fullScreen: { type: Boolean, default: !1 },
    content: { default: void 0 },
    width: { default: () => n("modal.width", 960) },
    animation: { default: () => n("modal.animation", "zoom-out") },
    overlay: { type: Boolean, default: () => n("modal.overlay", !0) },
    cancelable: { type: [Array, Boolean], default: () => n("modal.cancelable", ["escape", "x", "outside"]) },
    clipScroll: { type: Boolean, default: () => n("modal.clipScroll", !1) },
    trapFocus: { type: Boolean, default: () => n("modal.trapFocus", !0) },
    role: { default: () => n("modal.role", "dialog") },
    ariaLabel: { default: () => n("modal.ariaLabel") },
    autoFocus: { type: Boolean, default: () => n("modal.autoFocus", !0) },
    closeIcon: { default: () => n("modal.closeIcon", "close") },
    closeIconSize: { default: () => n("modal.closeIconSize", "medium") },
    mobileBreakpoint: { default: () => n("modal.mobileBreakpoint") },
    teleport: { type: [Boolean, String, Object], default: () => n("modal.teleport", !1) },
    container: {},
    component: { default: void 0 },
    props: { default: void 0 },
    events: { default: void 0 },
    rootClass: {},
    mobileClass: {},
    activeClass: {},
    overlayClass: {},
    contentClass: {},
    fullScreenClass: {},
    closeClass: {},
    scrollClipClass: {},
    scrollKeepClass: {}
  }, {
    active: { type: Boolean, default: !1 },
    activeModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:active", "close"], ["update:active"]),
  setup(t, { expose: l, emit: a }) {
    const e = t, s = a, { vTrapFocus: d } = el(), g = Me("rootElement"), u = Me("contentElement"), c = Pe(t, "active"), { isMobile: y } = rt(e.mobileBreakpoint), f = o(
      () => typeof e.teleport == "boolean" ? { to: la(), disabled: !e.teleport } : { to: e.teleport, disabled: !1 }
    ), v = o(
      () => Array.isArray(e.cancelable) ? e.cancelable.indexOf("x") >= 0 : e.cancelable
    ), I = o(
      () => e.fullScreen ? null : { maxWidth: wt(e.width) }
    ), C = aa(e.clipScroll);
    be(c, (V) => {
      e.overlay && C(V), V && e.autoFocus && ze(() => {
        g.value && g.value.focus();
      });
    }), st(() => {
      c.value && e.overlay && C(c.value);
    }), Ee && (mt(g, "keyup", B, { trigger: c }), e.overlay || ta(u, P, {
      trigger: c
    }));
    function B(V) {
      c.value && (V.key === "Escape" || V.key === "Esc") && h("escape");
    }
    function P(V) {
      !c.value || F.value || ((e.overlay || u.value && !V.composedPath().includes(u.value)) && V.preventDefault(), h("outside"));
    }
    function h(V) {
      typeof e.cancelable == "boolean" && !e.cancelable || !e.cancelable || Array.isArray(e.cancelable) && !e.cancelable.includes(V) || z({ action: "cancel", method: V });
    }
    function z(...V) {
      c.value = !1, s("close", V);
    }
    const F = ne(!e.active);
    function O() {
      F.value = !1;
    }
    function K() {
      F.value = !0;
    }
    const U = M(
      ["rootClass", "o-modal"],
      ["mobileClass", "o-modal--mobile", null, y],
      ["activeClass", "o-modal--active", null, c]
    ), S = M(["overlayClass", "o-modal__overlay"]), T = M(
      ["contentClass", "o-modal__content"],
      [
        "fullScreenClass",
        "o-modal__content--full-screen",
        null,
        o(() => e.fullScreen)
      ]
    ), w = M(["closeClass", "o-modal__close"]);
    return l({ close: z }), (V, $) => (p(), se(ga, {
      to: f.value.to,
      disabled: f.value.disabled
    }, [
      he(Je, {
        name: V.animation,
        onAfterEnter: O,
        onBeforeLeave: K
      }, {
        default: de(() => [
          Be((p(), A("div", fe({ ref: "rootElement" }, V.$attrs, {
            "data-oruga": "modal",
            class: i(U),
            tabindex: -1,
            role: V.role,
            "aria-label": V.ariaLabel,
            "aria-modal": c.value
          }), [
            V.overlay ? (p(), A("div", {
              key: 0,
              class: N(i(S)),
              tabindex: "-1",
              onClick: P
            }, null, 2)) : Q("", !0),
            pe("div", {
              ref: "contentElement",
              class: N(i(T)),
              style: Xe(I.value)
            }, [
              V.component ? (p(), se(xe(V.component), fe({ key: 0 }, V.$props.props, At(V.$props.events || {}), { onClose: z }), null, 16)) : ae(V.$slots, "default", {
                key: 1,
                close: z
              }, () => [
                V.content ? (p(), A("div", zn, ce(V.content), 1)) : Q("", !0)
              ]),
              v.value ? Be((p(), se(Te, {
                key: 2,
                clickable: "",
                both: "",
                class: N(i(w)),
                icon: V.closeIcon,
                size: V.closeIconSize,
                onClick: $[0] || ($[0] = (Y) => h("x"))
              }, null, 8, ["class", "icon", "size"])), [
                [Oe, !F.value]
              ]) : Q("", !0)
            ], 6)
          ], 16, An)), [
            [Oe, c.value],
            [i(d), c.value && V.trapFocus]
          ])
        ]),
        _: 3
      }, 8, ["name"])
    ], 8, ["to", "disabled"]));
  }
}), Kt = new Tt(), Tn = {
  /** Returns the number of registered active instances. */
  count: Kt.count,
  /**
   * Create a new programmatic modal component instance.
   * @param options modal content string or modal component props object
   * @param target specify a target the component get rendered into - default is `document.body`
   * @returns ProgrammaticExpose
   */
  open(t, l) {
    const a = typeof t == "string" ? { content: t } : t, e = {
      active: !0,
      // set the active default state to true
      ...a
    };
    return Rt.open(il, {
      registry: Kt,
      // custom programmatic instance registry
      target: l,
      // target the component get rendered into
      props: e,
      // component specific props
      onClose: a.onClose
      // on close event handler
    });
  },
  /** Close the last registred instance in the modal programmatic instance registry. */
  close(...t) {
    var l, a;
    (a = (l = Kt.last()) == null ? void 0 : l.exposed) == null || a.close(...t);
  },
  /** Close all instances in the programmatic modal instance registry. */
  closeAll(...t) {
    Kt.walk((l) => {
      var a;
      return (a = l.exposed) == null ? void 0 : a.close(...t);
    });
  }
}, Rn = {
  install(t) {
    Ie(t, il), $t(t, "modal", Tn);
  }
}, Ln = ["aria-label"], En = { key: 0 }, rl = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "ONotification",
  configField: "notification",
  inheritAttrs: !1,
  __name: "Notification",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    message: { default: void 0 },
    active: { type: Boolean, default: !0 },
    type: { default: void 0 },
    variant: { default: () => n("notification.variant") },
    position: { default: () => n("notification.position", "top") },
    animation: { default: () => n("notification.animation", "fade") },
    icon: { default: void 0 },
    iconPack: { default: () => n("notification.iconPack") },
    iconSize: { default: () => n("notification.iconSize", "large") },
    closable: { type: Boolean, default: !1 },
    closeIcon: { default: () => n("notification.closeIcon", "close") },
    closeIconSize: { default: () => n("notification.closeIconSize") },
    ariaCloseLabel: { default: () => n("notification.ariaCloseLabel", "Close") },
    rootClass: {},
    positionClass: {},
    variantClass: {},
    closeClass: {},
    contentClass: {},
    iconClass: {},
    wrapperClass: {}
  }, {
    active: { type: Boolean, default: !0 },
    activeModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:active", "close"], ["update:active"]),
  setup(t, { emit: l }) {
    const a = t, e = l, s = Pe(t, "active"), d = o(() => {
      if (a.icon) return a.icon;
      switch (a.type) {
        case "info":
          return "information";
        case "success":
          return "check-circle";
        case "warning":
          return "alert";
        case "danger":
          return "alert-circle";
        default:
          return null;
      }
    });
    function g(...I) {
      s.value = !1, e("close", ...I);
    }
    const u = M(
      ["rootClass", "o-notification"],
      [
        "variantClass",
        "o-notification--",
        o(() => a.variant),
        o(() => !!a.variant)
      ],
      [
        "positionClass",
        "o-notification--",
        o(() => a.position),
        o(() => !!a.position)
      ]
    ), c = M([
      "wrapperClass",
      "o-notification__wrapper"
    ]), y = M(["iconClass", "o-notification__icon"]), f = M([
      "contentClass",
      "o-notification__content"
    ]), v = M(["closeClass", "o-notification__close"]);
    return (I, C) => (p(), se(Je, { name: I.animation }, {
      default: de(() => [
        Be(pe("article", fe(I.$attrs, {
          "data-oruga": "notification",
          class: i(u)
        }), [
          I.closable ? (p(), A("button", {
            key: 0,
            class: N(i(v)),
            type: "button",
            "aria-label": I.ariaCloseLabel,
            onClick: C[0] || (C[0] = (B) => g({ action: "close", method: "x" }))
          }, [
            he(Te, {
              clickable: "",
              pack: I.iconPack,
              icon: I.closeIcon,
              size: I.closeIconSize,
              both: ""
            }, null, 8, ["pack", "icon", "size"])
          ], 10, Ln)) : Q("", !0),
          ae(I.$slots, "inner", { close: g }),
          I.$slots.default || I.message ? (p(), A("div", {
            key: 1,
            class: N(i(c))
          }, [
            d.value ? (p(), se(Te, {
              key: 0,
              icon: d.value,
              pack: I.iconPack,
              class: N(i(y)),
              size: I.iconSize,
              both: "",
              "aria-hidden": ""
            }, null, 8, ["icon", "pack", "class", "size"])) : Q("", !0),
            pe("div", {
              class: N(i(f))
            }, [
              ae(I.$slots, "default", { close: g }, () => [
                I.message ? (p(), A("span", En, ce(I.message), 1)) : Q("", !0)
              ])
            ], 2)
          ], 2)) : Q("", !0)
        ], 16), [
          [Oe, s.value]
        ])
      ]),
      _: 3
    }, 8, ["name"]));
  }
}), Hn = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "ONotificationNotice",
  configField: "notification",
  inheritAttrs: !1,
  __name: "NotificationNotice",
  props: {
    override: { type: Boolean, default: void 0 },
    container: { default: void 0 },
    position: { default: () => n("notification.position", "top") },
    variant: { default: () => n("notification.variant") },
    duration: { default: () => n("notification.duration", 2e3) },
    infinite: { type: Boolean, default: !1 },
    queue: { type: Boolean, default: () => n("notification.queue") },
    component: { default: void 0 },
    props: { default: void 0 },
    events: { default: void 0 },
    noticeClass: {},
    noticePositionClass: {},
    noticeContainerClass: {}
  },
  emits: ["close"],
  setup(t, { expose: l, emit: a }) {
    const e = t, s = a, d = Me("notificationComponent"), g = ne(!0), u = ne(null), c = ne(null), y = ne();
    Jl(() => {
      if (h.value && F.value && z.value) {
        const K = Ke(h.value), U = Ke(z.value), S = Ke(F.value);
        if (u.value = e.container.querySelector(
          `.${K.join(".")}.${U.join(".")}`
        ), c.value = e.container.querySelector(
          `.${K.join(".")}.${S.join(".")}`
        ), u.value && c.value) return;
        if (u.value || (u.value = document.createElement("div"), u.value.className = `${K.join(
          " "
        )} ${U.join(" ")}`, u.value.role = "region", u.value.ariaLive = "polite"), c.value || (c.value = document.createElement("div"), c.value.className = `${K.join(
          " "
        )} ${S.join(" ")}`, c.value.role = "region", c.value.ariaLive = "polite"), e.container.appendChild(u.value), e.container.appendChild(c.value), e.container.tagName !== "BODY") {
          const T = Ke(O.value);
          T != null && T.length && T.filter((w) => !!w).forEach((w) => {
            var V, $;
            (V = u.value) == null || V.classList.add(w), ($ = c.value) == null || $.classList.add(w);
          });
        }
      }
    }), st(() => {
      C(), B();
    });
    const f = o(() => {
      switch (e.position) {
        case "top-right":
        case "top":
        case "top-left":
          return u.value;
        case "bottom-right":
        case "bottom":
        case "bottom-left":
          return c.value;
        default:
          return null;
      }
    }), v = o(
      () => e.queue && u.value && c.value ? u.value.childElementCount > 0 || c.value.childElementCount > 0 : !1
    ), I = o(
      () => e.variant === "warning" || e.variant === "danger"
    );
    function C() {
      var K;
      f.value && (v.value && (f.value.innerHTML = ""), f.value.insertAdjacentElement(
        "afterbegin",
        (K = d.value) == null ? void 0 : K.$el
      ));
    }
    function B() {
      e.infinite || (y.value && clearTimeout(y.value), y.value = setTimeout(() => {
        g.value && P({ action: "close", method: "timeout" });
      }, e.duration));
    }
    function P(...K) {
      g.value = !1, y.value && clearTimeout(y.value), s("close", K);
    }
    const h = M(["noticeClass", "o-notices"]), z = M([
      "noticePositionClass",
      "o-notices--",
      "top"
    ]), F = M([
      "noticePositionClass",
      "o-notices--",
      "bottom"
    ]), O = M([
      "noticeContainerClass",
      "o-notices__container"
    ]);
    return l({ close: P }), (K, U) => (p(), se(rl, fe({ ref: "notificationComponent" }, K.$attrs, {
      active: g.value,
      "onUpdate:active": U[0] || (U[0] = (S) => g.value = S),
      override: K.override,
      position: K.position,
      variant: K.variant,
      role: I.value ? "alert" : "status",
      "aria-atomic": !0,
      onClose: P
    }), {
      inner: de(({ close: S }) => [
        K.component ? (p(), se(xe(K.component), fe({ key: 0 }, K.$props.props, At(K.$props.events || {}), { onClose: S }), null, 16, ["onClose"])) : Q("", !0)
      ]),
      default: de(() => [
        ae(K.$slots, "default")
      ]),
      _: 3
    }, 16, ["active", "override", "position", "variant", "role"]));
  }
}), Ut = new Tt(), Nn = {
  /** Returns the number of registered active instances. */
  count: Ut.count,
  /**
   * Create a new programmatic notification component instance.
   * @param options notification message string or notification component props object
   * @param target specify a target the component get rendered into - default is `document.body`
   * @returns ProgrammaticExpose
   */
  open(t, l) {
    const a = typeof t == "string" ? { message: t } : t, e = {
      position: nt("notification.position", "top-right"),
      container: document.body,
      ...a
      // pass all props to the internal notification component
    };
    return Rt.open(Hn, {
      registry: Ut,
      // custom programmatic instance registry
      target: l,
      // target the component get rendered into
      props: e,
      // component specific props
      onClose: a.onClose
      // on close event handler
    });
  },
  /** Close the last registred instance in the notification programmatic instance registry. */
  close(...t) {
    var l, a;
    (a = (l = Ut.last()) == null ? void 0 : l.exposed) == null || a.close(...t);
  },
  /** Close all instances in the programmatic notification instance registry. */
  closeAll(...t) {
    Ut.walk((l) => {
      var a;
      return (a = l.exposed) == null ? void 0 : a.close(...t);
    });
  }
}, xn = {
  install(t) {
    Ie(t, rl), $t(
      t,
      "notification",
      Nn
    );
  }
}, It = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OPaginationButton",
  configField: "pagination",
  __name: "PaginationButton",
  props: {
    number: { type: Number, default: void 0 },
    isCurrent: { type: Boolean, default: !1 },
    ariaLabel: { type: String, default: void 0 },
    disabled: { type: Boolean, default: !1 },
    tag: {
      type: [String, Object, Function],
      default: "button"
    },
    rootClass: { type: Array, default: () => [] },
    buttonClass: {
      type: Array,
      required: !0
    },
    buttonCurrentClass: {
      type: Array,
      required: !0
    }
  },
  emits: ["click"],
  setup(t) {
    const l = t, a = o(() => [
      ...l.rootClass,
      ...l.buttonClass,
      ...l.isCurrent ? l.buttonCurrentClass : []
    ]);
    return (e, s) => (p(), se(xe(t.tag), {
      role: "button",
      tabindex: t.disabled ? void 0 : 0,
      disabled: t.disabled,
      class: N(a.value),
      "aria-label": t.ariaLabel,
      "aria-current": t.isCurrent,
      onClick: s[0] || (s[0] = re((d) => e.$emit("click", d), ["prevent"])),
      onKeydown: s[1] || (s[1] = oe(re((d) => e.$emit("click", d), ["prevent"]), ["enter"]))
    }, {
      default: de(() => [
        ae(e.$slots, "default", {}, () => [
          Ve(ce(t.number), 1)
        ])
      ]),
      _: 3
    }, 40, ["tabindex", "disabled", "class", "aria-label", "aria-current"]));
  }
}), ul = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OPagination",
  configField: "pagination",
  inheritAttrs: !1,
  __name: "Pagination",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    total: { default: void 0 },
    perPage: { default: () => n("pagination.perPage", 20) },
    current: { default: 1 },
    rangeBefore: { default: 1 },
    rangeAfter: { default: 1 },
    size: { default: () => n("pagination.size") },
    simple: { type: Boolean, default: () => n("pagination.simple", !1) },
    rounded: { type: Boolean, default: () => n("pagination.rounded", !1) },
    order: { default: () => n("pagination.order", "right") },
    buttonTag: { default: () => n("pagination.buttonTag", "button") },
    iconPack: { default: () => n("pagination.iconPack") },
    iconPrev: { default: () => n("pagination.iconPrev", "chevron-left") },
    iconNext: { default: () => n("pagination.iconNext", "chevron-right") },
    mobileBreakpoint: { default: () => n("pagination.mobileBreakpoint") },
    ariaNextLabel: { default: () => n("pagination.ariaNextLabel", "Next page") },
    ariaPreviousLabel: { default: () => n("pagination.ariaPreviousLabel", "Previous page") },
    ariaPageLabel: { default: () => n("pagination.ariaPageLabel", "Page") },
    ariaCurrentLabel: { default: () => n("pagination.ariaCurrentLabel", "Current page") },
    rootClass: {},
    mobileClass: {},
    orderClass: {},
    sizeClass: {},
    simpleClass: {},
    infoClass: {},
    listClass: {},
    listItemClass: {},
    ellipsisClass: {},
    buttonClass: {},
    roundedClass: {},
    buttonCurrentClass: {},
    buttonPrevClass: {},
    buttonNextClass: {},
    buttonDisabledClass: {}
  }, {
    current: { default: 1 },
    currentModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:current", "change"], ["update:current"]),
  setup(t, { expose: l, emit: a }) {
    const e = t, s = a, { isMobile: d } = rt(e.mobileBreakpoint), g = Pe(t, "current"), u = o(
      () => Math.ceil((e.total || 0) / Number(e.perPage))
    );
    be(
      () => u.value,
      (k) => {
        e.current > k && U(new Event("change"));
      }
    );
    const c = o(() => {
      const k = Number(e.perPage), r = e.current * k - k + 1;
      return r >= 0 ? r : 0;
    }), y = o(() => e.current <= 1), f = o(() => e.current >= e.rangeBefore + 2), v = o(() => e.current >= e.rangeBefore + 4), I = o(() => e.current >= u.value), C = o(
      () => e.current <= u.value - (1 + e.rangeAfter)
    ), B = o(
      () => e.current < u.value - (2 + e.rangeAfter)
    ), P = o(() => {
      if (e.simple) return [];
      let k = Math.max(1, e.current - e.rangeBefore);
      k - 1 === 2 && k--;
      let r = Math.min(e.current + e.rangeAfter, u.value);
      u.value - r === 2 && r++;
      const m = [];
      for (let R = k; R <= r; R++)
        m.push(h(R));
      return m;
    });
    function h(k, r) {
      return {
        number: k,
        isCurrent: e.current === k,
        onClick: (m) => S(k, m),
        ariaLabel: r || z(k, e.current === k),
        tag: e.buttonTag
      };
    }
    function z(k, r) {
      return e.ariaPageLabel && (!r || !e.ariaCurrentLabel) ? e.ariaPageLabel + " " + k + "." : e.ariaPageLabel && r && e.ariaCurrentLabel ? e.ariaCurrentLabel + ", " + e.ariaPageLabel + " " + k + "." : "";
    }
    function F(k) {
      S(e.current - 1, k);
    }
    function O(k) {
      S(e.current + 1, k);
    }
    function K(k) {
      S(1, k);
    }
    function U(k) {
      S(u.value, k);
    }
    function S(k, r) {
      e.current === k || k < 1 || k > u.value || (s("change", k), g.value = k, r && r.target && ze(() => r.target.focus()));
    }
    const T = M(
      ["rootClass", "o-pagination"],
      [
        "orderClass",
        "o-pagination--",
        o(() => e.order),
        o(() => !!e.order)
      ],
      [
        "sizeClass",
        "o-pagination--",
        o(() => e.size),
        o(() => !!e.size)
      ],
      ["simpleClass", "o-pagination--simple", null, o(() => e.simple)],
      ["mobileClass", "o-pagination--mobile", null, d]
    ), w = M(["infoClass", "o-pagination__info"]), V = M([
      "ellipsisClass",
      "o-pagination__ellipsis"
    ]), $ = M(["listClass", "o-pagination__list"]), Y = M(["listItemClass", "o-pagination__item"]), E = M(
      ["buttonClass", "o-pagination__button"],
      [
        "roundedClass",
        "o-pagination__button--rounded",
        null,
        o(() => e.rounded)
      ]
    ), Z = M([
      "buttonCurrentClass",
      "o-pagination__button--current"
    ]), _ = M(
      ["buttonPrevClass", "o-pagination__button-previous"],
      ["buttonDisabledClass", "o-pagination__button--disabled", null, y]
    ), q = M(
      ["buttonNextClass", "o-pagination__button-next"],
      ["buttonDisabledClass", "o-pagination__button--disabled", null, I]
    );
    return l({ last: U, first: K, prev: F, next: O }), (k, r) => (p(), A("nav", {
      "data-oruga": "pagination",
      class: N(i(T))
    }, [
      ae(k.$slots, "previous", Et(Ht(h(g.value - 1, k.ariaPreviousLabel))), () => [
        he(It, fe(h(g.value - 1, k.ariaPreviousLabel), {
          disabled: y.value,
          "root-class": i(_),
          "button-class": i(E),
          "button-current-class": i(Z)
        }), {
          default: de(() => [
            he(Te, {
              icon: k.iconPrev,
              pack: k.iconPack,
              both: "",
              "aria-hidden": "true"
            }, null, 8, ["icon", "pack"])
          ]),
          _: 1
        }, 16, ["disabled", "root-class", "button-class", "button-current-class"])
      ]),
      ae(k.$slots, "next", Et(Ht(h(g.value + 1, k.ariaNextLabel))), () => [
        he(It, fe(h(g.value + 1, k.ariaNextLabel), {
          disabled: I.value,
          "root-class": i(q),
          "button-class": i(E),
          "button-current-class": i(Z)
        }), {
          default: de(() => [
            he(Te, {
              icon: k.iconNext,
              pack: k.iconPack,
              both: "",
              "aria-hidden": "true"
            }, null, 8, ["icon", "pack"])
          ]),
          _: 1
        }, 16, ["disabled", "root-class", "button-class", "button-current-class"])
      ]),
      k.simple ? (p(), A("small", {
        key: 0,
        class: N(i(w))
      }, [
        k.perPage == 1 ? (p(), A(ve, { key: 0 }, [
          Ve(ce(c.value) + " / " + ce(k.total), 1)
        ], 64)) : (p(), A(ve, { key: 1 }, [
          Ve(ce(c.value) + "-" + ce(Math.min(g.value * Number(k.perPage), k.total)) + " / " + ce(k.total), 1)
        ], 64))
      ], 2)) : (p(), A("ul", {
        key: 1,
        class: N(i($))
      }, [
        f.value ? (p(), A("li", {
          key: 0,
          class: N(i(Y))
        }, [
          ae(k.$slots, "default", Et(Ht(h(1))), () => [
            he(It, fe(h(1), {
              "button-class": i(E),
              "button-current-class": i(Z)
            }), null, 16, ["button-class", "button-current-class"])
          ])
        ], 2)) : Q("", !0),
        v.value ? (p(), A("li", {
          key: 1,
          class: N(i(Y))
        }, [
          pe("span", {
            class: N(i(V))
          }, "", 2)
        ], 2)) : Q("", !0),
        (p(!0), A(ve, null, $e(P.value, (m) => (p(), A("li", {
          key: m.number,
          class: N(i(Y))
        }, [
          ae(k.$slots, "default", fe({ ref_for: !0 }, m), () => [
            he(It, fe({ ref_for: !0 }, m, {
              "button-class": i(E),
              "button-current-class": i(Z)
            }), null, 16, ["button-class", "button-current-class"])
          ])
        ], 2))), 128)),
        B.value ? (p(), A("li", {
          key: 2,
          class: N(i(Y))
        }, [
          pe("span", {
            class: N(i(V))
          }, "", 2)
        ], 2)) : Q("", !0),
        C.value ? (p(), A("li", {
          key: 3,
          class: N(i(Y))
        }, [
          ae(k.$slots, "default", Et(Ht(h(u.value))), () => [
            he(It, fe(h(u.value), {
              "button-class": i(E),
              "button-current-class": i(Z)
            }), null, 16, ["button-class", "button-current-class"])
          ])
        ], 2)) : Q("", !0)
      ], 2))
    ], 2));
  }
}), Yn = {
  install(t) {
    Ie(t, ul);
  }
}, Wn = ["id", "name", "value", "required", "disabled", "autocomplete", "aria-checked", "aria-labelledby"], Kn = ["id", "for"], Un = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "ORadio",
  configField: "radio",
  inheritAttrs: !1,
  __name: "Radio",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    variant: { default: () => n("radio.variant") },
    size: { default: () => n("radio.size") },
    label: { default: void 0 },
    nativeValue: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    name: { default: void 0 },
    autocomplete: { default: () => n("radio.autocomplete", "off") },
    id: { default: () => Le() },
    useHtml5Validation: { type: Boolean, default: () => n("useHtml5Validation", !0) },
    customValidity: {},
    rootClass: {},
    sizeClass: {},
    variantClass: {},
    disabledClass: {},
    checkedClass: {},
    inputClass: {},
    labelClass: {}
  }, {
    modelValue: { default: void 0 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:model-value", "input", "focus", "blur", "invalid"], ["update:modelValue"]),
  setup(t, { expose: l, emit: a }) {
    var K, U;
    const e = t, s = a, d = Me("inputElement"), { onBlur: g, onFocus: u, onInvalid: c, setFocus: y } = et(
      d,
      s,
      e
    ), { parentField: f } = Ge(), v = f.value || e.label || vt().default ? ((K = f.value) == null ? void 0 : K.labelId) || Le() : void 0;
    !e.label && e.id && ((U = f.value) == null || U.setInputId(e.id));
    const I = Pe(t, "modelValue"), C = o(() => I.value === e.nativeValue);
    function B(S) {
      s("input", I.value, S);
    }
    const P = it(), h = o(() => {
      var S;
      return {
        ...(S = f == null ? void 0 : f.value) == null ? void 0 : S.inputAttrs,
        ...P
      };
    }), z = M(
      ["rootClass", "o-radio"],
      [
        "sizeClass",
        "o-radio--",
        o(() => e.size),
        o(() => !!e.size)
      ],
      [
        "variantClass",
        "o-radio--",
        o(() => e.variant),
        o(() => !!e.variant)
      ],
      [
        "disabledClass",
        "o-radio--disabled",
        null,
        o(() => e.disabled)
      ],
      ["checkedClass", "o-radio--checked", null, C]
    ), F = M(["inputClass", "o-radio__input"]), O = M(["labelClass", "o-radio__label"]);
    return l({ focus: y, value: I }), (S, T) => (p(), A("div", {
      "data-oruga": "radio",
      class: N(i(z))
    }, [
      Be(pe("input", fe(h.value, {
        id: S.id,
        ref: "inputElement",
        "onUpdate:modelValue": T[0] || (T[0] = (w) => I.value = w),
        type: "radio",
        "data-oruga-input": "radio",
        class: i(F),
        name: S.name,
        value: S.nativeValue,
        required: S.required,
        disabled: S.disabled,
        autocomplete: S.autocomplete,
        "aria-checked": C.value,
        "aria-labelledby": i(v),
        onBlur: T[1] || (T[1] = //@ts-ignore
        (...w) => i(g) && i(g)(...w)),
        onFocus: T[2] || (T[2] = //@ts-ignore
        (...w) => i(u) && i(u)(...w)),
        onInvalid: T[3] || (T[3] = //@ts-ignore
        (...w) => i(c) && i(c)(...w)),
        onChange: B
      }), null, 16, Wn), [
        [Zl, I.value]
      ]),
      S.label || S.$slots.default ? (p(), A("label", {
        key: 0,
        id: i(v),
        for: S.id,
        class: N(i(O))
      }, [
        ae(S.$slots, "default", {}, () => [
          Ve(ce(S.label), 1)
        ])
      ], 10, Kn)) : Q("", !0)
    ], 2));
  }
}), qn = {
  install(t) {
    Ie(t, Un);
  }
}, jn = {
  install(t) {
    Ie(t, ft);
  }
}, Xn = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OSkeleton",
  configField: "skeleton",
  __name: "Skeleton",
  props: {
    override: { type: Boolean, default: void 0 },
    active: { type: Boolean, default: !0 },
    animated: { type: Boolean, default: () => n("skeleton.animated", !0) },
    width: { default: void 0 },
    height: { default: void 0 },
    circle: { type: Boolean, default: !1 },
    rounded: { type: Boolean, default: () => n("skeleton.rounded", !0) },
    count: { default: 1 },
    size: { default: void 0 },
    position: { default: "left" },
    rootClass: {},
    positionClass: {},
    itemClass: {},
    roundedClass: {},
    animatedClass: {},
    sizeClass: {}
  },
  setup(t) {
    const l = t, a = o(() => ({
      height: wt(l.height),
      width: wt(l.width),
      borderRadius: l.circle ? "50%" : void 0
    })), e = M(
      ["rootClass", "o-skeleton"],
      [
        "positionClass",
        "o-skeleton--",
        o(() => l.position),
        o(() => !!l.position)
      ]
    ), s = M(
      ["itemClass", "o-skeleton__item"],
      [
        "roundedClass",
        "o-skeleton__item--rounded",
        null,
        o(() => l.rounded)
      ],
      [
        "animatedClass",
        "o-skeleton__item--animated",
        null,
        o(() => l.animated)
      ],
      [
        "sizeClass",
        "o-skeleton__item--",
        o(() => l.size),
        o(() => !!l.size)
      ]
    );
    return (d, g) => d.active ? (p(), A("div", {
      key: 0,
      "data-oruga": "skeleton",
      class: N(i(e))
    }, [
      (p(!0), A(ve, null, $e(d.count, (u) => (p(), A("div", {
        key: u,
        class: N(i(s)),
        style: Xe(a.value)
      }, null, 6))), 128))
    ], 2)) : Q("", !0);
  }
}), Gn = {
  install(t) {
    Ie(t, Xn);
  }
}, dl = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OSidebar",
  configField: "sidebar",
  inheritAttrs: !1,
  __name: "Sidebar",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    active: { type: Boolean, default: !1 },
    overlay: { type: Boolean, default: () => n("sidebar.overlay", !1) },
    inline: { type: Boolean, default: !1 },
    position: { default: () => n("sidebar.position", "left") },
    fullheight: { type: Boolean, default: () => n("sidebar.fullheight", !1) },
    fullwidth: { type: Boolean, default: () => n("sidebar.fullwidth", !1) },
    reduce: { type: Boolean, default: () => n("sidebar.reduce", !1) },
    mobile: { default: () => n("sidebar.mobile") },
    expandOnHover: { type: Boolean, default: () => n("sidebar.expandOnHover", !1) },
    animation: { default: () => n("sidebar.animation") },
    cancelable: { type: [Array, Boolean], default: () => n("sidebar.cancelable", ["escape", "outside"]) },
    clipScroll: { type: Boolean, default: () => n("sidebar.clipScroll", !1) },
    trapFocus: { type: Boolean, default: () => n("sidebar.trapFocus", !0) },
    mobileBreakpoint: { default: () => n("sidebar.mobileBreakpoint") },
    teleport: { type: [Boolean, String, Object], default: () => n("sidebar.teleport", !1) },
    container: {},
    component: { default: void 0 },
    props: { default: void 0 },
    events: { default: void 0 },
    rootClass: {},
    mobileClass: {},
    activeClass: {},
    teleportClass: {},
    inlineClass: {},
    overlayClass: {},
    contentClass: {},
    hiddenClass: {},
    visibleClass: {},
    positionClass: {},
    fullheightClass: {},
    fullwidthClass: {},
    reduceClass: {},
    expandOnHoverClass: {},
    scrollClipClass: {},
    scrollKeepClass: {}
  }, {
    active: { type: Boolean, default: !1 },
    activeModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:active", "close"], ["update:active"]),
  setup(t, { expose: l, emit: a }) {
    const e = t, s = a, { vTrapFocus: d } = el(), g = Me("rootElement"), u = Me("contentElement"), c = Pe(t, "active"), { isMobile: y } = rt(e.mobileBreakpoint), f = o(
      () => typeof e.teleport == "boolean" ? { to: la(), disabled: !e.teleport } : { to: e.teleport, disabled: !1 }
    ), v = o(() => {
      if (e.animation) return e.animation;
      const w = e.position === "top" || e.position === "bottom";
      return (e.position === "right" ? !c.value : c.value) ? w ? "slide-down" : "slide-next" : w ? "slide-up" : "slide-prev";
    }), I = o(
      () => e.mobile === "hidden" && y.value
    ), C = aa(e.clipScroll);
    be(
      c,
      (w) => {
        e.overlay && C(w);
      },
      { flush: "post" }
    ), st(() => {
      c.value && e.overlay && C(!0);
    }), Ee && (mt(g, "keyup", B, { trigger: c }), e.overlay || ta(u, P, { trigger: c }));
    function B(w) {
      c.value && (w.key === "Escape" || w.key === "Esc") && h("escape");
    }
    function P(w) {
      e.inline || !c.value || F.value || ((e.overlay || u.value && !w.composedPath().includes(u.value)) && w.preventDefault(), h("outside"));
    }
    function h(w) {
      typeof e.cancelable == "boolean" && !e.cancelable || !e.cancelable || Array.isArray(e.cancelable) && !e.cancelable.includes(w) || z({ action: "cancel", method: w });
    }
    function z(...w) {
      c.value = !1, s("close", w);
    }
    const F = ne(!e.active);
    function O() {
      F.value = !1;
    }
    function K() {
      F.value = !0;
    }
    const U = M(
      ["rootClass", "o-sidebar"],
      ["mobileClass", "o-sidebar--mobile", null, y],
      ["activeClass", "o-sidebar--active", null, c],
      [
        "teleportClass",
        "o-sidebar--teleport",
        null,
        o(() => !!e.teleport)
      ],
      ["inlineClass", "o-sidebar--inline", null, o(() => e.inline)]
    ), S = M(["overlayClass", "o-sidebar__overlay"]), T = M(
      ["contentClass", "o-sidebar__content"],
      [
        "positionClass",
        "o-sidebar__content--",
        o(() => e.position),
        o(() => !!e.position)
      ],
      [
        "fullheightClass",
        "o-sidebar__content--fullheight",
        null,
        o(() => e.fullheight)
      ],
      [
        "fullwidthClass",
        "o-sidebar__content--fullwidth",
        null,
        o(
          () => e.fullwidth || y.value && e.mobile === "expanded"
        )
      ],
      [
        "reduceClass",
        "o-sidebar__content--reduced",
        null,
        o(
          () => e.reduce || y.value && e.mobile === "reduced"
        )
      ],
      [
        "expandOnHoverClass",
        "o-sidebar__content--hover-expand",
        null,
        o(
          () => e.expandOnHover && (!y.value || e.mobile !== "expanded")
        )
      ],
      ["visibleClass", "o-sidebar__content--visible", null, c],
      [
        "hiddenClass",
        "o-sidebar__content--hidden",
        null,
        o(() => !c.value)
      ]
    );
    return l({ close: z }), (w, V) => (p(), se(ga, {
      to: f.value.to,
      disabled: f.value.disabled
    }, [
      Be((p(), A("div", fe({ ref: "rootElement" }, w.$attrs, {
        "data-oruga": "sidebar",
        class: i(U)
      }), [
        w.overlay && c.value ? (p(), A("div", {
          key: 0,
          class: N(i(S)),
          tabindex: -1,
          onClick: P
        }, null, 2)) : Q("", !0),
        he(Je, {
          name: v.value,
          onAfterEnter: O,
          onBeforeLeave: K
        }, {
          default: de(() => [
            Be(pe("div", {
              ref: "contentElement",
              class: N(i(T))
            }, [
              ae(w.$slots, "default", { close: z }, () => [
                w.component ? (p(), se(xe(w.component), fe({ key: 0 }, w.$props.props, At(w.$props.events || {}), { onClose: z }), null, 16)) : Q("", !0)
              ])
            ], 2), [
              [Oe, c.value]
            ])
          ]),
          _: 3
        }, 8, ["name"])
      ], 16)), [
        [Oe, !I.value],
        [i(d), c.value && !w.inline && w.trapFocus]
      ])
    ], 8, ["to", "disabled"]));
  }
}), qt = new Tt(), Qn = {
  /** Returns the number of registered active instances. */
  count: qt.count,
  /**
   * Create a new programmatic sidebar component instance.
   * @param options sidebar component props object
   * @param target specify a target the component get rendered into - default is `document.body`
   * @returns ProgrammaticExpose
   */
  open(t, l) {
    const a = {
      active: !0,
      // set the active default state to true
      ...t
    };
    return Rt.open(dl, {
      registry: qt,
      // custom programmatic instance registry
      target: l,
      // target the component get rendered into
      props: a,
      // component specific props
      onClose: t.onClose
      // on close event handler
    });
  },
  /** Close the last registred instance in the sidebar programmatic instance registry. */
  close(...t) {
    var l, a;
    (a = (l = qt.last()) == null ? void 0 : l.exposed) == null || a.close(...t);
  },
  /** Close all instances in the programmatic sidebar instance registry. */
  closeAll(...t) {
    qt.walk((l) => {
      var a;
      return (a = l.exposed) == null ? void 0 : a.close(...t);
    });
  }
}, Jn = {
  install(t) {
    Ie(t, dl), $t(t, "sidebar", Qn);
  }
}, Zn = ["id"], cl = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OTooltip",
  configField: "tooltip",
  __name: "Tooltip",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    active: { type: Boolean, default: !1 },
    label: { default: void 0 },
    variant: { default: () => n("tooltip.variant") },
    position: { default: () => n("tooltip.position", "auto") },
    always: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    animation: { default: () => n("tooltip.animation", "fade") },
    multiline: { type: Boolean, default: !1 },
    triggerTag: { default: () => n("tooltip.triggerTag", "div") },
    triggers: { default: () => n("tooltip.triggers", ["hover", "focus"]) },
    delay: { default: void 0 },
    closeable: { type: [Array, Boolean], default: () => n("tooltip.closeable", ["escape", "outside", "content"]) },
    teleport: { type: [Boolean, String, Object], default: () => n("dropdown.teleport", !1) },
    rootClass: {},
    teleportClass: {},
    triggerClass: {},
    contentClass: {},
    positionClass: {},
    variantClass: {},
    multilineClass: {},
    alwaysClass: {},
    arrowClass: {},
    arrowPositionClass: {},
    arrowVariantClass: {}
  }, {
    active: { type: Boolean, default: !1 },
    activeModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:active", "close", "open"], ["update:active"]),
  setup(t, { emit: l }) {
    const a = t, e = l, s = Pe(t, "active");
    be(s, (T) => {
      e(T ? "open" : "close");
    });
    const d = Le(), g = ne(), u = ne(a.position);
    be(
      () => a.position,
      (T) => u.value = T
    );
    const c = ne(), y = ne(), f = o(
      () => typeof a.closeable == "boolean" ? a.closeable ? ["escape", "outside", "content"] : [] : a.closeable
    );
    Ee && f.value.includes("outside") && ta([c, y], v, {
      trigger: s,
      passive: !0
    });
    function v() {
      !s.value || a.always || f.value.includes("outside") && (s.value = !1);
    }
    function I() {
      s.value && f.value.includes("escape") && (s.value = !1);
    }
    function C() {
      a.triggers.includes("click") && ze(() => setTimeout(() => z()));
    }
    function B(T) {
      a.triggers.includes("contextmenu") && (T.preventDefault(), z());
    }
    function P() {
      a.triggers.includes("focus") && z();
    }
    function h() {
      a.triggers.includes("hover") && z();
    }
    function z() {
      a.disabled || (a.delay ? g.value = setTimeout(() => {
        s.value = !0, g.value = null;
      }, a.delay) : s.value = !0);
    }
    function F() {
      f.value.includes("content") && (s.value = !a.closeable, g.value && a.closeable && clearTimeout(g.value));
    }
    const O = M(
      ["rootClass", "o-tooltip"],
      [
        "teleportClass",
        "o-tooltip--teleport",
        null,
        o(() => !!a.teleport)
      ]
    ), K = M(["triggerClass", "o-tooltip__trigger"]), U = M(
      ["contentClass", "o-tooltip__content"],
      [
        "positionClass",
        "o-tooltip__content--",
        u,
        o(() => !!u.value)
      ],
      [
        "variantClass",
        "o-tooltip__content--",
        o(() => a.variant),
        o(() => !!a.variant)
      ],
      [
        "multilineClass",
        "o-tooltip__content--multiline",
        null,
        o(() => a.multiline)
      ],
      [
        "alwaysClass",
        "o-tooltip__content--always",
        null,
        o(() => a.always)
      ]
    ), S = M(
      ["arrowClass", "o-tooltip__arrow"],
      [
        "arrowPositionClass",
        "o-tooltip__arrow--",
        u,
        o(() => !!u.value)
      ],
      [
        "arrowVariantClass",
        "o-tooltip__arrow--",
        o(() => a.variant),
        o(() => !!a.variant)
      ]
    );
    return (T, w) => (p(), A("div", {
      "data-oruga": "tooltip",
      class: N(i(O))
    }, [
      (p(), se(xe(T.triggerTag), {
        ref_key: "triggerRef",
        ref: y,
        class: N(i(K)),
        "aria-haspopup": "true",
        "aria-describedby": i(d),
        onKeydown: oe(I, ["escape"]),
        onClick: C,
        onContextmenu: B,
        onMouseenter: h,
        onFocusCapture: P,
        onBlurCapture: F,
        onMouseleave: F
      }, {
        default: de(() => [
          ae(T.$slots, "default", { active: s.value })
        ]),
        _: 3
      }, 40, ["class", "aria-describedby"])),
      he(tl, {
        position: u.value,
        "onUpdate:position": w[0] || (w[0] = (V) => u.value = V),
        teleport: T.teleport,
        class: N(i(O)),
        trigger: y.value,
        "default-position": "top",
        disabled: !s.value
      }, {
        default: de(({ setContent: V }) => [
          he(Je, { name: T.animation }, {
            default: de(() => [
              Be(pe("div", {
                id: i(d),
                ref: ($) => c.value = V($),
                class: N(i(U)),
                role: "tooltip"
              }, [
                pe("span", {
                  class: N(i(S))
                }, null, 2),
                ae(T.$slots, "content", {}, () => [
                  Ve(ce(T.label), 1)
                ])
              ], 10, Zn), [
                [Oe, s.value || T.always && !T.disabled]
              ])
            ]),
            _: 2
          }, 1032, ["name"])
        ]),
        _: 3
      }, 8, ["position", "teleport", "class", "trigger", "disabled"])
    ], 2));
  }
}), _n = ["tabindex", "aria-label", "aria-labelledby", "aria-valuenow", "aria-valuemin", "aria-valuemax", "aria-disabled", "onKeydown"], es = { key: 0 }, Ra = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OSliderThumb",
  configField: "slider",
  inheritAttrs: !1,
  __name: "SliderThumb",
  props: {
    sliderProps: {},
    modelValue: {},
    sliderSize: { type: Function },
    thumbWrapperClasses: {},
    thumbClasses: {}
  },
  emits: ["update:model-value", "change", "dragstart", "dragend"],
  setup(t, { expose: l, emit: a }) {
    const e = t, s = a, { parentField: d } = Ge(), g = ne(!1), u = ne(!1), c = ne(0), y = ne(0), f = ne(), v = ne(e.modelValue), I = o(() => e.sliderProps.tooltip), C = o(() => e.sliderProps.tooltipAlways), B = o(() => e.sliderProps.disabled), P = o(() => e.sliderProps.max), h = o(() => e.sliderProps.min), z = o(() => e.sliderProps.step), F = o(() => e.sliderProps.indicator), O = o(() => e.sliderProps.ariaLabel), K = o(() => {
      const L = [h.value, P.value, z.value].map((te) => {
        const W = ("" + te).split(".")[1];
        return W ? W.length : 0;
      });
      return Math.max(...L);
    }), U = o(
      () => e.sliderProps.tooltipVariant ? e.sliderProps.tooltipVariant : e.sliderProps.variant
    ), S = o(
      () => `${(e.modelValue - h.value) / (P.value - h.value) * 100}%`
    ), T = o(() => ({ left: S.value })), w = o(() => typeof e.sliderProps.formatter < "u" ? e.sliderProps.formatter(e.modelValue) : e.sliderProps.format === "percent" ? new Intl.NumberFormat(e.sliderProps.locale, {
      style: "percent"
    }).format((e.modelValue - h.value) / (P.value - h.value)) : new Intl.NumberFormat(e.sliderProps.locale).format(
      e.modelValue
    ));
    function V() {
      g.value = !0;
    }
    function $() {
      g.value = !1;
    }
    function Y(L) {
      B.value || (L.preventDefault(), k(L), Ee && (document.addEventListener("mousemove", r), document.addEventListener("touchmove", r), document.addEventListener("mouseup", m), document.addEventListener("touchend", m), document.addEventListener("contextmenu", m)));
    }
    function E() {
      B.value || e.modelValue === h.value || (f.value = parseFloat(S.value) - z.value / (P.value - h.value) * 100, R(f.value), s("change"));
    }
    function Z() {
      B.value || e.modelValue === P.value || (f.value = parseFloat(S.value) + z.value / (P.value - h.value) * 100, R(f.value), s("change"));
    }
    function _() {
      B.value || e.modelValue === h.value || (f.value = 0, R(f.value), s("change"));
    }
    function q() {
      B.value || e.modelValue === P.value || (f.value = 100, R(f.value), s("change"));
    }
    function k(L) {
      u.value = !0, s("dragstart"), L.type === "touchstart" && (L.clientX = L.touches[0].clientX), c.value = L.clientX, y.value = parseFloat(S.value), f.value = y.value;
    }
    function r(L) {
      if (u.value) {
        L.type === "touchmove" && (L.clientX = L.touches[0].clientX);
        const te = (L.clientX - c.value) / e.sliderSize() * 100;
        f.value = y.value + te, R(f.value);
      }
    }
    function m() {
      u.value = !1, s("dragend"), e.modelValue !== v.value && s("change"), R(f.value), Ee && (document.removeEventListener("mousemove", r), document.removeEventListener("touchmove", r), document.removeEventListener("mouseup", m), document.removeEventListener("touchend", m), document.removeEventListener("contextmenu", m));
    }
    function R(L) {
      if (L === void 0 || isNaN(L)) return;
      L < 0 ? L = 0 : L > 100 && (L = 100);
      const te = 100 / ((P.value - h.value) / z.value);
      let H = Math.round(L / te) * te / 100 * (P.value - h.value) + h.value;
      H = parseFloat(H.toFixed(K.value)), s("update:model-value", H), !u.value && H !== v.value && (v.value = H);
    }
    return l({ setPosition: R }), (L, te) => (p(), A("div", {
      "data-oruga": "slider-thumb",
      class: N(L.thumbWrapperClasses),
      style: Xe(T.value)
    }, [
      he(cl, {
        label: w.value,
        variant: U.value,
        disabled: B.value || !I.value,
        always: C.value || u.value || g.value
      }, {
        default: de(() => {
          var W;
          return [
            pe("div", fe(L.$attrs, {
              class: L.thumbClasses,
              tabindex: B.value ? void 0 : 0,
              role: "slider",
              "aria-label": O.value,
              "aria-labelledby": (W = i(d)) == null ? void 0 : W.labelId,
              "aria-valuenow": L.modelValue,
              "aria-valuemin": h.value,
              "aria-valuemax": P.value,
              "aria-disabled": B.value,
              "aria-orientation": "horizontal",
              onMousedown: Y,
              onTouchstartPassive: Y,
              onFocus: V,
              onBlur: $,
              onKeydown: [
                oe(re(E, ["prevent"]), ["left"]),
                oe(re(Z, ["prevent"]), ["right"]),
                oe(re(E, ["prevent"]), ["down"]),
                oe(re(Z, ["prevent"]), ["up"]),
                oe(re(_, ["prevent"]), ["home"]),
                oe(re(q, ["prevent"]), ["end"])
              ]
            }), [
              F.value ? (p(), A("span", es, ce(w.value), 1)) : Q("", !0)
            ], 16, _n)
          ];
        }),
        _: 1
      }, 8, ["label", "variant", "disabled", "always"])
    ], 6));
  }
}), fl = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OSliderTick",
  configField: "slider",
  __name: "SliderTick",
  props: {
    /** Override existing theme classes completely */
    override: { type: Boolean, default: void 0 },
    /** Value of single tick */
    value: { type: Number, required: !0 },
    /** Tick label */
    label: { type: [String, Number], default: void 0 },
    tickClass: {
      type: [String, Function, Array],
      default: void 0
    },
    /** Class when slider tick is hidden */
    tickHiddenClass: {
      type: [String, Function, Array],
      default: void 0
    },
    /** Class of tick label */
    tickLabelClass: {
      type: [String, Function, Array],
      default: void 0
    }
  },
  setup(t) {
    const l = t, { parent: a } = pt({ register: !1 }), e = o(() => {
      const c = (l.value - a.value.min) / (a.value.max - a.value.min) * 100;
      return c >= 0 && c <= 100 ? c : 0;
    }), s = o(
      () => l.value === a.value.min || l.value === a.value.max
    ), d = o(() => ({ left: e.value + "%" })), g = M(
      ["tickClass", "o-slider__tick"],
      ["tickHiddenClass", "o-slider__tick--hidden", null, s]
    ), u = M([
      "tickLabelClass",
      "o-slider__tick-label"
    ]);
    return (c, y) => (p(), A("div", {
      "data-oruga": "slider-tick",
      class: N(i(g)),
      style: Xe(d.value)
    }, [
      c.$slots.default || t.label ? (p(), A("span", {
        key: 0,
        class: N(i(u))
      }, [
        ae(c.$slots, "default", {}, () => [
          Ve(ce(t.label), 1)
        ])
      ], 2)) : Q("", !0)
    ], 6));
  }
}), ts = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OSlider",
  configField: "slider",
  __name: "Slider",
  props: {
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    range: {},
    min: { default: 0 },
    max: { default: 100 },
    step: { default: 1 },
    variant: { default: () => n("slider.variant") },
    size: { default: () => n("slider.size") },
    ticks: { type: Boolean, default: !1 },
    tooltip: { type: Boolean, default: () => n("slider.tooltip", !0) },
    tooltipVariant: { default: () => n("slider.tooltipVariant") },
    tooltipAlways: { type: Boolean, default: !1 },
    rounded: { type: Boolean, default: () => n("slider.rounded", !1) },
    disabled: { type: Boolean, default: !1 },
    lazy: { type: Boolean, default: !1 },
    formatter: { type: Function, default: void 0 },
    biggerSliderFocus: { type: Boolean, default: !1 },
    indicator: { type: Boolean, default: !1 },
    format: { default: () => n("slider.format", "raw") },
    locale: { default: () => n("locale") },
    ariaLabel: { default: () => n("slider.ariaLabel") },
    rootClass: {},
    sizeClass: {},
    disabledClass: {},
    trackClass: {},
    fillClass: {},
    variantClass: {},
    thumbWrapperClass: {},
    thumbWrapperDraggingClass: {},
    thumbClass: {},
    thumbRoundedClass: {},
    thumbDraggingClass: {},
    tickClass: {},
    tickHiddenClass: {},
    tickLabelClass: {}
  },
  emits: ["update:model-value", "change", "dragging", "dragstart", "dragend"],
  setup(t, { expose: l, emit: a }) {
    const e = t, s = a, d = Me("sliderElement"), g = Me("thumbStartComponent"), u = Me("thumbEndComponent"), c = o(() => ({
      max: e.max,
      min: e.min
    }));
    bt({ data: c });
    const y = ne(0), f = ne(0), v = ne(!1), I = ne(), C = ne(), B = o(
      () => Math.min(y.value || e.min, f.value || e.max)
    ), P = o(
      () => Math.max(y.value || e.min, f.value || e.max)
    ), h = o(() => we(e.range)), z = o(
      () => h.value ? [B.value, P.value] : y.value || 0
    );
    be([y, f], () => {
      h.value && (I.value = y.value && f.value ? y.value > f.value : !1), (!e.lazy || !v.value) && s("update:model-value", z.value), v.value && s("dragging", z.value);
    }), be(
      [() => e.min, () => e.max, () => e.modelValue],
      () => F(e.modelValue),
      { immediate: !0 }
      // initialise valueStart and valueEnd
    );
    function F(k) {
      if (!(e.min > e.max))
        if (Array.isArray(k)) {
          const r = typeof k[0] != "number" || isNaN(k[0]) ? e.min : Math.min(Math.max(e.min, k[0]), e.max), m = typeof k[1] != "number" || isNaN(k[1]) ? e.max : Math.max(Math.min(e.max, k[1]), e.min);
          y.value = I.value ? m : r, f.value = I.value ? r : m;
        } else k !== void 0 ? (y.value = isNaN(k) ? e.min : Math.min(e.max, Math.max(e.min, k)), f.value = 0) : (y.value = e.min, f.value = e.min);
    }
    const O = o(() => {
      if (!e.ticks || e.min > e.max || e.step === 0) return [];
      const k = [];
      for (let r = e.min + e.step; r < e.max; r = r + e.step)
        k.push(r);
      return k;
    }), K = o(
      () => h.value ? `${100 * (P.value - B.value) / (e.max - e.min)}%` : `${100 * (y.value - e.min) / (e.max - e.min)}%`
    ), U = o(
      () => h.value ? `${100 * (B.value - e.min) / (e.max - e.min)}%` : "0%"
    ), S = o(() => ({
      width: K.value,
      left: U.value
    }));
    function T() {
      var k;
      return ((k = d.value) == null ? void 0 : k.getBoundingClientRect().width) || 0;
    }
    function w(k) {
      if (e.disabled || C.value || !d.value || !g.value || h.value && !u.value)
        return;
      const r = d.value.getBoundingClientRect().left, m = (k.clientX - r) / T() * 100, R = e.min + m * (e.max - e.min) / 100, L = Math.abs(R - y.value);
      if (h.value) {
        const te = Math.abs(R - f.value);
        if (L <= te) {
          if (L < e.step / 2) return;
          g.value.setPosition(m);
        } else {
          if (te < e.step / 2) return;
          h.value && u.value && u.value.setPosition(m);
        }
      } else {
        if (L < e.step / 2) return;
        g.value.setPosition(m);
      }
      s("change", z.value);
    }
    function V() {
      v.value = !0, s("dragstart");
    }
    function $() {
      C.value = !0, setTimeout(() => C.value = !1), v.value = !1, s("dragend"), e.lazy && s("update:model-value", z.value);
    }
    const Y = M(
      ["rootClass", "o-slider"],
      [
        "sizeClass",
        "o-slider--",
        o(() => e.size),
        o(() => !!e.size)
      ],
      [
        "disabledClass",
        "o-slider--disabled",
        null,
        o(() => e.disabled)
      ]
    ), E = M(["trackClass", "o-slider__track"]), Z = M(
      ["fillClass", "o-slider__fill"],
      [
        "variantClass",
        "o-slider__fill--",
        o(() => e.variant),
        o(() => !!e.variant)
      ]
    ), _ = M(
      ["thumbWrapperClass", "o-slider__thumb-wrapper"],
      [
        "thumbWrapperDraggingClass",
        "o-slider__thumb-wrapper--dragging",
        null,
        v
      ]
    ), q = M(
      ["thumbClass", "o-slider__thumb"],
      ["thumbDraggingClass", "o-slider__thumb--dragging", null, v],
      [
        "thumbRoundedClass",
        "o-slider__thumb--rounded",
        null,
        o(() => e.rounded)
      ]
    );
    return l({ value: z }), (k, r) => (p(), A("div", {
      "data-oruga": "slider",
      class: N(i(Y)),
      onClick: w
    }, [
      pe("div", {
        ref: "sliderElement",
        class: N(i(E))
      }, [
        pe("div", {
          class: N(i(Z)),
          style: Xe(S.value)
        }, null, 6),
        k.ticks ? (p(!0), A(ve, { key: 0 }, $e(O.value, (m, R) => (p(), se(fl, {
          key: R,
          value: m,
          "tick-class": k.tickClass,
          "tick-hidden-class": k.tickHiddenClass,
          "tick-label-class": k.tickLabelClass
        }, null, 8, ["value", "tick-class", "tick-hidden-class", "tick-label-class"]))), 128)) : Q("", !0),
        ae(k.$slots, "default"),
        he(Ra, {
          ref: "thumbStartComponent",
          modelValue: y.value,
          "onUpdate:modelValue": r[0] || (r[0] = (m) => y.value = m),
          "slider-props": e,
          "slider-size": T,
          "thumb-classes": i(q),
          "thumb-wrapper-classes": i(_),
          onChange: r[1] || (r[1] = (m) => s("change", z.value)),
          onDragstart: V,
          onDragend: $
        }, null, 8, ["modelValue", "thumb-classes", "thumb-wrapper-classes"]),
        h.value ? (p(), se(Ra, {
          key: 1,
          ref: "thumbEndComponent",
          modelValue: f.value,
          "onUpdate:modelValue": r[2] || (r[2] = (m) => f.value = m),
          "slider-props": e,
          "slider-size": T,
          "thumb-classes": i(q),
          "thumb-wrapper-classes": i(_),
          onChange: r[3] || (r[3] = (m) => s("change", z.value)),
          onDragstart: V,
          onDragend: $
        }, null, 8, ["modelValue", "thumb-classes", "thumb-wrapper-classes"])) : Q("", !0)
      ], 2)
    ], 2));
  }
}), as = {
  install(t) {
    Ie(t, ts), Ie(t, fl);
  }
}, ls = ["id", "data-id", "hidden", "aria-labelledby"], pl = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OStepItem",
  configField: "steps",
  inheritAttrs: !1,
  __name: "StepItem",
  props: {
    override: { type: Boolean, default: void 0 },
    value: { default: void 0 },
    label: { default: void 0 },
    step: { default: void 0 },
    variant: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    clickable: { type: Boolean, default: void 0 },
    visible: { type: Boolean, default: !0 },
    icon: { default: () => n("steps.icon") },
    iconPack: { default: () => n("steps.iconPack") },
    content: { default: void 0 },
    component: { default: void 0 },
    props: { default: void 0 },
    events: { default: void 0 },
    stepClass: {},
    stepActiveClass: {},
    stepVariantClass: {},
    stepPositionClass: {},
    stepClickableClass: {},
    stepDisabledClass: {},
    stepPreviousClass: {},
    stepNextClass: {},
    stepLabelClass: {},
    stepIconClass: {},
    stepPanelClass: {}
  },
  emits: ["activate", "deactivate"],
  setup(t, { emit: l }) {
    const a = t, e = l, s = a.value ?? Le(), d = vt(), g = o(() => ({
      ...a,
      value: s,
      $slots: d,
      stepClasses: O.value,
      iconClasses: U.value,
      labelClasses: K.value,
      isClickable: B.value,
      isTransitioning: v.value,
      activate: P,
      deactivate: h
    })), { parent: u, item: c } = pt(
      { data: g }
    ), y = ne(), f = o(() => c.value.index === u.value.activeIndex), v = ne(!1), I = o(() => {
      const T = u.value.vertical && u.value.animation.length === 4 ? 2 : 0;
      return u.value.animation[T];
    }), C = o(() => {
      const T = u.value.vertical && u.value.animation.length === 4 ? 3 : 1;
      return u.value.animation[T];
    }), B = o(
      () => a.clickable || c.value.index < u.value.activeIndex
    );
    function P(T) {
      y.value = c.value.index < T ? I.value : C.value, e("activate");
    }
    function h(T) {
      y.value = T < c.value.index ? I.value : C.value, e("deactivate");
    }
    function z() {
      v.value = !0;
    }
    function F() {
      v.value = !0;
    }
    const O = M(
      ["stepClass", "o-steps__step"],
      [
        "stepVariantClass",
        "o-steps__step--",
        o(() => {
          var T;
          return ((T = u.value) == null ? void 0 : T.variant) || a.variant;
        }),
        o(() => {
          var T;
          return !!((T = u.value) != null && T.variant) || !!a.variant;
        })
      ],
      ["stepActiveClass", "o-steps__step--active", null, f],
      ["stepClickableClass", "o-steps__step--clickable", null, B],
      [
        "stepDisabledClass",
        "o-steps__step--disabled",
        null,
        o(() => a.disabled)
      ],
      [
        "stepPreviousClass",
        "o-steps__step--previous",
        null,
        o(() => {
          var T;
          return c.value.index < ((T = u.value) == null ? void 0 : T.activeIndex);
        })
      ],
      [
        "stepNextClass",
        "o-steps__step--next",
        null,
        o(() => {
          var T;
          return c.value.index > ((T = u.value) == null ? void 0 : T.activeIndex);
        })
      ],
      [
        "stepPositionClass",
        "o-steps__step--",
        o(() => {
          var T;
          return (T = u.value) == null ? void 0 : T.labelPosition;
        }),
        o(() => {
          var T;
          return !!((T = u.value) != null && T.labelPosition);
        })
      ]
    ), K = M([
      "stepLabelClass",
      "o-steps__step-label"
    ]), U = M(["stepIconClass", "o-steps__step-icon"]), S = M(["stepPanelClass", "o-steps__panel"]);
    return (T, w) => i(u) ? (p(), se(Je, {
      key: 0,
      css: i(u).animated,
      name: y.value,
      appear: i(u).animateInitially,
      onAfterEnter: z,
      onBeforeLeave: F
    }, {
      default: de(() => [
        Be(pe("div", fe(T.$attrs, {
          id: `tabpanel-${i(c).identifier}`,
          "data-oruga": "steps-item",
          "data-id": `steps-${i(c).identifier}`,
          class: i(S),
          role: "tabpanel",
          hidden: !f.value,
          "aria-labelledby": `tab-${i(c).identifier}`,
          "aria-roledescription": "item"
        }), [
          ae(T.$slots, "default", {
            active: f.value && T.visible
          }, () => [
            T.component ? (p(), se(xe(T.component), fe({ key: 0 }, T.$props.props, At(T.$props.events || {})), null, 16)) : (p(), A(ve, { key: 1 }, [
              Ve(ce(T.content), 1)
            ], 64))
          ])
        ], 16, ls), [
          [Oe, f.value && T.visible]
        ])
      ]),
      _: 3
    }, 8, ["css", "name", "appear"])) : Q("", !0);
  }
}), os = ["aria-label", "aria-orientation"], ns = ["id", "tabindex", "aria-current", "aria-controls", "aria-selected", "onClick", "onKeydown"], ss = { key: 1 }, is = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OSteps",
  configField: "steps",
  __name: "Steps",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    options: { default: void 0 },
    variant: { default: () => n("steps.variant") },
    size: { default: () => n("steps.size") },
    vertical: { type: Boolean, default: !1 },
    position: { default: void 0 },
    iconPack: { default: () => n("steps.iconPack") },
    iconPrev: { default: () => n("steps.iconPrev", "chevron-left") },
    iconNext: { default: () => n("steps.iconNext", "chevron-right") },
    hasNavigation: { type: Boolean, default: !0 },
    activateOnFocus: { type: Boolean, default: !1 },
    animated: { type: Boolean, default: () => n("steps.animated", !0) },
    animation: { default: () => n("steps.animation", [
      "slide-next",
      "slide-prev",
      "slide-down",
      "slide-up"
    ]) },
    animateInitially: { type: Boolean, default: () => n("steps.animateInitially", !1) },
    labelPosition: { default: () => n("steps.labelPosition", "bottom") },
    rounded: { type: Boolean, default: !0 },
    mobileBreakpoint: { default: () => n("steps.mobileBreakpoint") },
    ariaLabel: { default: () => n("steps.ariaLabel") },
    ariaNextLabel: { default: () => n("steps.ariaNextLabel", "Next") },
    ariaPreviousLabel: { default: () => n("steps.ariaPreviousLabel", "Previous") },
    rootClass: {},
    mobileClass: {},
    sizeClass: {},
    variantClass: {},
    verticalClass: {},
    positionClass: {},
    listClass: {},
    animatedClass: {},
    dividerClass: {},
    markerClass: {},
    markerRoundedClass: {},
    contentClass: {},
    transitioningClass: {},
    navigationClass: {}
  }, {
    modelValue: { default: void 0 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:model-value", "change"], ["update:modelValue"]),
  setup(t, { emit: l }) {
    const a = t, e = l, { isMobile: s } = rt(a.mobileBreakpoint), d = Me("rootElement"), g = o(() => {
      var q;
      return {
        activeIndex: ((q = I.value) == null ? void 0 : q.index) ?? 0,
        labelPosition: a.labelPosition,
        vertical: a.vertical,
        animated: a.animated,
        animation: a.animation,
        animateInitially: a.animateInitially,
        variant: a.variant
      };
    }), { childItems: u } = bt({
      rootRef: d,
      data: g
    }), c = o(() => u.value ? u.value.map((q) => ({
      index: q.index,
      identifier: q.identifier,
      ...Ae(q.data)
    })) : []), { nextSequence: y } = ut(), f = o(
      () => dt(a.options, y)
    ), v = Pe(t, "modelValue");
    be(
      () => a.modelValue,
      (q) => {
        v.value !== q && w(q);
      }
    );
    const I = ne();
    Ot(() => {
      I.value = ke(v.value) && c.value.find((q) => q.value === v.value) || c.value[0];
    });
    const C = o(
      () => c.value.some((q) => q.isTransitioning)
    );
    function B(q) {
      var m;
      const k = (((m = I.value) == null ? void 0 : m.index) ?? 0) + q;
      if (k < 0 || k >= c.value.length) return;
      const r = c.value[k];
      v.value !== r.value && w(r.value);
    }
    function P(q) {
      q.isClickable && v.value !== q.value && w(q.value);
    }
    const h = o(
      () => {
        var q;
        return ke(T((((q = I.value) == null ? void 0 : q.index) ?? 0) - 1, !1));
      }
    ), z = o(
      () => {
        var q;
        return ke(T((((q = I.value) == null ? void 0 : q.index) ?? 0) + 1, !0));
      }
    );
    function F(q) {
      const k = T(q + 1, !0);
      ke(k) && S(k);
    }
    function O(q) {
      const k = T(q - 1, !1);
      ke(k) && S(k);
    }
    function K() {
      const q = T(0, !0);
      ke(q) && S(q);
    }
    function U() {
      const q = T(c.value.length - 1, !1);
      ke(q) && S(q);
    }
    function S(q) {
      var r;
      if (q < 0 || q >= c.value.length) return;
      const k = c.value[q];
      if (a.activateOnFocus)
        P(k);
      else {
        const m = (r = d.value) == null ? void 0 : r.querySelector(
          `#tab-${k.identifier}`
        );
        m == null || m.focus();
      }
    }
    function T(q, k) {
      const r = k ? 1 : -1;
      let m = q;
      for (; m > 0 && m < c.value.length; m += r) {
        const R = c.value[m];
        if (R.visible && !R.disabled) break;
      }
      if (!(m < 0 || m >= c.value.length))
        return m;
    }
    function w(q) {
      var R;
      const k = (R = I.value) == null ? void 0 : R.value, r = I.value, m = c.value.find((L) => L.value === q) || c.value[0];
      r && m && (r.deactivate(m.index), m.activate(r.index)), ze(() => {
        v.value = q, e("change", q, k);
      });
    }
    const V = M(
      ["rootClass", "o-steps"],
      [
        "sizeClass",
        "o-steps--",
        o(() => a.size),
        o(() => !!a.size)
      ],
      [
        "variantClass",
        "o-steps--",
        o(() => a.variant),
        o(() => !!a.variant)
      ],
      [
        "verticalClass",
        "o-steps--vertical",
        null,
        o(() => a.vertical)
      ],
      [
        "positionClass",
        "o-steps--position-",
        o(() => a.position),
        o(() => !!a.position && a.vertical)
      ],
      ["mobileClass", "o-steps--mobile", null, s]
    ), $ = M(
      ["listClass", "o-steps__list"],
      [
        "animatedClass",
        "o-steps__list--animated",
        null,
        o(() => a.animated)
      ]
    ), Y = M(["dividerClass", "o-steps__divider"]), E = M(
      ["markerClass", "o-steps__marker"],
      [
        "markerRoundedClass",
        "o-steps__marker--rounded",
        null,
        o(() => a.rounded)
      ]
    ), Z = M(
      ["contentClass", "o-steps__content"],
      [
        "transitioningClass",
        "o-steps__content-transitioning",
        null,
        C
      ]
    ), _ = M([
      "navigationClass",
      "o-steps__navigation"
    ]);
    return (q, k) => (p(), A("div", {
      ref: "rootElement",
      "data-oruga": "steps",
      class: N(i(V))
    }, [
      pe("ol", {
        class: N(i($)),
        role: "tablist",
        "aria-label": q.ariaLabel,
        "aria-orientation": q.vertical ? "vertical" : "horizontal"
      }, [
        (p(!0), A(ve, null, $e(c.value, (r, m) => {
          var R, L, te;
          return Be((p(), A("li", {
            id: `tab-${r.identifier}`,
            key: r.identifier,
            class: N(r.stepClasses),
            role: "tab",
            tabindex: r.value === ((R = I.value) == null ? void 0 : R.value) ? 0 : -1,
            "aria-current": r.value === ((L = I.value) == null ? void 0 : L.value) ? "step" : void 0,
            "aria-controls": `tabpanel-${r.identifier}`,
            "aria-selected": r.value === ((te = I.value) == null ? void 0 : te.value),
            onClick: (W) => P(r),
            onKeydown: [
              oe(re((W) => P(r), ["prevent"]), ["enter"]),
              oe(re((W) => P(r), ["prevent"]), ["space"]),
              oe(re((W) => O(r.index), ["prevent"]), ["left"]),
              oe(re((W) => F(r.index), ["prevent"]), ["right"]),
              oe(re(K, ["prevent"]), ["home"]),
              oe(re(U, ["prevent"]), ["end"])
            ]
          }, [
            m > 0 ? (p(), A("span", {
              key: 0,
              class: N(i(Y))
            }, null, 2)) : Q("", !0),
            pe("div", {
              class: N(i(E))
            }, [
              r.icon ? (p(), se(Te, {
                key: 0,
                class: N(r.iconClasses),
                icon: r.icon,
                pack: r.iconPack,
                size: q.size
              }, null, 8, ["class", "icon", "pack", "size"])) : r.step ? (p(), A("span", ss, ce(r.step), 1)) : Q("", !0)
            ], 2),
            pe("div", {
              class: N(r.labelClasses)
            }, ce(r.label), 3)
          ], 42, ns)), [
            [Oe, r.visible]
          ]);
        }), 128))
      ], 10, os),
      pe("section", {
        class: N(i(Z))
      }, [
        ae(q.$slots, "default", {}, () => [
          (p(!0), A(ve, null, $e(f.value, (r) => Be((p(), se(pl, fe({ ref_for: !0 }, r.attrs, {
            key: r.key,
            value: r.value,
            label: r.label
          }), null, 16, ["value", "label"])), [
            [Oe, !r.hidden]
          ])), 128))
        ])
      ], 2),
      ae(q.$slots, "navigation", {
        previous: { disabled: !h.value, action: () => B(-1) },
        next: { disabled: !z.value, action: () => B(1) }
      }, () => [
        q.hasNavigation ? (p(), A("nav", {
          key: 0,
          class: N(i(_))
        }, [
          he(Dt, {
            role: "button",
            "icon-left": q.iconPrev,
            "icon-pack": q.iconPack,
            "icon-both": "",
            disabled: !h.value,
            "aria-label": q.ariaPreviousLabel,
            onClick: k[0] || (k[0] = re((r) => B(-1), ["prevent"]))
          }, null, 8, ["icon-left", "icon-pack", "disabled", "aria-label"]),
          he(Dt, {
            role: "button",
            "icon-left": q.iconNext,
            "icon-pack": q.iconPack,
            "icon-both": "",
            disabled: !z.value,
            "aria-label": q.ariaNextLabel,
            onClick: k[1] || (k[1] = re((r) => B(1), ["prevent"]))
          }, null, 8, ["icon-left", "icon-pack", "disabled", "aria-label"])
        ], 2)) : Q("", !0)
      ])
    ], 2));
  }
}), rs = {
  install(t) {
    Ie(t, is), Ie(t, pl);
  }
}, us = ["id", "name", "value", "true-value", "false-value", "required", "disabled", "autocomplete", "aria-checked", "aria-labelledby"], ds = ["id", "for"], cs = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OSwitch",
  configField: "switch",
  inheritAttrs: !1,
  __name: "Switch",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    variant: { default: () => n("switch.variant") },
    passiveVariant: { default: () => n("switch.passiveVariant") },
    size: { default: () => n("switch.size") },
    label: { default: void 0 },
    nativeValue: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    name: { default: void 0 },
    trueValue: { default: void 0 },
    falseValue: { default: void 0 },
    rounded: { type: Boolean, default: () => n("switch.rounded", !0) },
    position: { default: () => n("switch.right", "position") },
    autocomplete: { default: () => n("switch.autocomplete", "off") },
    id: { default: () => Le() },
    useHtml5Validation: { type: Boolean, default: () => n("useHtml5Validation", !0) },
    customValidity: {},
    rootClass: {},
    sizeClass: {},
    variantClass: {},
    passiveVariantClass: {},
    positionClass: {},
    disabledClass: {},
    roundedClass: {},
    checkedClass: {},
    inputClass: {},
    labelClass: {}
  }, {
    modelValue: { default: void 0 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:model-value", "input", "focus", "blur", "invalid"], ["update:modelValue"]),
  setup(t, { expose: l, emit: a }) {
    var K, U;
    const e = t, s = a, d = Me("inputElement"), { onBlur: g, onFocus: u, onInvalid: c, setFocus: y } = et(
      d,
      s,
      e
    ), { parentField: f } = Ge(), v = f.value || e.label || vt().default ? ((K = f.value) == null ? void 0 : K.labelId) || Le() : void 0;
    !e.label && e.id && ((U = f.value) == null || U.setInputId(e.id));
    const I = Pe(t, "modelValue"), C = o(
      () => I.value === (e.trueValue ?? !0) || Array.isArray(I.value) && I.value.includes(e.nativeValue)
    );
    function B(S) {
      s("input", I.value, S);
    }
    const P = it(), h = o(() => {
      var S;
      return {
        ...(S = f.value) == null ? void 0 : S.inputAttrs,
        ...P
      };
    }), z = M(
      ["rootClass", "o-switch"],
      [
        "sizeClass",
        "o-switch--",
        o(() => e.size),
        o(() => !!e.size)
      ],
      [
        "variantClass",
        "o-switch--",
        o(() => e.variant),
        o(() => !!e.variant)
      ],
      [
        "passiveVariantClass",
        "o-switch--",
        o(() => e.passiveVariant + "-passive"),
        o(() => !!e.passiveVariant)
      ],
      [
        "positionClass",
        "o-switch--",
        o(() => e.position),
        o(() => !!e.position)
      ],
      [
        "disabledClass",
        "o-switch--disabled",
        null,
        o(() => e.disabled)
      ],
      ["roundedClass", "o-switch--rounded", null, o(() => e.rounded)],
      ["checkedClass", "o-switch--checked", null, C]
    ), F = M(["inputClass", "o-switch__input"]), O = M(["labelClass", "o-switch__label"]);
    return l({ focus: y, value: I }), (S, T) => (p(), A("div", {
      "data-oruga": "switch",
      class: N(i(z))
    }, [
      Be(pe("input", fe(h.value, {
        id: S.id,
        ref: "inputElement",
        "onUpdate:modelValue": T[0] || (T[0] = (w) => I.value = w),
        type: "checkbox",
        role: "switch",
        "data-oruga-input": "switch",
        class: i(F),
        name: S.name,
        value: S.nativeValue,
        "true-value": S.trueValue ?? !0,
        "false-value": S.falseValue ?? !1,
        required: S.required,
        disabled: S.disabled,
        autocomplete: S.autocomplete,
        "aria-checked": C.value,
        "aria-labelledby": i(v),
        onBlur: T[1] || (T[1] = //@ts-ignore
        (...w) => i(g) && i(g)(...w)),
        onFocus: T[2] || (T[2] = //@ts-ignore
        (...w) => i(u) && i(u)(...w)),
        onInvalid: T[3] || (T[3] = //@ts-ignore
        (...w) => i(c) && i(c)(...w)),
        onChange: B
      }), null, 16, us), [
        [Ya, I.value]
      ]),
      S.label || S.$slots.default ? (p(), A("label", {
        key: 0,
        id: i(v),
        for: S.id,
        class: N(i(O))
      }, [
        ae(S.$slots, "default", {}, () => [
          Ve(ce(S.label), 1)
        ])
      ], 10, ds)) : Q("", !0)
    ], 2));
  }
}), fs = {
  install(t) {
    Ie(t, cs);
  }
}, Mt = Ce(
  (t, { slots: l }) => {
    const a = { tag: "div", name: "default", ...t };
    return () => {
      const e = t.component.$slots[a.name] ? t.component.$slots[a.name](t.props) : l.default ? l.default() : {};
      return he(a.tag, {}, e);
    };
  },
  {
    name: "OSlotComponent",
    // manual runtime props declaration is currently still needed.
    props: ["component", "props", "name", "tag"]
  }
), ps = ["value"], vs = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OTableMobileSort",
  configField: "table",
  __name: "TableMobileSort",
  props: {
    currentSortColumn: {
      type: Object,
      default: void 0
    },
    columns: {
      type: Array,
      default: void 0
    },
    placeholder: { type: String, default: void 0 },
    iconPack: { type: String, default: void 0 },
    sortIcon: { type: String, default: "arrow-up" },
    sortIconSize: { type: String, default: "small" },
    isAsc: { type: Boolean, default: !1 },
    mobileSortClasses: { type: Array, required: !0 }
  },
  emits: ["sort"],
  setup(t, { emit: l }) {
    var y;
    const a = t, e = l, s = ne((y = a.currentSortColumn) == null ? void 0 : y.identifier), d = o(
      () => !a.columns || a.columns.every((f) => f.identifier !== s.value)
    ), g = o(
      () => a.columns ? a.columns.filter((f) => f.sortable) : []
    ), u = o(
      () => {
        var f;
        return ((f = a.currentSortColumn) == null ? void 0 : f.identifier) === s.value;
      }
    );
    be(s, (f) => {
      var v;
      ((v = a.currentSortColumn) == null ? void 0 : v.identifier) !== f && c(new Event("sort"));
    }), be(
      () => a.currentSortColumn,
      (f) => {
        s.value = f == null ? void 0 : f.identifier;
      }
    );
    function c(f) {
      const v = g.value.find(
        (I) => I.identifier === s.value
      );
      v && e("sort", v, f);
    }
    return (f, v) => (p(), A("div", {
      class: N(t.mobileSortClasses)
    }, [
      he(sl, { addons: "" }, {
        default: de(() => [
          he(ft, {
            modelValue: s.value,
            "onUpdate:modelValue": v[0] || (v[0] = (I) => s.value = I),
            expanded: ""
          }, {
            default: de(() => [
              t.placeholder ? Be((p(), A("option", {
                key: 0,
                value: {},
                selected: "",
                disabled: "",
                hidden: ""
              }, ce(t.placeholder), 513)), [
                [Oe, d.value]
              ]) : Q("", !0),
              (p(!0), A(ve, null, $e(g.value, (I, C) => (p(), A("option", {
                key: I.field || C,
                value: I.identifier
              }, ce(I.label), 9, ps))), 128))
            ]),
            _: 1
          }, 8, ["modelValue"]),
          he(Dt, {
            onClick: v[1] || (v[1] = (I) => c(I))
          }, {
            default: de(() => [
              Be(he(Te, {
                icon: t.sortIcon,
                pack: t.iconPack,
                size: t.sortIconSize,
                both: "",
                rotation: t.isAsc ? 0 : 180
              }, null, 8, ["icon", "pack", "size", "rotation"]), [
                [Oe, u.value]
              ])
            ]),
            _: 1
          })
        ]),
        _: 1
      })
    ], 2));
  }
}), ms = ["data-id"], vl = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OTableColumn",
  configField: "table",
  __name: "TableColumn",
  props: {
    label: { default: void 0 },
    field: { default: void 0 },
    formatter: { type: Function, default: void 0 },
    subheading: { default: void 0 },
    width: { default: void 0 },
    numeric: { type: Boolean, default: !1 },
    position: { default: void 0 },
    searchable: { type: Boolean, default: !1 },
    sortable: { type: Boolean, default: !1 },
    hidden: { type: Boolean, default: !1 },
    sticky: { type: Boolean, default: !1 },
    headerSelectable: { type: Boolean, default: !1 },
    customSort: { type: Function, default: void 0 },
    customSearch: { type: Function, default: void 0 },
    thAttrs: { default: void 0 },
    tdAttrs: { default: void 0 }
  },
  setup(t) {
    const l = t, a = o(() => ({
      width: wt(l.width)
    })), e = o(
      () => !l.headerSelectable && l.sortable
    ), s = St(), d = o(() => ({
      ...l,
      $el: s.proxy,
      $slots: s.slots,
      style: a.value,
      thClasses: c.value,
      tdClasses: y.value
    })), { parent: g, item: u } = pt({ data: d }), c = M(
      [
        "thCurrentSortClass",
        "o-table__th-current-sort",
        null,
        o(() => {
          var f;
          return (f = g.value) == null ? void 0 : f.isColumnSorted(u.value);
        })
      ],
      [
        "thSortableClass",
        "o-table__th--sortable",
        null,
        o(() => l.sortable)
      ],
      [
        "thUnselectableClass",
        "o-table__th--unselectable",
        null,
        e
      ],
      [
        "thPositionClass",
        "o-table__th--",
        o(() => l.position),
        o(() => !!l.position)
      ],
      [
        "thStickyClass",
        "o-table__th--sticky",
        null,
        o(() => l.sticky)
      ]
    ), y = M(
      [
        "tdPositionClass",
        "o-table__td--",
        o(() => l.position),
        o(() => !!l.position)
      ],
      [
        "tdStickyClass",
        "o-table__td--sticky",
        null,
        o(() => l.sticky)
      ]
    );
    return (f, v) => (p(), A("span", {
      "data-oruga": "table-column",
      "data-id": `table-${i(u).identifier}`
    }, [
      Ve(ce(f.label) + " ", 1),
      Q("", !0)
    ], 8, ms));
  }
}), La = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OTablePagination",
  configField: "table",
  inheritAttrs: !1,
  __name: "TablePagination",
  props: /* @__PURE__ */ ge({
    current: { type: Number, default: void 0 },
    paginated: { type: Boolean, default: !1 },
    rootClass: {
      type: [String, Array, Object],
      default: void 0
    }
  }, {
    current: {},
    currentModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:current", "change"], ["update:current"]),
  setup(t, { emit: l }) {
    const a = l, e = Pe(t, "current");
    function s(d) {
      const g = d > 0 ? d : 1;
      e.value = g, a("change", g);
    }
    return (d, g) => (p(), A("div", {
      class: N(t.rootClass)
    }, [
      pe("div", null, [
        ae(d.$slots, "default")
      ]),
      pe("div", null, [
        t.paginated ? (p(), se(ul, fe({ key: 0 }, d.$attrs, {
          current: e.value,
          onChange: s
        }), null, 16, ["current"])) : Q("", !0)
      ])
    ], 2));
  }
}), bs = {
  ref: "slotsWrapper",
  style: { display: "none" }
}, gs = ["tabindex", "aria-rowcount", "aria-colcount"], ys = { key: 0 }, Cs = { key: 1 }, hs = { "aria-rowindex": 1 }, ks = ["aria-colindex"], ws = ["draggable", "aria-sort", "aria-colindex", "onClick", "onDragstart", "onDragend", "onDrop", "onDragover", "onDragleave"], Ps = { key: 1 }, Ds = ["aria-hidden"], Ss = ["aria-colindex"], $s = {
  key: 0,
  "aria-rowindex": 2
}, Bs = { key: 1 }, Is = { key: 2 }, Fs = ["aria-rowindex"], Ms = { key: 1 }, Os = { key: 1 }, Vs = { key: 2 }, As = ["draggable", "aria-rowindex", "onClick", "onDblclick", "onMouseenter", "onMouseleave", "onContextmenu", "onDragstart", "onDragend", "onDrop", "onDragover", "onDragleave"], zs = ["colspan"], Ts = ["colspan"], Rs = { key: 2 }, Ls = ["colspan"], Es = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OTable",
  configField: "table",
  inheritAttrs: !1,
  __name: "Table",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    data: { default: void 0 },
    columns: { default: void 0 },
    rowKey: { default: () => n("table.rowKey") },
    rowClass: { type: Function, default: n("table.rowClass", () => "") },
    thAttrs: { type: Function, default: void 0 },
    tdAttrs: { type: Function, default: void 0 },
    customCompare: { type: Function, default: void 0 },
    bordered: { type: Boolean, default: () => n("table.bordered", !1) },
    striped: { type: Boolean, default: () => n("table.striped", !1) },
    narrowed: { type: Boolean, default: () => n("table.narrowed", !1) },
    hoverable: { type: Boolean, default: () => n("table.hoverable", !1) },
    selected: { default: void 0 },
    selectable: { type: Boolean, default: () => n("table.selectable", !1) },
    isRowSelectable: { type: Function, default: () => !0 },
    showHeader: { type: Boolean, default: () => n("table.showHeader", !0) },
    draggable: { type: Boolean, default: !1 },
    draggableColumn: { type: Boolean, default: !1 },
    scrollable: { type: Boolean, default: void 0 },
    stickyHeader: { type: Boolean, default: !1 },
    height: { default: void 0 },
    checkable: { type: Boolean, default: !1 },
    checkableHeader: { type: Boolean, default: !0 },
    stickyCheckbox: { type: Boolean, default: !1 },
    checkedRows: { default: () => [] },
    checkboxPosition: { default: () => n("table.checkboxPosition", "left") },
    checkboxVariant: { default: () => n("table.checkboxVariant") },
    isRowChecked: { type: Function, default: void 0 },
    isRowCheckable: { type: Function, default: n("table.isRowCheckable", () => !0) },
    backendSorting: { type: Boolean, default: () => n("table.backendSorting", !1) },
    defaultSort: { default: () => n("table.defaultSort") },
    defaultSortDirection: { default: () => n("table.defaultSortDirection", "asc") },
    sortIcon: { default: () => n("table.sortIcon", "arrow-up") },
    sortIconSize: { default: () => n("table.sortIconSize", "small") },
    iconPack: { default: () => n("table.iconPack") },
    detailed: { type: Boolean, default: !1 },
    detailedRows: { default: () => [] },
    isDetailedVisible: { type: Function, default: n("table.isDetailedVisible", () => !0) },
    showDetailIcon: { type: Boolean, default: () => n("table.showDetailIcon", !0) },
    detailIcon: { default: () => n("table.detailIcon", "chevron-right") },
    customDetailRow: { type: Boolean, default: !1 },
    detailTransition: { default: () => n("table.detailTransition", "slide") },
    paginated: { type: Boolean, default: () => n("table.paginated", !1) },
    backendPagination: { type: Boolean, default: !1 },
    total: { default: 0 },
    currentPage: { default: 1 },
    perPage: { default: () => n("table.perPage", 20) },
    paginationPosition: { default: () => n("table.paginationPosition", "bottom") },
    paginationSize: { default: () => n("table.paginationSize", "small") },
    paginationRounded: { type: Boolean, default: () => n("table.paginationRounded", !1) },
    paginationSimple: { type: Boolean, default: () => n("table.paginationSimple", !1) },
    paginationOrder: { default: () => n("table.paginationOrder") },
    backendFiltering: { type: Boolean, default: () => n("table.backendFiltering", !1) },
    filtersIcon: { default: () => n("table.filterIcon") },
    filtersPlaceholder: { default: () => n("table.filterPlaceholder") },
    filtersEvent: { default: "" },
    filterDebounce: { default: () => n("table.filterDebounce", 300) },
    emptyLabel: { default: () => n("table.emptyLabel") },
    emptyIcon: { default: () => n("table.emptyIcon") },
    emptyIconSize: { default: () => n("table.emptyIconSize") },
    loading: { type: Boolean, default: !1 },
    loadingIcon: { default: () => n("table.loadingIcon", "loading") },
    loadingLabel: { default: () => n("table.loadingLabel") },
    mobileBreakpoint: { default: () => n("table.mobileBreakpoint") },
    mobileCards: { type: Boolean, default: () => n("table.mobileCards", !0) },
    mobileSortPlaceholder: { default: () => n("table.mobileSortPlaceholder") },
    ariaNextLabel: { default: () => n("table.ariaNextLabel") },
    ariaPreviousLabel: { default: () => n("table.ariaPreviousLabel") },
    ariaPageLabel: { default: () => n("table.ariaPageLabel") },
    ariaCurrentLabel: { default: () => n("table.ariaCurrentLabel") },
    rootClass: {},
    mobileClass: {},
    mobileSortClass: {},
    wrapperClass: {},
    stickyHeaderClass: {},
    scrollableClass: {},
    tableClass: {},
    borderedClass: {},
    stripedClass: {},
    narrowedClass: {},
    hoverableClass: {},
    emptyClass: {},
    thClass: {},
    thPositionClass: {},
    thCheckboxClass: {},
    thStickyClass: {},
    thDetailedClass: {},
    thSortableClass: {},
    thSortIconClass: {},
    thCurrentSortClass: {},
    thUnselectableClass: {},
    thSubheadingClass: {},
    trSelectedClass: {},
    trCheckedClass: {},
    trDetailedClass: {},
    trEmptyClass: {},
    tdClass: {},
    tdPositionClass: {},
    tdStickyClass: {},
    tdCheckboxClass: {},
    tdDetailedChevronClass: {},
    paginationWrapperClass: {},
    footerClass: {},
    loadingClasses: {}
  }, {
    currentPage: { default: 1 },
    currentPageModifiers: {},
    selected: { default: void 0 },
    selectedModifiers: {},
    checkedRows: {
      default: []
    },
    checkedRowsModifiers: {},
    detailedRows: {
      default: []
    },
    detailedRowsModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:currentPage", "page-change", "update:selected", "select", "check", "check-all", "update:checkedRows", "sort", "filters-change", "filters-event", "update:detailedRows", "details-open", "details-close", "click", "dblclick", "contextmenu", "mouseenter", "mouseleave", "cell-click", "dragstart", "dragend", "drop", "dragleave", "dragover", "columndragstart", "columndragend", "columndrop", "columndragleave", "columndragover"], ["update:currentPage", "update:selected", "update:checkedRows", "update:detailedRows"]),
  setup(t, { expose: l, emit: a }) {
    const e = t, s = a, d = vt(), { isMobile: g } = rt(e.mobileBreakpoint), u = o(() => e.mobileCards && g.value), c = Me("slotsWrapper"), y = o(() => ({
      isColumnSorted: H
    })), { childItems: f } = bt({
      rootRef: c,
      data: y
    }), v = o(() => f.value.length ? f.value.map((b) => {
      const ee = Ae(b.data);
      let x = typeof e.thAttrs == "function" ? e.thAttrs(ee) : {};
      x = Object.assign(x, ee.thAttrs);
      const De = (e.data ?? []).map((ie) => {
        const Re = typeof e.tdAttrs == "function" ? e.tdAttrs(ie, ee) : {};
        return Object.assign(Re, ee.tdAttrs);
      });
      return {
        ...ee,
        value: ee,
        index: b.index,
        identifier: b.identifier,
        thAttrsData: x,
        tdAttrsData: De
      };
    }) : []), I = o(() => {
      let b = v.value.length;
      return D.value && b++, e.checkable && b++, b;
    }), C = o(() => {
      let b = 1;
      return D.value && b++, e.checkable && e.checkboxPosition === "left" && b++, b;
    }), B = o(() => d.subheading ? !0 : v.value.some((b) => !!b.subheading)), P = o(() => e.scrollable ? !0 : v.value.some((b) => b.sticky)), h = Pe(t, "currentPage");
    be(
      [h, () => e.perPage, () => e.data],
      () => K()
    );
    const { nextSequence: z } = ut(), F = o(() => e.data ? e.data.map((b, ee) => ({
      label: "row " + ee,
      // row display label
      value: Ae(b),
      // normalizes wrapped ref values
      index: ee,
      // row index
      key: (
        // if no key is given and data is object, create unique row id for each row
        String(
          Ye(
            b,
            e.rowKey,
            z()
          )
        )
      )
    })) : []), O = o(
      () => F.value.filter(_a)
    );
    function K() {
      const b = h.value, ee = Number(e.perPage), x = (b - 1) * ee, De = x + ee;
      ka(F, (ie, Re) => (e.paginated || !e.backendPagination) && F.value.length > ee && (Re < x || Re >= De) ? !0 : e.backendFiltering ? !1 : !R(ie.value));
    }
    const U = o(
      () => e.backendPagination ? e.total : F.value.length
    ), S = o(() => U.value + T.value), T = o(() => {
      let b = 1;
      return q.value && b++, B.value && b++, b;
    });
    function w() {
      if (!d.footer) return !1;
      const b = d.footer({
        columnCount: I.value,
        rowCount: S.value
      });
      if (b.length > 1) return !0;
      const ee = b[0].type;
      return ee === "th" || ee === "td";
    }
    function V(b, ee) {
      return ia(b, ee.field, ee.formatter);
    }
    function $(b, ee) {
      const x = Xt(Ae(b)), De = Xt(Ae(ee));
      return ke(ee) ? typeof e.customCompare == "function" ? e.customCompare(x, De) : e.rowKey ? ia(x, e.rowKey) == ia(De, e.rowKey) : x == De : !1;
    }
    const Y = Pe(t, "selected");
    function E(b, ee) {
      if (!O.value.length) return;
      let x = O.value.findIndex(
        (ie) => $(ie.value, Y.value)
      ) + b;
      x = x > O.value.length - 1 ? O.value.length - 1 : x, x = x < 0 ? 0 : x;
      const De = O.value[x];
      if (e.isRowSelectable(De.value))
        Z(De, ee);
      else {
        let ie;
        if (b > 0)
          for (let Re = x; Re < O.value.length && ie === void 0; Re++)
            e.isRowSelectable(O.value[Re].value) && (ie = Re);
        else
          for (let Re = x; Re >= 0 && ie === void 0; Re--)
            e.isRowSelectable(O.value[Re].value) && (ie = Re);
        ie != null && ie >= 0 && Z(O.value[ie], ee);
      }
    }
    function Z(b, ee) {
      s("click", b.value, b.index, ee), e.selectable && ($(Y, b.value) || e.isRowSelectable(b.value) && (Y.value = b.value, s("select", b.value, Y.value)));
    }
    const _ = ne({}), q = o(
      () => v.value.some((b) => b.searchable)
    );
    let k;
    be(
      () => e.filterDebounce,
      (b) => k = Ca(r, b || 0),
      { immediate: !0 }
    ), be(_, (b) => k(b), { deep: !0 });
    function r(b) {
      s("filters-change", b), e.backendFiltering || (K(), _t(F));
    }
    function m(b) {
      s("filters-event", e.filtersEvent, _.value, b);
    }
    function R(b) {
      return Object.values(_.value).filter(Boolean).length ? Object.entries(_.value).some(([ee, x]) => {
        if (!x) return !1;
        const De = v.value.find((Lt) => Lt.field === ee);
        if (typeof (De == null ? void 0 : De.customSearch) == "function")
          return De.customSearch(b, x);
        const ie = typeof b == "object" && b ? Ye(b, ee) : b;
        if (ie == null) return !1;
        if (Number.isInteger(ie)) return ie === Number(x);
        const Re = new RegExp(oo(x), "i");
        return Array.isArray(ie) ? ie.some(
          (Lt) => Re.test(Va(Lt)) || Re.test(Lt)
        ) : typeof ie != "string" ? !!ie : Re.test(Va(ie)) || Re.test(ie);
      }) : !0;
    }
    const L = ne(), te = ne(!0), W = o(
      () => v.value.some((b) => b.sortable)
    );
    function H(b) {
      var ee;
      return ((ee = L.value) == null ? void 0 : ee.identifier) === b.identifier;
    }
    st(() => ze(() => J()));
    function J() {
      if (!v.value.length || L.value || !e.defaultSort) return;
      let b = "", ee = e.defaultSortDirection;
      Array.isArray(e.defaultSort) ? (b = e.defaultSort[0], e.defaultSort[1] && (ee = e.defaultSort[1])) : b = e.defaultSort, j(b, ee);
    }
    function j(b, ee) {
      const x = v.value.find(
        (De) => De.field === b
      );
      x && (te.value = ee.toLowerCase() === "asc", ye(x));
    }
    function ye(b, ee = !1, x) {
      b != null && b.sortable && (ee && (te.value = H(b) ? !te.value : e.defaultSortDirection.toLowerCase() === "asc"), L.value && s(
        "sort",
        b,
        te.value ? "asc" : "desc",
        x || new Event("sort")
      ), L.value = b, e.backendSorting || (Se(F.value), K()));
    }
    function Se(b) {
      const ee = L.value;
      return ee ? lo(
        b,
        ee != null && ee.field ? "value." + ee.field : "",
        ee != null && ee.customSort ? (x, De, ie) => ee.customSort(x.value, De.value, ie) : void 0,
        te.value,
        !0
      ) : b;
    }
    const Ne = Pe(t, "checkedRows"), Ue = o(() => {
      const b = O.value.filter(
        (ee) => e.isRowCheckable(ee.value)
      );
      return b.length === 0 ? !1 : b.every(
        (ee) => je(ee)
      );
    }), Qe = o(
      () => !O.value.some((b) => e.isRowCheckable(b.value))
    );
    function je(b) {
      return typeof e.isRowChecked == "function" ? e.isRowChecked(b.value) : Ne.value.some((ee) => $(ee, b.value));
    }
    function gt(b) {
      Ne.value = [...Ne.value, b.value];
    }
    function yt(b) {
      const ee = Ne.value.findIndex(
        (x) => $(x, b.value)
      );
      ee >= 0 && (Ne.value = Ne.value.toSpliced(ee, 1));
    }
    function ue() {
      Ue.value ? Ne.value = [] : Ne.value = O.value.filter((b) => e.isRowCheckable(b.value)).map((b) => b.value), ze(() => s("check-all", Ne.value));
    }
    function X(b) {
      e.isRowCheckable(b.value) && (je(b) ? yt(b) : gt(b), ze(() => s("check", Ne.value, b.value)));
    }
    const G = Pe(t, "detailedRows"), D = o(
      () => e.detailed && e.showDetailIcon
    );
    function le(b) {
      He(b) ? (Fe(b), s("details-close", b.value)) : (me(b), s("details-open", b.value));
    }
    function me(b) {
      G.value = [...G.value, b.value];
    }
    function Fe(b) {
      const ee = G.value.findIndex(
        (x) => $(x, b.value)
      );
      ee >= 0 && (G.value = G.value.toSpliced(ee, 1));
    }
    function He(b) {
      return e.detailed && G.value.some((ee) => $(ee, b.value));
    }
    const na = ne(!1), Ze = ne(!1), bl = o(() => e.draggable && !Ze.value), Ct = o(
      () => e.draggableColumn && !na.value
    );
    function gl(b, ee) {
      e.draggable && s("dragstart", b.value, b.index, ee);
    }
    function yl(b, ee) {
      e.draggable && s("dragend", b.value, b.index, ee);
    }
    function Cl(b, ee) {
      e.draggable && s("drop", b.value, b.index, ee);
    }
    function hl(b, ee) {
      e.draggable && s("dragover", b.value, b.index, ee);
    }
    function kl(b, ee) {
      e.draggable && s("dragleave", b.value, b.index, ee);
    }
    function wl(b, ee) {
      Ct.value && (Ze.value = !0, s("columndragstart", b.value, b.index, ee));
    }
    function Pl(b, ee) {
      Ct.value && (Ze.value = !1, s("columndragend", b.value, b.index, ee));
    }
    function Dl(b, ee) {
      Ct.value && s("columndrop", b.value, b.index, ee);
    }
    function Sl(b, ee) {
      Ct.value && s("columndragover", b.value, b.index, ee);
    }
    function $l(b, ee) {
      Ct.value && s("columndragleave", b.value, b.index, ee);
    }
    const Bl = M(
      ["rootClass", "o-table__root"],
      ["mobileClass", "o-table__root--mobile", null, u]
    ), Il = M(
      ["wrapperClass", "o-table__wrapper"],
      [
        "stickyHeaderClass",
        "o-table__wrapper--sticky-header",
        null,
        o(() => e.stickyHeader)
      ],
      ["scrollableClass", "o-table__wrapper--scrollable", null, P],
      ["mobileClass", "o-table__wrapper--mobile", null, u]
    ), Fl = o(() => ({
      height: wt(e.height)
    })), Ml = M(
      ["tableClass", "o-table"],
      [
        "borderedClass",
        "o-table--bordered",
        null,
        o(() => e.bordered)
      ],
      ["stripedClass", "o-table--striped", null, o(() => e.striped)],
      [
        "narrowedClass",
        "o-table--narrowed",
        null,
        o(() => e.narrowed)
      ],
      [
        "hoverableClass",
        "o-table--hoverable",
        null,
        o(
          () => (e.hoverable || e.selectable) && !!O.value.length
        )
      ],
      [
        "emptyClass",
        "o-table--empty",
        null,
        o(() => !O.value.length)
      ]
    ), _e = M(["thClass", "o-table__th"]), Sa = M(
      ["thCheckboxClass", "o-table__th-checkbox"],
      [
        "thStickyClass",
        "o-table__th--sticky",
        null,
        o(() => e.stickyCheckbox)
      ]
    ), sa = M([
      "thDetailedClass",
      "o-table__th-detailed"
    ]), Ol = M([
      "thSubheadingClass",
      "o-table__th-subheading"
    ]), Vl = M([
      "thSortIconClass",
      "o-table__th__sort-icon"
    ]), Al = M([
      "trSelectedClass",
      "o-table__tr--selected"
    ]), zl = M([
      "trCheckedClass",
      "o-table__tr--checked"
    ]), Tl = M(["trEmptyClass", "o-table__tr-empty"]), Rl = M([
      "trDetailedClass",
      "o-table__tr-detail"
    ]), $a = M(["tdClass", "o-table__td"]), Ba = M(
      ["tdCheckboxClass", "o-table__td-checkbox"],
      [
        "thStickyClass",
        "o-table__th--sticky",
        null,
        o(() => e.stickyCheckbox)
      ]
    ), Ll = M([
      "tdDetailedChevronClass",
      "o-table__td-chevron"
    ]), El = M(["footerClass", "o-table__footer"]), Hl = M([
      "mobileSortClass",
      "o-table__mobile-sort"
    ]), Nl = M([
      "paginationWrapperClass",
      "o-table__pagination"
    ]), Ia = o(
      () => Ke(Nl)
    );
    function xl(b) {
      const ee = $(b.value, Y.value) ? Al.value : [], x = je(b) ? zl.value : [], De = typeof e.rowClass == "function" && e.rowClass(b.value, b.index) || "";
      return [...ee, ...x, { [De]: !0 }];
    }
    return K(), l({ rows: F, sort: j }), (b, ee) => (p(), A("div", {
      "data-oruga": "table",
      class: N(i(Bl))
    }, [
      pe("div", bs, [
        ae(b.$slots, "default", {}, () => {
          var x;
          return [
            ae(b.$slots, "before"),
            (x = b.columns) != null && x.length ? (p(!0), A(ve, { key: 0 }, $e(b.columns, (De, ie) => (p(), se(vl, fe({
              key: De.field || ie,
              ref_for: !0
            }, De), {
              default: de(({ row: Re }) => [
                Ve(ce(V(Re, De)), 1)
              ]),
              _: 2
            }, 1040))), 128)) : Q("", !0),
            ae(b.$slots, "after")
          ];
        })
      ], 512),
      u.value && W.value ? (p(), se(vs, {
        key: 0,
        "current-sort-column": L.value,
        columns: v.value,
        placeholder: b.mobileSortPlaceholder,
        "icon-pack": b.iconPack,
        "sort-icon": b.sortIcon,
        "sort-icon-size": b.sortIconSize,
        "is-asc": te.value,
        "mobile-sort-classes": i(Hl),
        onSort: ee[0] || (ee[0] = (x, De) => ye(x, !0, De))
      }, null, 8, ["current-sort-column", "columns", "placeholder", "icon-pack", "sort-icon", "sort-icon-size", "is-asc", "mobile-sort-classes"])) : Q("", !0),
      b.paginated && (b.paginationPosition === "top" || b.paginationPosition === "both") ? ae(b.$slots, "pagination", {
        key: 1,
        current: h.value,
        perPage: b.perPage,
        total: U.value,
        change: (x) => h.value = x
      }, () => [
        he(La, {
          current: h.value,
          "onUpdate:current": ee[1] || (ee[1] = (x) => h.value = x),
          paginated: b.paginated,
          "per-page": b.perPage,
          total: U.value,
          rounded: b.paginationRounded,
          size: b.paginationSize,
          order: b.paginationOrder,
          simple: b.paginationSimple,
          "icon-pack": b.iconPack,
          "aria-next-label": b.ariaNextLabel,
          "aria-previous-label": b.ariaPreviousLabel,
          "aria-page-label": b.ariaPageLabel,
          "aria-current-label": b.ariaCurrentLabel,
          "root-class": Ia.value,
          onChange: ee[2] || (ee[2] = (x) => b.$emit("page-change", x))
        }, {
          default: de(() => [
            ae(b.$slots, "top-left")
          ]),
          _: 3
        }, 8, ["current", "paginated", "per-page", "total", "rounded", "size", "order", "simple", "icon-pack", "aria-next-label", "aria-previous-label", "aria-page-label", "aria-current-label", "root-class"])
      ]) : Q("", !0),
      pe("div", {
        class: N(i(Il)),
        style: Xe(Fl.value)
      }, [
        v.value.length ? (p(), A("table", fe({ key: 0 }, b.$attrs, {
          class: i(Ml),
          tabindex: b.selectable || P.value ? 0 : void 0,
          "aria-rowcount": S.value,
          "aria-colcount": I.value,
          onKeydown: [
            ee[3] || (ee[3] = oe(re((x) => E(-1, x), ["prevent"]), ["up"])),
            ee[4] || (ee[4] = oe(re((x) => E(1, x), ["prevent"]), ["down"])),
            ee[5] || (ee[5] = oe(re((x) => Z(O.value[0], x), ["prevent"]), ["home"])),
            ee[6] || (ee[6] = oe(re((x) => Z(O.value[O.value.length - 1], x), ["prevent"]), ["end"]))
          ]
        }), [
          b.$slots.caption ? (p(), A("caption", ys, [
            ae(b.$slots, "caption")
          ])) : Q("", !0),
          b.showHeader ? (p(), A("thead", Cs, [
            ae(b.$slots, "preheader"),
            pe("tr", hs, [
              D.value ? (p(), A("th", {
                key: 0,
                class: N([...i(_e), ...i(sa)]),
                "aria-colindex": 1,
                "aria-hidden": "true"
              }, null, 2)) : Q("", !0),
              b.checkable && b.checkboxPosition === "left" ? (p(), A("th", {
                key: 1,
                class: N([...i(_e), ...i(Sa)]),
                "aria-colindex": D.value ? 2 : 1
              }, [
                b.checkableHeader ? ae(b.$slots, "check-all", {
                  key: 0,
                  isAllChecked: Ue.value,
                  isAllUncheckable: Qe.value,
                  checkAll: ue
                }, () => [
                  he(Ft, {
                    "model-value": Ue.value,
                    autocomplete: "off",
                    name: "row_check_all",
                    variant: b.checkboxVariant,
                    disabled: Qe.value,
                    "aria-label": "Check all",
                    "onUpdate:modelValue": ue
                  }, null, 8, ["model-value", "variant", "disabled"])
                ]) : Q("", !0)
              ], 10, ks)) : Q("", !0),
              (p(!0), A(ve, null, $e(v.value, (x) => {
                var De;
                return p(), A(ve, {
                  key: x.identifier
                }, [
                  x.hidden ? Q("", !0) : (p(), A("th", fe({
                    key: 0,
                    ref_for: !0
                  }, x.thAttrsData, {
                    class: [...i(_e), ...x.thClasses],
                    style: u.value ? {} : x.style,
                    draggable: Ct.value,
                    "aria-sort": H(x) ? te.value ? "ascending" : "descending" : void 0,
                    "aria-colindex": C.value + x.index,
                    onClick: re((ie) => ye(x, !0, ie), ["stop"]),
                    onDragstart: (ie) => wl(x, ie),
                    onDragend: (ie) => Pl(x, ie),
                    onDrop: (ie) => Dl(x, ie),
                    onDragover: (ie) => Sl(x, ie),
                    onDragleave: (ie) => $l(x, ie)
                  }), [
                    (De = x.$slots) != null && De.header ? (p(), se(i(Mt), {
                      key: 0,
                      component: x.$el,
                      name: "header",
                      tag: "span",
                      props: {
                        column: x.value,
                        index: x.index
                      }
                    }, null, 8, ["component", "props"])) : (p(), A("span", Ps, [
                      Ve(ce(x.label) + " ", 1),
                      x.sortable ? Be((p(), A("span", {
                        key: 0,
                        class: N(i(Vl)),
                        "aria-hidden": !H(x)
                      }, [
                        he(Te, {
                          icon: b.sortIcon,
                          pack: b.iconPack,
                          both: "",
                          size: b.sortIconSize,
                          rotation: te.value ? 0 : 180
                        }, null, 8, ["icon", "pack", "size", "rotation"])
                      ], 10, Ds)), [
                        [Oe, H(x)]
                      ]) : Q("", !0)
                    ]))
                  ], 16, ws))
                ], 64);
              }), 128)),
              b.checkable && b.checkboxPosition === "right" ? (p(), A("th", {
                key: 2,
                class: N([...i(_e), ...i(Sa)]),
                "aria-colindex": C.value + v.value.length
              }, [
                b.checkableHeader ? ae(b.$slots, "check-all", {
                  key: 0,
                  isAllChecked: Ue.value,
                  isAllUncheckable: Qe.value,
                  checkAll: ue
                }, () => [
                  he(Ft, {
                    "model-value": Ue.value,
                    autocomplete: "off",
                    name: "row_check_all",
                    variant: b.checkboxVariant,
                    disabled: Qe.value,
                    "aria-label": "Check all",
                    "onUpdate:modelValue": ue
                  }, null, 8, ["model-value", "variant", "disabled"])
                ]) : Q("", !0)
              ], 10, Ss)) : Q("", !0)
            ]),
            q.value ? (p(), A("tr", $s, [
              D.value ? (p(), A("th", {
                key: 0,
                class: N([...i(_e), ...i(sa)]),
                "aria-hidden": "true"
              }, null, 2)) : Q("", !0),
              b.checkable && b.checkboxPosition === "left" ? (p(), A("th", Bs)) : Q("", !0),
              (p(!0), A(ve, null, $e(v.value, (x) => {
                var De;
                return p(), A(ve, {
                  key: x.identifier
                }, [
                  x.hidden ? Q("", !0) : (p(), A("th", fe({
                    key: 0,
                    ref_for: !0
                  }, x.thAttrsData, {
                    class: [...i(_e), ...x.thClasses],
                    style: u.value ? {} : x.style
                  }), [
                    x.searchable ? (p(), A(ve, { key: 0 }, [
                      (De = x.$slots) != null && De.searchable ? (p(), se(i(Mt), {
                        key: 0,
                        component: x.$el,
                        name: "searchable",
                        tag: "span",
                        props: {
                          column: x.value,
                          index: x.index,
                          filters: _.value
                        }
                      }, null, 8, ["component", "props"])) : x.field ? (p(), se(Pt, fe({
                        key: 1,
                        modelValue: _.value[x.field],
                        "onUpdate:modelValue": (ie) => _.value[x.field] = ie,
                        name: `column_${x.field}_filter`,
                        type: x.numeric ? "number" : "search",
                        placeholder: b.filtersPlaceholder,
                        icon: b.filtersIcon,
                        pack: b.iconPack,
                        size: "small",
                        "aria-label": `${x.label} search`
                      }, { [_l(b.filtersEvent)]: m }), null, 16, ["modelValue", "onUpdate:modelValue", "name", "type", "placeholder", "icon", "pack", "aria-label"])) : Q("", !0)
                    ], 64)) : Q("", !0)
                  ], 16))
                ], 64);
              }), 128)),
              b.checkable && b.checkboxPosition === "right" ? (p(), A("th", Is)) : Q("", !0)
            ])) : Q("", !0),
            B.value ? (p(), A("tr", {
              key: 1,
              "aria-rowindex": q.value ? 3 : 2
            }, [
              D.value ? (p(), A("th", {
                key: 0,
                class: N([...i(_e), ...i(sa)])
              }, null, 2)) : Q("", !0),
              b.checkable && b.checkboxPosition === "left" ? (p(), A("th", Ms)) : Q("", !0),
              (p(!0), A(ve, null, $e(v.value, (x) => {
                var De;
                return p(), A(ve, {
                  key: x.identifier
                }, [
                  x.hidden ? Q("", !0) : (p(), A("th", {
                    key: 0,
                    style: Xe(u.value ? {} : x.style),
                    class: N([
                      ...i(_e),
                      ...i(Ol)
                    ])
                  }, [
                    (De = x.$slots) != null && De.subheading ? (p(), se(i(Mt), {
                      key: 0,
                      component: x.$el,
                      name: "subheading",
                      tag: "span",
                      props: {
                        column: x.value,
                        index: x.index
                      }
                    }, null, 8, ["component", "props"])) : (p(), A("span", Os, [
                      ae(b.$slots, "subheading", {}, () => [
                        Ve(ce(x.subheading), 1)
                      ])
                    ]))
                  ], 6))
                ], 64);
              }), 128)),
              b.checkable && b.checkboxPosition === "right" ? (p(), A("th", Vs)) : Q("", !0)
            ], 8, Fs)) : Q("", !0)
          ])) : Q("", !0),
          pe("tbody", null, [
            (p(!0), A(ve, null, $e(F.value, (x, De) => (p(), A(ve, {
              key: x.key
            }, [
              x.hidden ? Q("", !0) : (p(), A("tr", {
                key: 0,
                class: N(xl(x)),
                draggable: bl.value,
                "aria-rowindex": T.value + De + 1,
                onClick: (ie) => Z(x, ie),
                onDblclick: (ie) => b.$emit("dblclick", x.value, x.index, ie),
                onMouseenter: (ie) => b.$emit(
                  "mouseenter",
                  x.value,
                  x.index,
                  ie
                ),
                onMouseleave: (ie) => b.$emit(
                  "mouseleave",
                  x.value,
                  x.index,
                  ie
                ),
                onContextmenu: (ie) => b.$emit(
                  "contextmenu",
                  x.value,
                  x.index,
                  ie
                ),
                onDragstart: (ie) => gl(x, ie),
                onDragend: (ie) => yl(x, ie),
                onDrop: (ie) => Cl(x, ie),
                onDragover: (ie) => hl(x, ie),
                onDragleave: (ie) => kl(x, ie)
              }, [
                D.value ? (p(), A("td", {
                  key: 0,
                  class: N([
                    ...i($a),
                    ...i(Ll)
                  ])
                }, [
                  b.isDetailedVisible(x.value) ? (p(), se(Te, {
                    key: 0,
                    icon: b.detailIcon,
                    pack: b.iconPack,
                    rotation: He(x) ? 90 : 0,
                    role: "button",
                    tabindex: "0",
                    clickable: "",
                    both: "",
                    "aria-label": `Open ${x.label} details`,
                    onClick: re((ie) => le(x), ["prevent"]),
                    onKeydown: [
                      oe(re((ie) => le(x), ["prevent"]), ["enter"]),
                      oe(re((ie) => le(x), ["prevent"]), ["space"])
                    ]
                  }, null, 8, ["icon", "pack", "rotation", "aria-label", "onClick", "onKeydown"])) : Q("", !0)
                ], 2)) : Q("", !0),
                b.checkable && b.checkboxPosition === "left" ? (p(), A("td", {
                  key: 1,
                  class: N([
                    ...i(_e),
                    ...i(Ba)
                  ])
                }, [
                  he(Ft, {
                    "model-value": je(x),
                    autocomplete: "off",
                    name: `row_${x.index}_check`,
                    variant: b.checkboxVariant,
                    disabled: !b.isRowCheckable(x.value),
                    "aria-label": `Check ${x.label}`,
                    "onUpdate:modelValue": (ie) => X(x)
                  }, null, 8, ["model-value", "name", "variant", "disabled", "aria-label", "onUpdate:modelValue"])
                ], 2)) : Q("", !0),
                (p(!0), A(ve, null, $e(v.value, (ie) => (p(), A(ve, {
                  key: ie.identifier
                }, [
                  ie.hidden ? Q("", !0) : (p(), se(i(Mt), fe({
                    key: 0,
                    ref_for: !0
                  }, ie.tdAttrsData[x.index], {
                    component: ie.$el,
                    name: "default",
                    tag: "td",
                    class: [
                      ...i($a),
                      ...ie.tdClasses
                    ],
                    "data-label": ie.label,
                    style: u.value ? {} : ie.style,
                    props: {
                      row: x.value,
                      index: x.index,
                      column: ie.value,
                      colindex: ie.index,
                      toggleDetails: () => le(x)
                    },
                    onClick: (Re) => b.$emit(
                      "cell-click",
                      x.value,
                      ie.value,
                      x.index,
                      ie.index,
                      Re
                    )
                  }), {
                    default: de(() => [
                      Ve(ce(V(x.value, ie)), 1)
                    ]),
                    _: 2
                  }, 1040, ["component", "class", "data-label", "style", "props", "onClick"]))
                ], 64))), 128)),
                b.checkable && b.checkboxPosition === "right" ? (p(), A("td", {
                  key: 2,
                  class: N([
                    ...i(_e),
                    ...i(Ba)
                  ])
                }, [
                  he(Ft, {
                    "model-value": je(x),
                    autocomplete: "off",
                    variant: b.checkboxVariant,
                    disabled: !b.isRowCheckable(x.value),
                    "aria-label": `Check ${x.label}`,
                    "onUpdate:modelValue": (ie) => X(x)
                  }, null, 8, ["model-value", "variant", "disabled", "aria-label", "onUpdate:modelValue"])
                ], 2)) : Q("", !0)
              ], 42, As)),
              e.detailed ? (p(), se(eo, {
                key: 1,
                name: b.detailTransition
              }, {
                default: de(() => [
                  He(x) ? (p(), A(ve, { key: 0 }, [
                    b.customDetailRow ? ae(b.$slots, "detail", {
                      key: 0,
                      row: x.value,
                      index: x.index
                    }) : (p(), A("tr", {
                      key: `${x.key}_detail`,
                      class: N(i(Rl))
                    }, [
                      pe("td", { colspan: I.value }, [
                        ae(b.$slots, "detail", {
                          row: x.value,
                          index: x.index
                        })
                      ], 8, zs)
                    ], 2))
                  ], 64)) : Q("", !0)
                ]),
                _: 2
              }, 1032, ["name"])) : Q("", !0)
            ], 64))), 128)),
            O.value.length ? Q("", !0) : (p(), A("tr", {
              key: 0,
              class: N(i(Tl))
            }, [
              pe("td", { colspan: I.value }, [
                ae(b.$slots, "empty", {}, () => [
                  b.emptyIcon ? (p(), se(Te, {
                    key: 0,
                    icon: b.emptyIcon,
                    size: b.emptyIconSize,
                    pack: b.iconPack,
                    both: ""
                  }, null, 8, ["icon", "size", "pack"])) : Q("", !0),
                  Ve(" " + ce(b.emptyLabel), 1)
                ])
              ], 8, Ts)
            ], 2))
          ]),
          b.$slots.footer ? (p(), A("tfoot", Rs, [
            pe("tr", {
              class: N(i(El))
            }, [
              w() ? ae(b.$slots, "footer", {
                key: 0,
                columnCount: I.value,
                rowCount: S.value
              }) : (p(), A("th", {
                key: 1,
                colspan: I.value
              }, [
                ae(b.$slots, "footer", {
                  columnCount: I.value,
                  rowCount: S.value
                })
              ], 8, Ls))
            ], 2)
          ])) : Q("", !0)
        ], 16, gs)) : Q("", !0),
        ae(b.$slots, "loading", { loading: b.loading }, () => [
          he(Da, fe(b.loadingClasses, {
            "full-page": !1,
            active: b.loading,
            icon: b.loadingIcon,
            label: b.loadingLabel
          }), null, 16, ["active", "icon", "label"])
        ])
      ], 6),
      b.checkable && b.$slots["bottom-left"] || b.paginated && (b.paginationPosition === "bottom" || b.paginationPosition === "both") ? ae(b.$slots, "pagination", {
        key: 2,
        current: h.value,
        perPage: b.perPage,
        total: U.value,
        change: (x) => h.value = x
      }, () => [
        he(La, {
          current: h.value,
          "onUpdate:current": ee[7] || (ee[7] = (x) => h.value = x),
          paginated: b.paginated,
          "per-page": b.perPage,
          total: U.value,
          rounded: b.paginationRounded,
          size: b.paginationSize,
          order: b.paginationOrder,
          simple: b.paginationSimple,
          "icon-pack": b.iconPack,
          "aria-next-label": b.ariaNextLabel,
          "aria-previous-label": b.ariaPreviousLabel,
          "aria-page-label": b.ariaPageLabel,
          "aria-current-label": b.ariaCurrentLabel,
          "root-class": Ia.value,
          onChange: ee[8] || (ee[8] = (x) => b.$emit("page-change", x))
        }, {
          default: de(() => [
            ae(b.$slots, "bottom-left")
          ]),
          _: 3
        }, 8, ["current", "paginated", "per-page", "total", "rounded", "size", "order", "simple", "icon-pack", "aria-next-label", "aria-previous-label", "aria-page-label", "aria-current-label", "root-class"])
      ]) : Q("", !0)
    ], 2));
  }
}), Hs = {
  install(t) {
    Ie(t, Es), Ie(t, vl);
  }
}, Ns = ["id", "data-id", "hidden", "aria-labelledby"], ml = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OTabItem",
  configField: "tabs",
  inheritAttrs: !1,
  __name: "TabItem",
  props: {
    override: { type: Boolean, default: void 0 },
    value: { default: void 0 },
    label: { default: void 0 },
    disabled: { type: Boolean, default: !1 },
    visible: { type: Boolean, default: !0 },
    icon: { default: () => n("tabs.icon") },
    iconPack: { default: () => n("tabs.iconPack") },
    tag: { default: () => n("tabs.itemTag", "button") },
    content: { default: void 0 },
    component: { default: void 0 },
    props: { default: void 0 },
    events: { default: void 0 },
    tabClass: {},
    tabActiveClass: {},
    tabPreviousClass: {},
    tabNextClass: {},
    tabDisabledClass: {},
    tabIconClass: {},
    tabLabelClass: {},
    tabPanelClass: {}
  },
  emits: ["activate", "deactivate"],
  setup(t, { emit: l }) {
    const a = t, e = l, s = a.value ?? Le(), d = vt(), g = o(() => ({
      ...a,
      value: s,
      $slots: d,
      tabClasses: F.value,
      iconClasses: O.value,
      labelClasses: K.value,
      isTransitioning: v.value,
      activate: B,
      deactivate: P
    })), { parent: u, item: c } = pt({
      data: g
    }), y = ne(), f = o(() => c.value.index === u.value.activeIndex), v = ne(!1), I = o(() => {
      const S = u.value.vertical && u.value.animation.length === 4 ? 2 : 0;
      return u.value.animation[S];
    }), C = o(() => {
      const S = u.value.vertical && u.value.animation.length === 4 ? 3 : 1;
      return u.value.animation[S];
    });
    function B(S) {
      y.value = c.value.index < S ? I.value : C.value, e("activate");
    }
    function P(S) {
      y.value = S < c.value.index ? I.value : C.value, e("deactivate");
    }
    function h() {
      v.value = !0;
    }
    function z() {
      v.value = !0;
    }
    const F = M(
      ["tabClass", "o-tabs__tab"],
      ["tabActiveClass", "o-tabs__tab--active", null, f],
      [
        "tabDisabledClass",
        "o-tabs__tab--disabled",
        null,
        o(() => a.disabled)
      ],
      [
        "tabPreviousClass",
        "o-tabs__tab--previous",
        null,
        o(() => {
          var S;
          return c.value.index < ((S = u.value) == null ? void 0 : S.activeIndex);
        })
      ],
      [
        "tabNextClass",
        "o-tabs__tab--next",
        null,
        o(() => {
          var S;
          return c.value.index > ((S = u.value) == null ? void 0 : S.activeIndex);
        })
      ]
    ), O = M(["tabIconClass", "o-tabs__tab-icon"]), K = M(["tabLabelClass", "o-tabs__tab-label"]), U = M(["tabPanelClass", "o-tabs__panel"]);
    return (S, T) => i(u) ? (p(), se(Je, {
      key: 0,
      css: i(u).animated,
      name: y.value,
      appear: i(u).animateInitially,
      onAfterEnter: h,
      onBeforeLeave: z
    }, {
      default: de(() => [
        Be(pe("div", fe(S.$attrs, {
          id: `tabpanel-${i(c).identifier}`,
          "data-oruga": "tabs-item",
          "data-id": `tabs-${i(c).identifier}`,
          class: i(U),
          role: "tabpanel",
          hidden: !f.value,
          "aria-labelledby": `tab-${i(c).identifier}`,
          "aria-roledescription": "item"
        }), [
          ae(S.$slots, "default", {
            active: f.value && S.visible
          }, () => [
            S.component ? (p(), se(xe(S.component), fe({ key: 0 }, S.$props.props, At(S.$props.events || {})), null, 16)) : (p(), A(ve, { key: 1 }, [
              Ve(ce(S.content), 1)
            ], 64))
          ]),
          Q("", !0)
        ], 16, Ns), [
          [Oe, f.value && S.visible]
        ])
      ]),
      _: 3
    }, 8, ["css", "name", "appear"])) : Q("", !0);
  }
}), xs = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OTabs",
  configField: "tabs",
  __name: "Tabs",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    options: { default: void 0 },
    variant: { default: () => n("tabs.variant") },
    size: { default: () => n("tabs.size") },
    vertical: { type: Boolean, default: () => n("tabs.vertical", !1) },
    position: { default: void 0 },
    type: { default: () => n("tabs.type", "default") },
    expanded: { type: Boolean, default: !1 },
    tag: { default: () => n("tabs.tag", "div") },
    activateOnFocus: { type: Boolean, default: !1 },
    animated: { type: Boolean, default: () => n("tabs.animated", !0) },
    animation: { default: () => n("tabs.animation", [
      "slide-next",
      "slide-prev",
      "slide-down",
      "slide-up"
    ]) },
    animateInitially: { type: Boolean, default: () => n("tabs.animateInitially", !1) },
    multiline: { type: Boolean, default: !1 },
    ariaLabel: { default: () => n("tabs.ariaLabel") },
    rootClass: {},
    positionClass: {},
    sizeClass: {},
    typeClass: {},
    expandedClass: {},
    verticalClass: {},
    multilineClass: {},
    listClass: {},
    contentClass: {},
    transitioningClass: {}
  }, {
    modelValue: { default: void 0 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:model-value", "change"], ["update:modelValue"]),
  setup(t, { emit: l }) {
    const a = t, e = l, s = Me("rootElement"), d = o(() => {
      var w;
      return {
        activeIndex: ((w = v.value) == null ? void 0 : w.index) ?? 0,
        type: a.type,
        vertical: a.vertical,
        animated: a.animated,
        animation: a.animation,
        animateInitially: a.animateInitially
      };
    }), { childItems: g } = bt({
      rootRef: s,
      data: d
    }), u = o(() => g.value ? g.value.map((w) => ({
      index: w.index,
      identifier: w.identifier,
      ...Ae(w.data)
    })) : []), { nextSequence: c } = ut(), y = o(
      () => dt(a.options, c)
    ), f = Pe(t, "modelValue");
    be(
      () => a.modelValue,
      (w) => {
        f.value !== w && K(w);
      }
    );
    const v = ne();
    Ot(() => {
      v.value = ke(f.value) && u.value.find((w) => w.value === f.value) || u.value[0];
    });
    const I = o(
      () => u.value.some((w) => w.isTransitioning)
    );
    st(() => {
      var w;
      f.value || (f.value = (w = u.value[0]) == null ? void 0 : w.value);
    });
    function C(w) {
      f.value !== w.value && K(w.value);
    }
    function B(w, V) {
      if (a.vertical && w.key == "ArrowDown" || !a.vertical && w.key == "ArrowRight") {
        const $ = ot(V + 1, u.value.length), Y = O($, !0);
        F(Y);
      }
    }
    function P(w, V) {
      if (a.vertical && w.key == "ArrowUp" || !a.vertical && w.key == "ArrowLeft") {
        const $ = ot(V - 1, u.value.length), Y = O($, !1);
        F(Y);
      }
    }
    function h() {
      if (u.value.length < 1) return;
      const w = O(0, !0);
      F(w);
    }
    function z() {
      if (u.value.length < 1) return;
      const w = O(u.value.length - 1, !1);
      F(w);
    }
    function F(w) {
      var V;
      if (a.activateOnFocus)
        C(w);
      else {
        const $ = (V = s.value) == null ? void 0 : V.querySelector(
          `#tab-${w.identifier}`
        );
        $ == null || $.focus();
      }
    }
    function O(w, V) {
      var E;
      const $ = V ? 1 : -1;
      let Y = w;
      for (; Y !== ((E = v.value) == null ? void 0 : E.index) && !(u.value[Y].visible && !u.value[Y].disabled); Y = ot(Y + $, u.value.length))
        ;
      return u.value[Y];
    }
    function K(w) {
      const V = f.value, $ = v.value, Y = u.value.find((E) => E.value === w) || u.value[0];
      $ && Y && ($.deactivate(Y.index), Y.activate($.index)), ze(() => {
        f.value = w, e("change", w, V);
      });
    }
    const U = M(
      ["rootClass", "o-tabs"],
      [
        "positionClass",
        "o-tabs--",
        o(() => a.position),
        o(() => !!a.position)
      ],
      [
        "sizeClass",
        "o-tabs--",
        o(() => a.size),
        o(() => !!a.size)
      ],
      [
        "typeClass",
        "o-tabs--",
        o(() => a.type),
        o(() => !!a.type)
      ],
      ["expandedClass", "o-tabs--expanded", null, o(() => a.expanded)],
      ["verticalClass", "o-tabs--vertical", null, o(() => a.vertical)],
      [
        "multilineClass",
        "o-tabs--multiline",
        null,
        o(() => a.multiline)
      ]
    ), S = M(["listClass", "o-tabs__list"]), T = M(
      ["contentClass", "o-tabs__content"],
      [
        "transitioningClass",
        "o-tabs__content--transitioning",
        null,
        I
      ]
    );
    return (w, V) => (p(), A("div", {
      ref: "rootElement",
      "data-oruga": "tabs",
      class: N(i(U))
    }, [
      (p(), se(xe(a.tag), {
        class: N(i(S)),
        role: "tablist",
        "aria-label": w.ariaLabel,
        "aria-orientation": w.vertical ? "vertical" : "horizontal"
      }, {
        default: de(() => [
          ae(w.$slots, "before"),
          (p(!0), A(ve, null, $e(u.value, ($) => {
            var Y, E, Z;
            return Be((p(), se(i(Mt), {
              id: `tab-${$.identifier}`,
              key: $.identifier,
              component: $,
              tag: $.tag,
              name: "header",
              class: N($.tabClasses),
              role: "tab",
              tabindex: $.value === ((Y = v.value) == null ? void 0 : Y.value) ? 0 : -1,
              "aria-current": $.value === ((E = v.value) == null ? void 0 : E.value) ? "true" : void 0,
              "aria-controls": `tabpanel-${$.identifier}`,
              "aria-selected": $.value === ((Z = v.value) == null ? void 0 : Z.value),
              onClick: (_) => C($),
              onKeydown: [
                oe(re((_) => C($), ["prevent"]), ["enter"]),
                oe(re((_) => C($), ["prevent"]), ["space"]),
                oe(re((_) => P(_, $.index), ["prevent"]), ["left"]),
                oe(re((_) => B(_, $.index), ["prevent"]), ["right"]),
                oe(re((_) => P(_, $.index), ["prevent"]), ["up"]),
                oe(re((_) => B(_, $.index), ["prevent"]), ["down"]),
                oe(re(h, ["prevent"]), ["home"]),
                oe(re(z, ["prevent"]), ["end"])
              ]
            }, {
              default: de(() => [
                $.icon ? (p(), se(Te, {
                  key: 0,
                  class: N($.iconClasses),
                  icon: $.icon,
                  pack: $.iconPack,
                  size: w.size
                }, null, 8, ["class", "icon", "pack", "size"])) : Q("", !0),
                pe("span", {
                  class: N($.labelClasses)
                }, ce($.label), 3)
              ]),
              _: 2
            }, 1032, ["id", "component", "tag", "class", "tabindex", "aria-current", "aria-controls", "aria-selected", "onClick", "onKeydown"])), [
              [Oe, $.visible]
            ]);
          }), 128)),
          ae(w.$slots, "after")
        ]),
        _: 3
      }, 8, ["class", "aria-label", "aria-orientation"])),
      pe("section", {
        class: N(i(T))
      }, [
        ae(w.$slots, "default", {}, () => [
          (p(!0), A(ve, null, $e(y.value, ($) => Be((p(), se(ml, fe({ ref_for: !0 }, $.attrs, {
            key: $.key,
            value: $.value,
            label: $.label
          }), null, 16, ["value", "label"])), [
            [Oe, !$.hidden]
          ])), 128))
        ])
      ], 2)
    ], 2));
  }
}), Ys = {
  install(t) {
    Ie(t, xs), Ie(t, ml);
  }
}, Ws = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OTaginput",
  configField: "taginput",
  inheritAttrs: !1,
  __name: "Taginput",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    input: { default: "" },
    options: { default: void 0 },
    filter: { type: Function, default: void 0 },
    size: { default: () => n("taginput.size") },
    variant: { default: () => n("taginput.variant") },
    maxitems: { default: void 0 },
    maxlength: { default: void 0 },
    counter: { type: Boolean, default: () => n("taginput.counter", !0) },
    openOnFocus: { type: Boolean, default: () => n("taginput.openOnFocus", !0) },
    keepOpen: { type: Boolean, default: () => n("taginput.keepOpen", !1) },
    placeholder: { default: void 0 },
    expanded: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    keepFirst: { type: Boolean, default: () => n("taginput.keepFirst", !1) },
    allowNew: { type: Boolean, default: () => n("taginput.allowNew", !1) },
    allowDuplicates: { type: Boolean, default: () => n("taginput.allowDuplicates", !1) },
    validateItem: { type: Function, default: () => !0 },
    createItem: { type: Function, default: (t) => t },
    checkScroll: { type: Boolean, default: () => n("taginput.checkScroll", !1) },
    closable: { type: Boolean, default: () => n("taginput.closable", !0) },
    iconPack: { default: () => n("taginput.iconPack") },
    icon: { default: () => n("taginput.icon") },
    closeIcon: { default: () => n("taginput.closeIcon", "close") },
    ariaCloseLabel: { default: () => n("taginput.ariaCloseLabel", "Remove") },
    autocomplete: { default: () => n("taginput.autocomplete", "off") },
    useHtml5Validation: { type: Boolean, default: () => n("useHtml5Validation", !0) },
    customValidity: { type: [String, Function], default: void 0 },
    teleport: { type: [Boolean, String, Object], default: () => n("taginput.teleport", !1) },
    rootClass: {},
    expandedClass: {},
    sizeClass: {},
    variantClass: {},
    containerClass: {},
    itemClass: {},
    closeClass: {},
    counterClass: {},
    autocompleteClasses: { default: () => n("taginput.autocompleteClasses", {}) }
  }, {
    modelValue: { default: void 0 },
    modelModifiers: {},
    input: { default: "" },
    inputModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:model-value", "update:input", "input", "add", "remove", "focus", "blur", "invalid", "icon-click", "icon-right-click", "scroll-start", "scroll-end"], ["update:modelValue", "update:input"]),
  setup(t, { expose: l, emit: a }) {
    const e = t, s = a, d = Me("autocompleteComponent"), { setFocus: g, onFocus: u, onBlur: c, onInvalid: y } = et(
      d,
      s,
      e
    ), f = ne(!1), v = Pe(t, "modelValue"), I = Pe(t, "input"), C = o(() => I.value.trim().length), B = o(() => {
      var m;
      return ((m = v.value) == null ? void 0 : m.length) || 0;
    }), { nextSequence: P } = ut(), h = o(() => {
      const m = dt(e.options, P);
      return ha(m, P());
    }), z = o(() => v.value ? v.value.map((m) => {
      const R = Zt(h, m);
      return R || { label: m, value: m, key: Le() };
    }) : []), F = o(
      () => e.maxitems == null || B.value < Number(e.maxitems)
    );
    Ot(() => {
      F.value || c(new Event("blur"));
    });
    function O(m) {
      var R;
      if (m = m || I.value.trim(), m) {
        const L = e.createItem(m);
        (R = v.value) != null && R.length ? (e.allowDuplicates || !v.value.includes(L)) && e.validateItem(m) && (v.value = [...v.value, L], s("add", L)) : e.validateItem(m) && (v.value = [L], s("add", L));
      }
      requestAnimationFrame(() => {
        I.value = "", s("input", "", new Event("input"));
      });
    }
    function K(m, R) {
      var te;
      if (!((te = v.value) != null && te.length)) return;
      const L = v.value.at(m);
      L && (v.value = v.value.toSpliced(m, 1), s("remove", L), R && R.stopPropagation(), e.openOnFocus && d.value && g());
    }
    function U(m) {
      m && O(m);
    }
    function S(m, R) {
      s("input", m == null ? void 0 : m.trim(), R);
    }
    function T() {
      var m;
      !((m = I.value) != null && m.length) && B.value > 0 && K(B.value - 1);
    }
    function w() {
      e.allowNew && !f.value && O();
    }
    const V = M(
      ["rootClass", "o-taginput"],
      [
        "sizeClass",
        "o-taginput--",
        o(() => e.size),
        o(() => !!e.size)
      ],
      [
        "variantClass",
        "o-taginput--",
        o(() => e.variant),
        o(() => !!e.variant)
      ],
      [
        "expandedClass",
        "o-taginput--expanded",
        null,
        o(() => e.expanded)
      ]
    ), $ = M([
      "containerClass",
      "o-taginput__container"
    ]), Y = M(
      ["itemClass", "o-taginput__item"],
      [
        "variantClass",
        "o-taginput__item--",
        o(() => e.variant),
        o(() => !!e.variant)
      ]
    ), E = M(["closeClass", "o-taginput__item__close"]), Z = M(["counterClass", "o-taginput__counter"]), _ = M([
      "autocompleteClasses.rootClass",
      "o-taginput__autocomplete"
    ]), q = M([
      "autocompleteClasses.inputClasses.inputClass",
      "o-taginput__input"
    ]), k = it(), r = o(() => ({
      ...k,
      "root-class": Ke(_),
      "input-classes": {
        "input-class": Ke(q)
      },
      ...e.autocompleteClasses
    }));
    return l({ focus: g, value: v }), (m, R) => (p(), A("div", {
      "data-oruga": "taginput",
      class: N(i(V))
    }, [
      pe("div", {
        class: N(i($)),
        onFocus: R[6] || (R[6] = //@ts-ignore
        (...L) => i(u) && i(u)(...L)),
        onBlur: R[7] || (R[7] = //@ts-ignore
        (...L) => i(c) && i(c)(...L))
      }, [
        ae(m.$slots, "selected", {
          items: v.value,
          options: z.value,
          removeItem: K
        }, () => [
          (p(!0), A(ve, null, $e(z.value, (L, te) => (p(), A("span", {
            key: L.key,
            class: N(i(Y))
          }, [
            pe("span", null, ce(L.label), 1),
            m.closable && !m.disabled ? (p(), se(Te, {
              key: 0,
              class: N(i(E)),
              pack: m.iconPack,
              icon: m.closeIcon,
              clickable: "",
              tabindex: "0",
              role: "button",
              "aria-label": m.ariaCloseLabel,
              both: "",
              onKeydown: oe((W) => K(te, W), ["enter"]),
              onClick: (W) => K(te, W)
            }, null, 8, ["class", "pack", "icon", "aria-label", "onKeydown", "onClick"])) : Q("", !0)
          ], 2))), 128))
        ]),
        Be(he(al, fe({
          ref: "autocompleteComponent",
          active: f.value,
          "onUpdate:active": R[0] || (R[0] = (L) => f.value = L),
          input: I.value,
          "onUpdate:input": R[1] || (R[1] = (L) => I.value = L)
        }, r.value, {
          options: m.options,
          filter: m.filter,
          placeholder: m.placeholder,
          icon: m.icon,
          "icon-pack": m.iconPack,
          maxlength: m.maxlength,
          size: m.size,
          disabled: m.disabled,
          autocomplete: m.autocomplete,
          "open-on-focus": m.openOnFocus,
          "keep-first": m.keepFirst,
          "keep-open": m.keepOpen,
          "check-scroll": m.checkScroll,
          teleport: m.teleport,
          "has-counter": !1,
          "use-html5-validation": !1,
          expanded: "",
          onInput: S,
          onFocus: i(u),
          onBlur: i(c),
          onInvalid: i(y),
          onKeydown: [
            oe(w, ["enter"]),
            oe(w, ["tab"]),
            oe(T, ["backspace"])
          ],
          onSelect: U,
          onScrollStart: R[2] || (R[2] = (L) => m.$emit("scroll-start")),
          onScrollEnd: R[3] || (R[3] = (L) => m.$emit("scroll-end")),
          onIconClick: R[4] || (R[4] = (L) => m.$emit("icon-click", L)),
          onIconRightClick: R[5] || (R[5] = (L) => m.$emit("icon-right-click", L))
        }), Vt({ _: 2 }, [
          m.$slots.header ? {
            name: "header",
            fn: de(() => [
              ae(m.$slots, "header")
            ]),
            key: "0"
          } : void 0,
          m.$slots.default ? {
            name: "default",
            fn: de(({ option: L, index: te, value: W }) => [
              ae(m.$slots, "default", {
                option: L,
                index: te,
                value: W
              })
            ]),
            key: "1"
          } : void 0,
          m.$slots.empty ? {
            name: "empty",
            fn: de(() => [
              ae(m.$slots, "empty")
            ]),
            key: "2"
          } : void 0,
          m.$slots.footer ? {
            name: "footer",
            fn: de(() => [
              ae(m.$slots, "footer")
            ]),
            key: "3"
          } : void 0
        ]), 1040, ["active", "input", "options", "filter", "placeholder", "icon", "icon-pack", "maxlength", "size", "disabled", "autocomplete", "open-on-focus", "keep-first", "keep-open", "check-scroll", "teleport", "onFocus", "onBlur", "onInvalid"]), [
          [Oe, F.value]
        ])
      ], 34),
      m.counter && (m.maxitems || m.maxlength) ? (p(), A("small", {
        key: 0,
        class: N(i(Z))
      }, [
        m.maxlength && C.value > 0 ? ae(m.$slots, "counter", {
          key: 0,
          items: C.value,
          total: m.maxlength
        }, () => [
          Ve(ce(C.value) + " / " + ce(m.maxlength), 1)
        ]) : m.maxitems ? ae(m.$slots, "counter", {
          key: 1,
          items: B.value,
          total: m.maxitems
        }, () => [
          Ve(ce(B.value) + " / " + ce(m.maxitems), 1)
        ]) : Q("", !0)
      ], 2)) : Q("", !0)
    ], 2));
  }
}), Ks = {
  install(t) {
    Ie(t, Ws);
  }
}, Us = {
  install(t) {
    Ie(t, nl);
  }
}, qs = {
  install(t) {
    Ie(t, cl);
  }
}, js = ["multiple", "accept", "disabled"], Xs = /* @__PURE__ */ Ce({
  isOruga: !0,
  name: "OUpload",
  configField: "upload",
  inheritAttrs: !1,
  __name: "Upload",
  props: /* @__PURE__ */ ge({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    multiple: {},
    variant: { default: () => n("upload.variant") },
    disabled: { type: Boolean, default: !1 },
    accept: { default: void 0 },
    dragDrop: { type: Boolean, default: !1 },
    expanded: { type: Boolean, default: !1 },
    native: { type: Boolean, default: !0 },
    useHtml5Validation: { type: Boolean, default: () => n("useHtml5Validation", !0) },
    customValidity: { type: [String, Function], default: "" },
    rootClass: {},
    expandedClass: {},
    variantClass: {},
    draggableClass: {},
    disabledClass: {},
    hoveredClass: {}
  }, {
    modelValue: { default: void 0 },
    modelModifiers: {}
  }),
  emits: /* @__PURE__ */ ge(["update:model-value", "focus", "blur", "invalid"], ["update:modelValue"]),
  setup(t, { expose: l, emit: a }) {
    const e = t, s = a, d = Me("inputElement"), { checkHtml5Validity: g, onFocus: u, onBlur: c, onInvalid: y, isValid: f, setFocus: v } = et(d, s, e), { parentField: I } = Ge(), C = Pe(t, "modelValue"), B = ne(!1);
    be(C, (w) => {
      (!w || Array.isArray(w) && w.length === 0) && d.value && (d.value.value = ""), !f.value && !e.dragDrop && g();
    });
    function P(w) {
      var $;
      if (e.disabled) return;
      e.dragDrop && z(!1);
      const V = w.target.files || (($ = w.dataTransfer) == null ? void 0 : $.files) || [];
      if (V.length === 0) {
        if (!C.value) return;
        e.native && (C.value = void 0);
      }
      if (we(e.multiple)) {
        const Y = e.native || !C.value || !Array.isArray(C.value) ? [] : [...C.value];
        for (let E = 0; E < V.length; E++) {
          const Z = V[E];
          F(Z) && Y.push(Z);
        }
        C.value = Y;
      } else {
        if (e.dragDrop && V.length !== 1) return;
        {
          const Y = V[0];
          if (F(Y)) C.value = Y;
          else if (C.value)
            C.value = void 0, h();
          else {
            h(), g();
            return;
          }
        }
      }
      e.dragDrop || g();
    }
    function h() {
      d.value && (d.value.value = "");
    }
    function z(w) {
      e.disabled || (B.value = w);
    }
    function F(w) {
      if (!e.accept) return !0;
      const V = e.accept.split(",");
      if (V.length === 0) return !0;
      for (let $ = 0; $ < V.length; $++) {
        const Y = V[$].trim();
        if (Y) {
          if (Y.substring(0, 1) === ".") {
            if (w.name.toLowerCase().slice(-Y.length) === Y.toLowerCase()) return !0;
          } else if (w.type.match(Y)) return !0;
        }
      }
      return !1;
    }
    function O(w) {
      e.disabled || e.dragDrop || (w.preventDefault(), d.value && d.value.click());
    }
    const K = it(), U = o(() => {
      var w;
      return {
        ...(w = I == null ? void 0 : I.value) == null ? void 0 : w.inputAttrs,
        ...K
      };
    }), S = M(
      ["rootClass", "o-upload"],
      [
        "expandedClass",
        "o-upload--expanded",
        null,
        o(() => e.expanded)
      ],
      [
        "disabledClass",
        "o-upload--disabled",
        null,
        o(() => e.disabled)
      ]
    ), T = M(
      ["draggableClass", "o-upload__draggable"],
      [
        "hoveredClass",
        "o-upload__draggable--hovered",
        null,
        o(() => !e.variant && B.value)
      ],
      [
        "variantClass",
        "o-upload__draggable--hovered-",
        o(() => e.variant),
        o(() => !!e.variant && B.value)
      ]
    );
    return l({ focus: v, value: C }), (w, V) => (p(), A("label", {
      "data-oruga": "upload",
      class: N(i(S))
    }, [
      w.dragDrop ? (p(), A("div", {
        key: 1,
        class: N(i(T)),
        role: "button",
        tabindex: "0",
        onMouseenter: V[0] || (V[0] = ($) => z(!0)),
        onMouseleave: V[1] || (V[1] = ($) => z(!1)),
        onDragover: V[2] || (V[2] = re(($) => z(!0), ["prevent"])),
        onDragleave: V[3] || (V[3] = re(($) => z(!1), ["prevent"])),
        onDragenter: V[4] || (V[4] = re(($) => z(!0), ["prevent"])),
        onDrop: re(P, ["prevent"])
      }, [
        ae(w.$slots, "default", { onclick: O })
      ], 34)) : ae(w.$slots, "default", {
        key: 0,
        onclick: O
      }),
      pe("input", fe(U.value, {
        ref: "inputElement",
        type: "file",
        "data-oruga-input": "file",
        multiple: e.multiple,
        accept: w.accept,
        disabled: w.disabled,
        onChange: P,
        onFocus: V[5] || (V[5] = //@ts-ignore
        (...$) => i(u) && i(u)(...$)),
        onBlur: V[6] || (V[6] = //@ts-ignore
        (...$) => i(c) && i(c)(...$)),
        onInvalid: V[7] || (V[7] = //@ts-ignore
        (...$) => i(y) && i(y)(...$))
      }), null, 16, js)
    ], 2));
  }
}), Gs = {
  install(t) {
    Ie(t, Xs);
  }
}, Ea = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Autocomplete: Io,
  Button: Fo,
  Carousel: Ro,
  Checkbox: Ho,
  Collapse: Wo,
  Datepicker: sn,
  Datetimepicker: bn,
  Dropdown: gn,
  Field: hn,
  Icon: kn,
  Input: wn,
  Loading: $n,
  Menu: Vn,
  Modal: Rn,
  Notification: xn,
  Pagination: Yn,
  Programmatic: Dn,
  Radio: qn,
  Select: jn,
  Sidebar: Jn,
  Skeleton: Gn,
  Slider: as,
  Steps: rs,
  Switch: fs,
  Table: Hs,
  Tabs: Ys,
  Taginput: Ks,
  Timepicker: Us,
  Tooltip: qs,
  Upload: Gs
}, Symbol.toStringTag, { value: "Module" })), ti = {
  install(t, l = {}) {
    t.use(co, l);
    for (const a in Ea)
      io(t, Ea[a]);
    $t(t, "config", uo);
  }
};
export {
  Io as Autocomplete,
  Fo as Button,
  Ro as Carousel,
  Ho as Checkbox,
  Wo as Collapse,
  Rt as ComponentProgrammatic,
  uo as ConfigProgrammatic,
  sn as Datepicker,
  bn as Datetimepicker,
  gn as Dropdown,
  hn as Field,
  kn as Icon,
  wn as Input,
  Tt as InstanceRegistry,
  $n as Loading,
  Sn as LoadingProgrammatic,
  Vn as Menu,
  Rn as Modal,
  Tn as ModalProgrammatic,
  xn as Notification,
  Nn as NotificationProgrammatic,
  al as OAutocomplete,
  Dt as OButton,
  Ao as OCarousel,
  To as OCarouselItem,
  Ft as OCheckbox,
  Yo as OCollapse,
  ol as ODatepicker,
  mn as ODatetimepicker,
  wa as ODropdown,
  at as ODropdownItem,
  sl as OField,
  Te as OIcon,
  Pt as OInput,
  Da as OLoading,
  On as OMenu,
  jt as OMenuItem,
  il as OModal,
  rl as ONotification,
  ul as OPagination,
  Un as ORadio,
  ft as OSelect,
  dl as OSidebar,
  Xn as OSkeleton,
  ts as OSlider,
  fl as OSliderTick,
  pl as OStepItem,
  is as OSteps,
  cs as OSwitch,
  ml as OTabItem,
  Es as OTable,
  vl as OTableColumn,
  xs as OTabs,
  Ws as OTaginput,
  nl as OTimepicker,
  cl as OTooltip,
  Xs as OUpload,
  ti as Oruga,
  co as OrugaConfig,
  Yn as Pagination,
  Dn as Programmatic,
  qn as Radio,
  jn as Select,
  Jn as Sidebar,
  Qn as SidebarProgrammatic,
  Gn as Skeleton,
  as as Slider,
  rs as Steps,
  fs as Switch,
  Hs as Table,
  Ys as Tabs,
  Ks as Taginput,
  Us as Timepicker,
  qs as Tooltip,
  Gs as Upload,
  kt as blankIfUndefined,
  Oa as bound,
  ti as default,
  Zs as defaultIfUndefined,
  oo as escapeRegExpChars,
  ia as getPropertyValue,
  Ye as getValueByPath,
  lt as isDate,
  ke as isDefined,
  _s as isElement,
  Qt as isEqual,
  ct as isMobileAgent,
  qe as isObject,
  we as isTrueish,
  qa as isVNodeEmpty,
  ya as merge,
  Ka as mergeDeep,
  ot as mod,
  tt as pad,
  Va as removeDiacriticsFromString,
  ei as removeElement,
  Ua as setValueByPath,
  ao as sign,
  lo as sortBy,
  wt as toCssDimension,
  so as useOruga
};
//# sourceMappingURL=oruga.mjs.map
