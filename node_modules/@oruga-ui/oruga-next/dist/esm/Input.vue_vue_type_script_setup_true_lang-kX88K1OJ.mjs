/*! Oruga v0.10.5 | MIT License | github.com/oruga-ui/oruga */
import { defineComponent, mergeModels, useTemplateRef, useModel, computed, onMounted, watch, ref, nextTick, useAttrs, createElementBlock, openBlock, normalizeClass, unref, createBlock, createCommentVNode, withDirectives, mergeProps, vModelDynamic, vModelText, toDisplayString, useId } from "vue";
import { _ as _sfc_main$1 } from "./Icon.vue_vue_type_script_setup_true_lang-v4MwBFqk.mjs";
import { g as getDefault } from "./config-B-gWlaT6.mjs";
import { isDefined, isTrueish } from "./helpers.mjs";
import { d as defineClasses } from "./defineClasses-BApkclKh.mjs";
import { u as useInputHandler } from "./useInputHandler-B842u-_G.mjs";
import { u as useDebounce } from "./useDebounce-b4Z66lnw.mjs";
import { i as injectField } from "./fieldInjection-Bs3TBpgZ.mjs";
const _hoisted_1 = ["id", "type", "data-oruga-input", "maxlength", "autocomplete", "placeholder", "disabled"];
const _hoisted_2 = ["id", "maxlength", "placeholder", "disabled"];
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    isOruga: true,
    name: "OInput",
    configField: "input",
    inheritAttrs: false
  },
  __name: "Input",
  props: /* @__PURE__ */ mergeModels({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    number: {},
    type: { default: "text" },
    size: { default: () => getDefault("input.size") },
    variant: { default: () => getDefault("input.variant") },
    placeholder: { default: void 0 },
    expanded: { type: Boolean, default: false },
    rounded: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    passwordReveal: { type: Boolean, default: false },
    maxlength: { default: void 0 },
    counter: { type: Boolean, default: () => getDefault("input.counter", false) },
    autosize: { type: Boolean, default: false },
    iconPack: { default: () => getDefault("input.iconPack") },
    icon: { default: () => getDefault("input.icon") },
    iconClickable: { type: Boolean, default: false },
    iconRight: { default: () => getDefault("input.iconRight") },
    iconRightClickable: { type: Boolean, default: false },
    iconRightVariant: { default: void 0 },
    clearable: { type: Boolean, default: () => getDefault("input.clearable", false) },
    clearIcon: { default: () => getDefault("input.clearIcon", "close-circle") },
    statusIcon: { type: Boolean, default: () => getDefault("statusIcon", true) },
    debounce: { default: () => getDefault("autocomplete.debounce", 400) },
    autocomplete: { default: () => getDefault("input.autocomplete", "off") },
    id: { default: () => useId() },
    useHtml5Validation: { type: Boolean, default: () => getDefault("useHtml5Validation", true) },
    customValidity: { type: [String, Function], default: "" },
    rootClass: {},
    sizeClass: {},
    variantClass: {},
    expandedClass: {},
    roundedClass: {},
    disabledClass: {},
    textareaClass: {},
    hasIconRightClass: {},
    inputClass: {},
    iconLeftSpaceClass: {},
    iconRightSpaceClass: {},
    placeholderClass: {},
    iconLeftClass: {},
    iconRightClass: {},
    counterClass: {}
  }, {
    "modelValue": {
      // cast incomming value to string
      default: void 0
    },
    "modelModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["update:model-value", "input", "focus", "blur", "invalid", "icon-click", "icon-right-click"], ["update:modelValue"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    var _a;
    const props = __props;
    const emits = __emit;
    const inputRef = useTemplateRef("inputElement");
    const {
      checkHtml5Validity,
      onBlur,
      onFocus,
      onInvalid,
      setFocus,
      isValid,
      isFocused
    } = useInputHandler(inputRef, emits, props);
    const { parentField, statusVariant, statusVariantIcon } = injectField();
    const vmodel = useModel(__props, "modelValue", {
      // cast incomming value to string
      get: (value) => isDefined(value) ? String(value) : "",
      // cast outgoing value to number if prop number is true
      set: (value) => !isDefined(value) ? value : isTrueish(props.number) ? Number(value) : String(value)
    });
    if (props.id) (_a = parentField == null ? void 0 : parentField.value) == null ? void 0 : _a.setInputId(props.id);
    const valueLength = computed(
      () => typeof vmodel.value === "string" || typeof vmodel.value === "number" ? String(vmodel.value).length : 0
    );
    onMounted(() => {
      watch(
        () => vmodel.value,
        (value) => {
          if (parentField == null ? void 0 : parentField.value) parentField.value.setFilled(!!value);
          if (props.autosize) resize();
          if (!isValid.value) checkHtml5Validity();
        },
        { immediate: true, flush: "post" }
      );
    });
    const height = ref("auto");
    function resize() {
      height.value = "auto";
      nextTick(() => {
        if (props.type !== "textarea" || !inputRef.value) return;
        const scrollHeight = inputRef.value.scrollHeight;
        height.value = scrollHeight + "px";
      });
    }
    const computedStyles = computed(
      () => props.type === "textarea" && props.autosize ? {
        resize: "none",
        height: height.value,
        overflow: "hidden"
      } : {}
    );
    let debouncedInput;
    watch(
      () => props.debounce,
      (debounce) => debouncedInput = useDebounce(onInput, debounce || 0),
      { immediate: true }
    );
    function onInput(event) {
      emits("input", vmodel.value, event);
    }
    const placeholderVisible = computed(
      () => !isDefined(vmodel.value) || vmodel.value === ""
    );
    const hasIconRight = computed(() => {
      return !!(props.passwordReveal || props.statusIcon && statusVariantIcon.value || props.clearable && vmodel.value && props.clearIcon || props.iconRight);
    });
    const computedIconRight = computed(() => {
      if (props.passwordReveal) return passwordVisibleIcon.value;
      else if (props.clearable && vmodel.value && props.clearIcon)
        return props.clearIcon;
      else if (props.iconRight) return props.iconRight;
      return statusVariantIcon.value;
    });
    const computedIconRightVariant = computed(
      () => props.passwordReveal || props.iconRight ? props.iconRightVariant || props.variant : statusVariant.value
    );
    function iconClick(event) {
      emits("icon-click", event);
      nextTick(() => setFocus());
    }
    function rightIconClick(event) {
      if (props.passwordReveal) togglePasswordVisibility();
      else if (props.clearable)
        vmodel.value = isTrueish(props.number) ? 0 : "";
      if (props.iconRightClickable) {
        emits("icon-right-click", event);
        nextTick(() => setFocus());
      }
    }
    const isPasswordVisible = ref(false);
    const inputType = computed(() => {
      if (props.passwordReveal)
        return isPasswordVisible.value ? "text" : "password";
      else return props.type;
    });
    const passwordVisibleIcon = computed(
      () => !isPasswordVisible.value ? "eye" : "eye-off"
    );
    function togglePasswordVisibility() {
      isPasswordVisible.value = !isPasswordVisible.value;
      nextTick(() => setFocus());
    }
    const attrs = useAttrs();
    const inputBind = computed(() => {
      var _a2;
      return {
        ...(_a2 = parentField == null ? void 0 : parentField.value) == null ? void 0 : _a2.inputAttrs,
        ...attrs
      };
    });
    const rootClasses = defineClasses(
      ["rootClass", "o-input"],
      [
        "sizeClass",
        "o-input--",
        computed(() => props.size),
        computed(() => !!props.size)
      ],
      [
        "variantClass",
        "o-input--",
        computed(() => statusVariant.value || props.variant),
        computed(() => !!statusVariant.value || !!props.variant)
      ],
      [
        "expandedClass",
        "o-input--expanded",
        null,
        computed(() => props.expanded)
      ],
      [
        "disabledClass",
        "o-input--disabled",
        null,
        computed(() => props.disabled)
      ],
      ["roundedClass", "o-input--rounded", null, computed(() => props.rounded)],
      ["hasIconRightClass", "o-input--icon-right", null, hasIconRight],
      [
        "textareaClass",
        "o-input--textarea",
        null,
        computed(() => props.type === "textarea")
      ]
    );
    const inputClasses = defineClasses(
      ["inputClass", "o-input__input"],
      [
        "iconLeftSpaceClass",
        "o-input__input--iconspace-left",
        null,
        computed(() => !!props.icon)
      ],
      [
        "iconRightSpaceClass",
        "o-input__input--iconspace-right",
        null,
        hasIconRight
      ],
      [
        "placeholderClass",
        "o-input__input--placeholder",
        null,
        placeholderVisible
      ]
    );
    const iconLeftClasses = defineClasses(["iconLeftClass", "o-input__icon-left"]);
    const iconRightClasses = defineClasses([
      "iconRightClass",
      "o-input__icon-right"
    ]);
    const counterClasses = defineClasses(["counterClass", "o-input__counter"]);
    __expose({ focus: setFocus, value: vmodel });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        "data-oruga": "input",
        class: normalizeClass(unref(rootClasses))
      }, [
        _ctx.icon ? (openBlock(), createBlock(_sfc_main$1, {
          key: 0,
          class: normalizeClass(unref(iconLeftClasses)),
          clickable: _ctx.iconClickable,
          icon: _ctx.icon,
          pack: _ctx.iconPack,
          size: _ctx.size,
          onClick: iconClick
        }, null, 8, ["class", "clickable", "icon", "pack", "size"])) : createCommentVNode("", true),
        _ctx.type !== "textarea" ? withDirectives((openBlock(), createElementBlock("input", mergeProps({ key: 1 }, inputBind.value, {
          id: _ctx.id,
          ref: "inputElement",
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => vmodel.value = $event),
          type: inputType.value,
          "data-oruga-input": inputType.value,
          class: unref(inputClasses),
          maxlength: _ctx.maxlength,
          autocomplete: _ctx.autocomplete,
          placeholder: _ctx.placeholder,
          disabled: _ctx.disabled,
          onBlur: _cache[1] || (_cache[1] = //@ts-ignore
          (...args) => unref(onBlur) && unref(onBlur)(...args)),
          onFocus: _cache[2] || (_cache[2] = //@ts-ignore
          (...args) => unref(onFocus) && unref(onFocus)(...args)),
          onInvalid: _cache[3] || (_cache[3] = //@ts-ignore
          (...args) => unref(onInvalid) && unref(onInvalid)(...args)),
          onInput: _cache[4] || (_cache[4] = //@ts-ignore
          (...args) => unref(debouncedInput) && unref(debouncedInput)(...args))
        }), null, 16, _hoisted_1)), [
          [vModelDynamic, vmodel.value]
        ]) : withDirectives((openBlock(), createElementBlock("textarea", mergeProps({ key: 2 }, inputBind.value, {
          id: _ctx.id,
          ref: "inputElement",
          "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => vmodel.value = $event),
          "data-oruga-input": "textarea",
          class: unref(inputClasses),
          maxlength: _ctx.maxlength,
          style: computedStyles.value,
          placeholder: _ctx.placeholder,
          disabled: _ctx.disabled,
          onBlur: _cache[6] || (_cache[6] = //@ts-ignore
          (...args) => unref(onBlur) && unref(onBlur)(...args)),
          onFocus: _cache[7] || (_cache[7] = //@ts-ignore
          (...args) => unref(onFocus) && unref(onFocus)(...args)),
          onInvalid: _cache[8] || (_cache[8] = //@ts-ignore
          (...args) => unref(onInvalid) && unref(onInvalid)(...args)),
          onInput: _cache[9] || (_cache[9] = //@ts-ignore
          (...args) => unref(debouncedInput) && unref(debouncedInput)(...args))
        }), null, 16, _hoisted_2)), [
          [vModelText, vmodel.value]
        ]),
        hasIconRight.value ? (openBlock(), createBlock(_sfc_main$1, {
          key: 3,
          class: normalizeClass(unref(iconRightClasses)),
          clickable: _ctx.passwordReveal || _ctx.clearable || _ctx.iconRightClickable,
          icon: computedIconRight.value,
          pack: _ctx.iconPack,
          size: _ctx.size,
          variant: computedIconRightVariant.value,
          both: "",
          onClick: rightIconClick
        }, null, 8, ["class", "clickable", "icon", "pack", "size", "variant"])) : createCommentVNode("", true),
        _ctx.maxlength && _ctx.counter && unref(isFocused) && _ctx.type !== "number" ? (openBlock(), createElementBlock("small", {
          key: 4,
          class: normalizeClass(unref(counterClasses))
        }, toDisplayString(valueLength.value) + " / " + toDisplayString(_ctx.maxlength), 3)) : createCommentVNode("", true)
      ], 2);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=Input.vue_vue_type_script_setup_true_lang-kX88K1OJ.mjs.map
