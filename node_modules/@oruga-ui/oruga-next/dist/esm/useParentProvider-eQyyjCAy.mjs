/*! Oruga v0.10.5 | MIT License | github.com/oruga-ui/oruga */
import { getCurrentInstance, ref, watch, provide, inject, onUnmounted } from "vue";
import { u as unrefElement } from "./unrefElement-BpUk-iXz.mjs";
import { u as useDebounce } from "./useDebounce-b4Z66lnw.mjs";
import { u as useSequentialId } from "./useSequentialId-aw-jeTgs.mjs";
function useProviderParent(options) {
  var _a;
  const vm = getCurrentInstance();
  if (!vm)
    throw new Error(
      "useProviderChild must be called within a component setup function."
    );
  const configField = (_a = vm.proxy) == null ? void 0 : _a.$options.configField;
  const key = (options == null ? void 0 : options.key) || configField;
  const childItems = ref([]);
  if (options == null ? void 0 : options.rootRef) {
    const sortHandler = useDebounce((items) => {
      const parent = unrefElement(options.rootRef);
      if (!parent) return;
      const ids = items.map((item) => `[data-id="${key}-${item.identifier}"]`).join(",");
      const children = parent.querySelectorAll(ids);
      const sortedIds = Array.from(children).map(
        (el) => {
          var _a2;
          return (_a2 = el.getAttribute("data-id")) == null ? void 0 : _a2.replace(`${key}-`, "");
        }
      );
      items.forEach(
        (item) => item.index = sortedIds.indexOf(`${item.identifier}`)
      );
      items.sort((a, b) => a.index - b.index);
    }, 500);
    watch(childItems, sortHandler);
  }
  const { nextSequence } = useSequentialId(1);
  function registerItem(data) {
    const index = childItems.value.length;
    const identifier = nextSequence();
    const item = { index, data, identifier };
    childItems.value = [
      ...childItems.value,
      item
    ];
    return item;
  }
  function unregisterItem(item) {
    childItems.value = childItems.value.filter((i) => i !== item);
  }
  provide("$o-" + key, {
    registerItem,
    unregisterItem,
    data: options == null ? void 0 : options.data
  });
  return {
    childItems
  };
}
function useProviderChild(options) {
  var _a, _b;
  options = Object.assign({ needParent: true, register: true }, options);
  const vm = getCurrentInstance();
  if (!vm)
    throw new Error(
      "useProviderChild must be called within a component setup function."
    );
  const configField = (_a = vm.proxy) == null ? void 0 : _a.$options.configField;
  const key = (options == null ? void 0 : options.key) || configField;
  const parent = inject("$o-" + key, void 0);
  if (options.needParent && !parent)
    throw new Error(
      `You should wrap ${(_b = vm.proxy) == null ? void 0 : _b.$options.name} in a ${key} component`
    );
  const item = ref();
  if (parent && options.register)
    item.value = parent.registerItem(
      options == null ? void 0 : options.data
    );
  onUnmounted(() => {
    if (parent && item.value) parent.unregisterItem(item.value);
  });
  const data = (parent == null ? void 0 : parent.data) || ref();
  return { parent: data, item };
}
export {
  useProviderChild as a,
  useProviderParent as u
};
//# sourceMappingURL=useParentProvider-eQyyjCAy.mjs.map
