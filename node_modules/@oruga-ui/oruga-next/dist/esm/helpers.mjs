/*! Oruga v0.10.5 | MIT License | github.com/oruga-ui/oruga */
import { Comment, Text, Fragment } from "vue";
function signPoly(value) {
  if (value < 0) return -1;
  return value > 0 ? 1 : 0;
}
const sign = Math.sign || signPoly;
const mod = (n, mod2) => (n % mod2 + mod2) % mod2;
const pad = (value) => (value < 10 ? "0" : "") + value;
function bound(val, min, max) {
  return Math.max(min, Math.min(max, val));
}
const isObject = (value) => !!value && typeof value === "object" && !Array.isArray(value);
const isDate = (value) => !!value && value instanceof Date && !isNaN(value.getTime());
const isDefined = (value) => value !== null && typeof value !== "undefined";
const isTrueish = (value) => isDefined(value) && value !== "false" && value !== false;
const blankIfUndefined = (value) => isDefined(value) ? value : "";
const defaultIfUndefined = (value, defaultValue) => isDefined(value) ? value : defaultValue;
const toCssDimension = (width, dimension = "px") => !isDefined(width) ? void 0 : isNaN(width) ? String(width) : String(width) + dimension;
function sortBy(array, key, fn, isAsc = false, mutate = false) {
  if (fn && typeof fn === "function") {
    return (mutate ? array : [...array]).sort((a, b) => fn(a, b, isAsc));
  } else {
    return (mutate ? array : [...array]).sort((a, b) => {
      let newA = isObject(a) ? getValueByPath(a, key) : a;
      let newB = isObject(b) ? getValueByPath(b, key) : b;
      if (typeof newA === "boolean" && typeof newB === "boolean") {
        return isAsc ? newA > newB ? 1 : -1 : newA > newB ? -1 : 1;
      }
      if (!newA && newA !== 0) return 1;
      if (!newB && newB !== 0) return -1;
      if (newA === newB) return 0;
      newA = typeof newA === "string" ? newA.toUpperCase() : newA;
      newB = typeof newB === "string" ? newB.toUpperCase() : newB;
      return isAsc ? newA > newB ? 1 : -1 : newA > newB ? -1 : 1;
    });
  }
}
function isEqual(valueA, valueB) {
  if (!valueA && !!valueB || !!valueA && !valueB) return false;
  if (valueA === valueB) return true;
  if (isObject(valueA) && isObject(valueB)) {
    const keys1 = Object.keys(valueA);
    const keys2 = Object.keys(valueB);
    if (keys1.length !== keys2.length) return false;
    for (const key of keys1) {
      const val1 = valueA[key];
      const val2 = valueB[key];
      const areObjects = isObject(val1) && isObject(val2);
      if (areObjects && !isEqual(val1, val2) || !areObjects && val1 !== val2)
        return false;
    }
    return true;
  }
  if (Array.isArray(valueA) && Array.isArray(valueB)) {
    if (valueA.length !== valueB.length) return false;
    if (!valueA.every((val, index) => val === valueB[index])) return false;
    return true;
  }
  return false;
}
function isElement(el) {
  return typeof HTMLElement === "object" ? el instanceof HTMLElement : el && typeof el === "object" && el !== null && el.nodeType === 1 && typeof el.nodeName === "string";
}
function getPropertyValue(obj, field, formatter) {
  if (!obj) return "";
  const property = field ? getValueByPath(obj, field) : obj;
  const label = typeof formatter === "function" ? formatter(property, obj) : property;
  return String(label || "");
}
function merge(target, source, deep = false) {
  if (!isObject(target) || !isObject(source)) return source;
  if (!deep) return Object.assign(target, source);
  else return mergeDeep(target, source);
}
function mergeDeep(target, source) {
  if (!isObject(target) || !isObject(source)) return source;
  Object.getOwnPropertyNames(source).forEach((key) => {
    const targetValue = target[key];
    const sourceValue = source[key];
    if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {
      target[key] = targetValue.concat(sourceValue);
    } else if (isObject(targetValue) && isObject(sourceValue)) {
      target[key] = mergeDeep(
        Object.assign({}, targetValue),
        sourceValue
      );
    } else {
      target[key] = sourceValue;
    }
  });
  return target;
}
function getValueByPath(obj, path, defaultValue) {
  if (!obj || typeof obj !== "object" || typeof path !== "string")
    return defaultValue;
  const value = path.split(".").reduce((o, i) => typeof o !== "undefined" ? o[i] : void 0, obj);
  return typeof value !== "undefined" ? value : defaultValue;
}
function setValueByPath(obj, path, value) {
  const p = path.split(".");
  if (p.length === 1) {
    obj[path] = value;
    return;
  }
  const field = p[0];
  if (typeof obj[field] === "undefined") obj[field] = {};
  return setValueByPath(obj[field], p.slice(1).join("."), value);
}
function removeElement(el) {
  if (typeof el.remove !== "undefined") {
    el.remove();
  } else if (typeof el.parentNode !== "undefined" && el.parentNode !== null) {
    el.parentNode.removeChild(el);
  }
}
function escapeRegExpChars(value) {
  if (!value) return value;
  return value.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
function removeDiacriticsFromString(value) {
  if (!value) return value;
  return value.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}
function isVNodeEmpty(vnode) {
  if (!vnode) return true;
  if (vnode.type === Comment) return true;
  if (vnode.type === Text && !vnode.children.trim()) return true;
  if (vnode.type === Fragment && isVNodeEmpty(vnode.children)) return true;
  return false;
}
const isMobileAgent = {
  Android: () => typeof window !== "undefined" && !!window.navigator.userAgent.match(/Android/i),
  BlackBerry: () => typeof window !== "undefined" && !!window.navigator.userAgent.match(/BlackBerry/i),
  iOS: () => typeof window !== "undefined" && !!window.navigator.userAgent.match(/iPhone|iPad|iPod/i),
  Opera: () => typeof window !== "undefined" && !!window.navigator.userAgent.match(/Opera Mini/i),
  Windows: () => typeof window !== "undefined" && !!window.navigator.userAgent.match(/IEMobile/i),
  any: () => isMobileAgent.Android() || isMobileAgent.BlackBerry() || isMobileAgent.iOS() || isMobileAgent.Opera() || isMobileAgent.Windows()
};
export {
  blankIfUndefined,
  bound,
  defaultIfUndefined,
  escapeRegExpChars,
  getPropertyValue,
  getValueByPath,
  isDate,
  isDefined,
  isElement,
  isEqual,
  isMobileAgent,
  isObject,
  isTrueish,
  isVNodeEmpty,
  merge,
  mergeDeep,
  mod,
  pad,
  removeDiacriticsFromString,
  removeElement,
  setValueByPath,
  sign,
  sortBy,
  toCssDimension
};
//# sourceMappingURL=helpers.mjs.map
