/*! Oruga v0.10.5 | MIT License | github.com/oruga-ui/oruga */
import { getCurrentInstance, getCurrentScope, effectScope, onScopeDispose, ref, watch, isRef, toValue } from "vue";
import { d as getOptions } from "./config-B-gWlaT6.mjs";
import { isDefined, getValueByPath, blankIfUndefined } from "./helpers.mjs";
const getActiveClasses = (classes) => {
  const values = toValue(classes);
  if (!values) return [];
  return values.flatMap(
    (bind) => Object.keys(bind).filter((key) => key && bind[key]).flatMap((v) => v.split(" "))
  );
};
function defineClasses(...args) {
  const options = Array.isArray(args.at(-1)) ? void 0 : args.at(-1);
  const classDefinitions = Array.isArray(args.at(-1)) ? args : args.slice(0, -1);
  const vm = getCurrentInstance();
  if (!vm)
    throw new Error(
      "defineClasses must be called within a component setup function."
    );
  if (!getCurrentScope() && !(options == null ? void 0 : options.scope))
    throw new Error(
      "defineClasses must be called within a current active effect scope."
    );
  const scope = (options == null ? void 0 : options.scope) || effectScope();
  if (getCurrentScope())
    onScopeDispose(() => {
      if (scope) scope.stop();
    });
  const classes = ref([]);
  classes.value = classDefinitions.map((defintion, index) => {
    const className = defintion[0];
    const defaultClass = defintion[1];
    const suffix = defintion[2];
    const apply = defintion[3];
    function getClassBind() {
      const computedClass = computeClass(
        vm,
        className,
        defaultClass,
        toValue(suffix) || void 0
      );
      const applied = !isDefined(apply) || toValue(apply);
      return { [computedClass]: applied };
    }
    scope.run(() => {
      watch(
        [
          () => {
            var _a;
            return (_a = vm.proxy) == null ? void 0 : _a.$props[className];
          },
          () => (options == null ? void 0 : options.props) ? options == null ? void 0 : options.props[className] : null
        ],
        () => {
          const classBind = getClassBind();
          classes.value[index] = classBind;
        }
      );
      if (isDefined(suffix) && isRef(suffix)) {
        watch(suffix, (value, oldValue) => {
          if (value === oldValue) return;
          const classBind = getClassBind();
          classes.value[index] = classBind;
        });
      }
      if (isDefined(apply) && isRef(apply)) {
        watch(apply, (applied, oldValue) => {
          if (applied === oldValue) return;
          const classBind = classes.value[index];
          Object.keys(classBind).forEach(
            (key) => classBind[key] = applied
          );
          classes.value[index] = classBind;
        });
      }
    });
    return getClassBind();
  });
  return classes;
}
function computeClass(vm, field, defaultValue, suffix = "") {
  var _a;
  const props = getProps(vm);
  const componentKey = (_a = vm.proxy) == null ? void 0 : _a.$options.configField;
  if (!componentKey)
    throw new Error("component must define the 'configField' option.");
  const config = props.override === true ? {} : getOptions();
  let globalClass = getValueByPath(
    config,
    `${componentKey}.${field}.class`,
    ""
  ) || getValueByPath(
    config,
    `${componentKey}.${field}`,
    ""
  );
  let localClass = getValueByPath(
    props,
    field,
    ""
  );
  if (Array.isArray(localClass)) {
    localClass = localClass.join(" ");
  }
  if (typeof localClass === "function") {
    const props2 = getProps(vm);
    localClass = localClass(suffix, props2);
  } else {
    localClass = suffixProcessor(localClass, suffix);
  }
  if (Array.isArray(globalClass)) {
    globalClass = globalClass.join(" ");
  }
  if (typeof globalClass === "function") {
    const props2 = getProps(vm);
    globalClass = globalClass(suffix, props2);
  } else {
    globalClass = suffixProcessor(globalClass, suffix);
  }
  if (defaultValue.includes("{*}")) {
    defaultValue = defaultValue.replace(
      /\{\*\}/g,
      blankIfUndefined(suffix)
    );
  } else {
    defaultValue = defaultValue + blankIfUndefined(suffix);
  }
  const globalOverride = props.override || getValueByPath(config, "override", false);
  const localOverride = getValueByPath(
    config,
    `${componentKey}.override`,
    globalOverride
  );
  const overrideClass = getValueByPath(
    config,
    `${componentKey}.${field}.override`,
    localOverride
  );
  let appliedClasses = `${!overrideClass ? defaultValue : ""} ${blankIfUndefined(globalClass)} ${blankIfUndefined(localClass)}`.trim().replace(/\s\s+/g, " ");
  const globalTransformClasses = getValueByPath(
    config,
    "transformClasses",
    void 0
  );
  const localTransformClasses = getValueByPath(
    config,
    `${componentKey}.transformClasses`,
    void 0
  );
  if (localTransformClasses) {
    appliedClasses = localTransformClasses(appliedClasses);
  } else if (globalTransformClasses) {
    appliedClasses = globalTransformClasses(appliedClasses);
  }
  return appliedClasses;
}
function suffixProcessor(input, suffix) {
  return blankIfUndefined(input).split(" ").filter((cls) => cls.length > 0).map((cls) => cls + blankIfUndefined(suffix)).join(" ");
}
const getProps = (vm) => {
  var _a;
  let props = ((_a = vm.proxy) == null ? void 0 : _a.$props) || {};
  props = Object.keys(props).filter((key) => key.endsWith("Props")).map((key) => props[key]).reduce((a, b) => ({ ...a, ...b }), props);
  return props;
};
export {
  defineClasses as d,
  getActiveClasses as g
};
//# sourceMappingURL=defineClasses-BApkclKh.mjs.map
