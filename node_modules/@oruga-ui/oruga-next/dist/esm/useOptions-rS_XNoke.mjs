/*! Oruga v0.10.5 | MIT License | github.com/oruga-ui/oruga */
import { toValue } from "vue";
import { isEqual } from "./helpers.mjs";
function normalizeOptions(options, uuid) {
  if (!options) return [];
  if (Array.isArray(options))
    return options.map(
      (option) => {
        if (typeof option === "string" || typeof option === "number")
          return {
            label: String(option),
            value: String(option),
            key: uuid()
          };
        if (typeof option == "object") {
          if ("options" in option) {
            const options2 = normalizeOptions(option.options, uuid);
            return {
              ...option,
              options: options2,
              key: uuid()
            };
          } else if ("value" in option) {
            return {
              ...option,
              key: uuid()
            };
          }
        }
        return option;
      }
    );
  return Object.keys(options).map(
    (value) => ({
      // create option from object key/value
      label: options[value],
      value,
      key: uuid()
    })
  );
}
function isGroupOption(option) {
  return option && typeof option === "object" && Array.isArray(option.options);
}
function toOptionsGroup(options, key) {
  if (!Array.isArray(options)) return [];
  const isGroup = options.some((option) => isGroupOption(option));
  if (isGroup) return [...options];
  return [{ options, key }];
}
function toOptionsList(options) {
  if (!Array.isArray(toValue(options))) return [];
  return toValue(options).reduce((list, group) => {
    list.push(...group.options);
    return list;
  }, []);
}
function filterOptionsItems(options, filter) {
  toValue(options).forEach(
    (option, idx) => {
      if (isGroupOption(option)) {
        filterOptionsItems(option.options, filter);
        option.hidden = option.options.every((option2) => option2.hidden);
      } else {
        option.hidden = filter(option, idx);
      }
    }
  );
}
function checkOptionsEmpty(options) {
  if (!Array.isArray(toValue(options))) return true;
  return toValue(options).every((option) => {
    if (isGroupOption(option))
      return checkOptionsEmpty(option.options);
    else return !isOptionViable(option);
  });
}
function findOption(options, value) {
  if (!Array.isArray(toValue(options))) return void 0;
  for (const option of toValue(options)) {
    if (typeof option !== "object" && option) continue;
    if (isGroupOption(option)) {
      const found = findOption(option.options, value);
      if (found !== void 0) return found;
    } else if (isEqual(toValue(value), option.value)) return option;
  }
  return void 0;
}
function isOptionViable(option) {
  var _a;
  return !toValue(option).hidden && !((_a = toValue(option).attrs) == null ? void 0 : _a.disabled);
}
export {
  isOptionViable as a,
  findOption as b,
  checkOptionsEmpty as c,
  toOptionsList as d,
  filterOptionsItems as f,
  isGroupOption as i,
  normalizeOptions as n,
  toOptionsGroup as t
};
//# sourceMappingURL=useOptions-rS_XNoke.mjs.map
