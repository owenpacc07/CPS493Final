/*! Oruga v0.10.5 | MIT License | github.com/oruga-ui/oruga */
import { defineComponent, mergeModels, useSlots, useTemplateRef, useModel, useId, computed, watchEffect, triggerRef, watch, ref, useAttrs, createBlock, openBlock, unref, normalizeClass, withCtx, createCommentVNode, createElementBlock, renderSlot, Fragment, renderList, withDirectives, mergeProps, toDisplayString, vShow, createVNode, toValue } from "vue";
import { _ as _sfc_main$3 } from "./Input.vue_vue_type_script_setup_true_lang-kX88K1OJ.mjs";
import { _ as _sfc_main$1, a as _sfc_main$2 } from "./Dropdown.vue_vue_type_script_setup_true_lang-DvIYVcC_.mjs";
import { g as getDefault } from "./config-B-gWlaT6.mjs";
import { d as defineClasses } from "./defineClasses-BApkclKh.mjs";
import { u as useInputHandler } from "./useInputHandler-B842u-_G.mjs";
import { n as normalizeOptions, t as toOptionsGroup, f as filterOptionsItems, c as checkOptionsEmpty, b as findOption, d as toOptionsList } from "./useOptions-rS_XNoke.mjs";
import { u as useSequentialId } from "./useSequentialId-aw-jeTgs.mjs";
import { i as injectField } from "./fieldInjection-Bs3TBpgZ.mjs";
const _hoisted_1 = { key: 1 };
const _hoisted_2 = { key: 1 };
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    isOruga: true,
    name: "OAutocomplete",
    configField: "autocomplete",
    inheritAttrs: false
  },
  __name: "Autocomplete",
  props: /* @__PURE__ */ mergeModels({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    input: { default: "" },
    active: { type: Boolean, default: false },
    options: { default: void 0 },
    backendFiltering: { type: Boolean, default: () => getDefault("autocomplete.backendFiltering", false) },
    filter: { type: Function, default: void 0 },
    type: { default: "text" },
    menuTag: { default: () => getDefault("autocomplete.menuTag", "div") },
    itemTag: { default: () => getDefault("autocomplete.itemTag", "div") },
    size: { default: () => getDefault("autocomplete.size") },
    position: { default: () => getDefault("autocomplete.position", "auto") },
    placeholder: { default: void 0 },
    expanded: { type: Boolean, default: false },
    rounded: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    maxlength: { default: void 0 },
    debounce: { default: () => getDefault("autocomplete.debounce", 400) },
    keepFirst: { type: Boolean, default: () => getDefault("autocomplete.keepFirst", false) },
    keepOpen: { type: Boolean, default: () => getDefault("autocomplete.keepOpen", false) },
    clearOnSelect: { type: Boolean, default: () => getDefault("autocomplete.clearOnSelect", false) },
    openOnFocus: { type: Boolean, default: () => getDefault("autocomplete.openOnFocus", false) },
    selectOnClose: { type: Boolean, default: false },
    selectableHeader: { type: Boolean, default: false },
    selectableFooter: { type: Boolean, default: false },
    maxHeight: { default: () => getDefault("autocomplete.maxHeight") },
    checkScroll: { type: Boolean, default: () => getDefault("autocomplete.checkScroll", false) },
    iconPack: { default: () => getDefault("autocomplete.iconPack") },
    icon: { default: () => getDefault("autocomplete.icon") },
    iconClickable: { type: Boolean, default: false },
    iconRight: { default: () => getDefault("autocomplete.iconRight") },
    iconRightClickable: { type: Boolean, default: false },
    iconRightVariant: { default: void 0 },
    clearable: { type: Boolean, default: () => getDefault("autocomplete.clearable", false) },
    clearIcon: { default: () => getDefault("autocomplete.clearIcon", "close-circle") },
    statusIcon: { type: Boolean, default: () => getDefault("statusIcon", true) },
    mobileModal: { type: Boolean, default: () => getDefault("autocomplete.mobileModal", false) },
    desktopModal: { type: Boolean, default: () => getDefault("dropdown.desktopModal", false) },
    animation: { default: () => getDefault("autocomplete.animation", "fade") },
    autocomplete: { default: () => getDefault("autocomplete.autocomplete", "off") },
    useHtml5Validation: { type: Boolean, default: () => getDefault("useHtml5Validation", true) },
    customValidity: { type: [String, Function], default: void 0 },
    teleport: { type: [Boolean, String, Object], default: () => getDefault("autocomplete.teleport", false) },
    rootClass: {},
    itemClass: {},
    itemGroupTitleClass: {},
    itemEmptyClass: {},
    itemHeaderClass: {},
    itemFooterClass: {},
    inputClasses: { default: () => getDefault("autocomplete.inputClasses", {}) }
  }, {
    "active": { type: Boolean, ...{ default: false } },
    "activeModifiers": {},
    "modelValue": { default: void 0 },
    "modelModifiers": {},
    "input": { default: "" },
    "inputModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["update:model-value", "update:input", "update:active", "input", "select", "select-header", "select-footer", "focus", "blur", "invalid", "icon-click", "icon-right-click", "scroll-start", "scroll-end"], ["update:active", "update:modelValue", "update:input"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const slots = useSlots();
    const inputRef = useTemplateRef("inputComponent");
    const { checkHtml5Validity, onInvalid, onFocus, onBlur, isFocused, setFocus } = useInputHandler(inputRef, emits, props);
    const { parentField } = injectField();
    const isActive = useModel(__props, "active");
    const selectedValue = useModel(__props, "modelValue");
    const inputValue = useModel(__props, "input");
    const menuId = useId();
    const { nextSequence } = useSequentialId();
    const groupedOptions = computed(() => {
      const normalizedOptions = normalizeOptions(props.options, nextSequence);
      const groupedOptions2 = toOptionsGroup(normalizedOptions, nextSequence());
      return groupedOptions2;
    });
    if (!props.backendFiltering)
      watchEffect(() => {
        filterOptionsItems(
          groupedOptions,
          (o) => filterItems(o, inputValue)
        );
        triggerRef(groupedOptions);
      });
    function filterItems(option, value) {
      var _a;
      if (typeof props.filter === "function")
        return props.filter(option.value, toValue(value));
      else
        return !String(option.label).toLowerCase().includes((_a = toValue(value)) == null ? void 0 : _a.toLowerCase());
    }
    const isEmpty = computed(() => checkOptionsEmpty(groupedOptions));
    watch(isEmpty, (empty) => {
      if (isFocused.value) isActive.value = !empty || !!slots.empty;
    });
    const dropdownValue = ref();
    watch(
      inputValue,
      (value) => {
        const currentOption = findOption(groupedOptions, selectedValue);
        if (currentOption && currentOption.label !== value) {
          selectedValue.value = void 0;
          dropdownValue.value = void 0;
        }
        if (isEmpty.value && !slots.empty) {
          isActive.value = false;
        }
      },
      { flush: "post" }
    );
    watch(
      selectedValue,
      (value) => {
        if (!value) return;
        const option = findOption(groupedOptions, value);
        if (!option) return;
        inputValue.value = props.clearOnSelect ? "" : option.label;
        checkHtml5Validity();
        dropdownValue.value = option.value;
      },
      // set initial values if selected is given
      { immediate: true }
    );
    function setSelected(item) {
      let option = void 0;
      if (item === 0) {
        emits("select-header");
      } else if (item === 1) {
        emits("select-footer");
      } else if (item) {
        const options = toOptionsList(groupedOptions);
        option = options.find((o) => o.value === item);
      }
      selectedValue.value = option == null ? void 0 : option.value;
      emits("select", option == null ? void 0 : option.value);
      if (props.keepOpen) setFocus();
      else isActive.value = false;
    }
    function onInput(value, event) {
      if (isFocused.value) {
        if (!isActive.value && value && (!isEmpty.value || slots.empty)) {
          isActive.value = true;
        } else if (isActive.value && !value && !props.keepOpen) {
          isActive.value = false;
        }
      }
      emits("input", value, event);
      checkHtml5Validity();
    }
    function handleFocus(event) {
      var _a;
      if (props.openOnFocus && (!!((_a = props.options) == null ? void 0 : _a.length) || !!slots.header || !!slots.footer))
        isActive.value = true;
      onFocus(event);
    }
    function handleBlur(event) {
      onBlur(event);
    }
    const computedIconRight = computed(
      () => props.clearable && inputValue.value && props.clearIcon ? props.clearIcon : props.iconRight
    );
    const computedIconRightClickable = computed(
      () => props.clearable ? true : props.iconRightClickable
    );
    function rightIconClick(event) {
      if (props.clearable) {
        inputValue.value = "";
      } else emits("icon-right-click", event);
    }
    const attrs = useAttrs();
    const inputBind = computed(() => {
      var _a;
      return {
        ...(_a = parentField == null ? void 0 : parentField.value) == null ? void 0 : _a.inputAttrs,
        ...attrs,
        ...props.inputClasses
      };
    });
    const rootClasses = defineClasses(["rootClass", "o-autocomplete"]);
    const itemClasses = defineClasses(["itemClass", "o-autocomplete__item"]);
    const itemEmptyClasses = defineClasses([
      "itemEmptyClass",
      "o-autocomplete__item--empty"
    ]);
    const itemGroupClasses = defineClasses([
      "itemGroupTitleClass",
      "o-autocomplete__item-group-title"
    ]);
    const itemHeaderClasses = defineClasses([
      "itemHeaderClass",
      "o-autocomplete__item-header"
    ]);
    const itemFooterClasses = defineClasses([
      "itemFooterClass",
      "o-autocomplete__item-footer"
    ]);
    __expose({ focus: setFocus, value: inputValue });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$1, {
        modelValue: dropdownValue.value,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => dropdownValue.value = $event),
        active: isActive.value,
        "onUpdate:active": _cache[3] || (_cache[3] = ($event) => isActive.value = $event),
        "data-oruga": "autocomplete",
        class: normalizeClass(unref(rootClasses)),
        "menu-id": unref(menuId),
        "menu-tag": _ctx.menuTag,
        triggers: [],
        scrollable: "",
        selectable: "",
        "keep-open": _ctx.keepOpen,
        "keep-first": _ctx.keepFirst,
        "check-scroll": _ctx.checkScroll,
        "select-on-close": _ctx.selectOnClose,
        disabled: _ctx.disabled,
        "desktop-modal": _ctx.desktopModal,
        "mobile-modal": _ctx.mobileModal,
        "max-height": _ctx.maxHeight,
        animation: _ctx.animation,
        position: _ctx.position,
        teleport: _ctx.teleport,
        expanded: _ctx.expanded,
        onSelect: setSelected,
        onScrollStart: _cache[4] || (_cache[4] = ($event) => emits("scroll-start")),
        onScrollEnd: _cache[5] || (_cache[5] = ($event) => emits("scroll-end"))
      }, {
        trigger: withCtx(() => [
          createVNode(_sfc_main$3, mergeProps({ ref: "inputComponent" }, inputBind.value, {
            modelValue: inputValue.value,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => inputValue.value = $event),
            type: _ctx.type,
            size: _ctx.size,
            rounded: _ctx.rounded,
            icon: _ctx.icon,
            "icon-right": computedIconRight.value,
            "icon-right-clickable": computedIconRightClickable.value,
            "icon-pack": _ctx.iconPack,
            placeholder: _ctx.placeholder,
            maxlength: _ctx.maxlength,
            autocomplete: _ctx.autocomplete,
            expanded: _ctx.expanded,
            disabled: _ctx.disabled,
            "status-icon": _ctx.statusIcon,
            debounce: _ctx.debounce,
            "aria-autocomplete": _ctx.keepFirst ? "both" : "list",
            "aria-controls": unref(menuId),
            enterkeyhint: "enter",
            "use-html5-validation": false,
            onInput,
            onFocus: handleFocus,
            onBlur: handleBlur,
            onInvalid: unref(onInvalid),
            onIconClick: _cache[1] || (_cache[1] = ($event) => emits("icon-click", $event)),
            onIconRightClick: rightIconClick
          }), null, 16, ["modelValue", "type", "size", "rounded", "icon", "icon-right", "icon-right-clickable", "icon-pack", "placeholder", "maxlength", "autocomplete", "expanded", "disabled", "status-icon", "debounce", "aria-autocomplete", "aria-controls", "onInvalid"])
        ]),
        default: withCtx(() => [
          _ctx.$slots.header ? (openBlock(), createBlock(_sfc_main$2, {
            key: 0,
            tag: _ctx.itemTag,
            value: 0,
            clickable: _ctx.selectableHeader,
            class: normalizeClass([...unref(itemClasses), ...unref(itemHeaderClasses)])
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "header")
            ]),
            _: 3
          }, 8, ["tag", "value", "clickable", "class"])) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(groupedOptions.value, (group, groupIndex) => {
            return openBlock(), createElementBlock(Fragment, null, [
              group.label ? withDirectives((openBlock(), createBlock(_sfc_main$2, mergeProps({
                key: group.key,
                ref_for: true
              }, group.attrs, {
                hidden: group.hidden,
                value: group.value,
                tag: _ctx.itemTag,
                role: "presentation",
                clickable: false,
                class: [...unref(itemClasses), ...unref(itemGroupClasses)]
              }), {
                default: withCtx(() => [
                  _ctx.$slots.group ? renderSlot(_ctx.$slots, "group", {
                    key: 0,
                    group: group.label,
                    index: groupIndex
                  }) : (openBlock(), createElementBlock("span", _hoisted_1, toDisplayString(group.label), 1))
                ]),
                _: 2
              }, 1040, ["hidden", "value", "tag", "class"])), [
                [vShow, !group.hidden]
              ]) : createCommentVNode("", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(group.options, (option, optionIndex) => {
                return withDirectives((openBlock(), createBlock(_sfc_main$2, mergeProps({
                  key: option.key,
                  ref_for: true
                }, option.attrs, {
                  value: option.value,
                  hidden: option.hidden,
                  tag: _ctx.itemTag,
                  class: unref(itemClasses)
                }), {
                  default: withCtx(() => [
                    _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", {
                      key: 0,
                      option,
                      value: option.value,
                      index: optionIndex
                    }) : (openBlock(), createElementBlock("span", _hoisted_2, toDisplayString(option.label), 1))
                  ]),
                  _: 2
                }, 1040, ["value", "hidden", "tag", "class"])), [
                  [vShow, !option.hidden]
                ]);
              }), 128))
            ], 64);
          }), 256)),
          isEmpty.value && _ctx.$slots.empty ? (openBlock(), createBlock(_sfc_main$2, {
            key: 1,
            tag: _ctx.itemTag,
            class: normalizeClass([...unref(itemClasses), ...unref(itemEmptyClasses)])
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "empty")
            ]),
            _: 3
          }, 8, ["tag", "class"])) : createCommentVNode("", true),
          _ctx.$slots.footer ? (openBlock(), createBlock(_sfc_main$2, {
            key: 2,
            tag: _ctx.itemTag,
            value: 1,
            clickable: _ctx.selectableFooter,
            class: normalizeClass([...unref(itemClasses), ...unref(itemFooterClasses)])
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "footer")
            ]),
            _: 3
          }, 8, ["tag", "value", "clickable", "class"])) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["modelValue", "active", "class", "menu-id", "menu-tag", "keep-open", "keep-first", "check-scroll", "select-on-close", "disabled", "desktop-modal", "mobile-modal", "max-height", "animation", "position", "teleport", "expanded"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=Autocomplete.vue_vue_type_script_setup_true_lang-DNYts92f.mjs.map
