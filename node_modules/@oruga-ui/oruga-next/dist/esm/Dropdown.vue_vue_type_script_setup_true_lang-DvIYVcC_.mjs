/*! Oruga v0.10.5 | MIT License | github.com/oruga-ui/oruga */
import { defineComponent, useId, useTemplateRef, computed, createBlock, openBlock, resolveDynamicComponent, withKeys, normalizeClass, unref, withCtx, renderSlot, createTextVNode, toDisplayString, mergeModels, ref, useModel, watch, nextTick, createElementBlock, createCommentVNode, createVNode, withModifiers, Transition, withDirectives, createElementVNode, vShow, normalizeStyle, Fragment, renderList, mergeProps } from "vue";
import { g as getDefault, i as isClient } from "./config-B-gWlaT6.mjs";
import { isDefined, isEqual, isTrueish, isMobileAgent, toCssDimension, mod } from "./helpers.mjs";
import { d as defineClasses } from "./defineClasses-BApkclKh.mjs";
import { a as useProviderChild, u as useProviderParent } from "./useParentProvider-eQyyjCAy.mjs";
import { _ as _sfc_main$2 } from "./PositionWrapper.vue_vue_type_script_setup_true_lang-BWfJ96nN.mjs";
import { u as unrefElement } from "./unrefElement-BpUk-iXz.mjs";
import { u as useEventListener } from "./useEventListener-DOZSd6dT.mjs";
import { u as useMatchMedia } from "./useMatchMedia-DbB9F3o7.mjs";
import { u as useClickOutside } from "./useClickOutside-C73B6jwZ.mjs";
import { n as normalizeOptions, t as toOptionsGroup } from "./useOptions-rS_XNoke.mjs";
import { u as usePreventScrolling } from "./usePreventScrolling-wKArjY8w.mjs";
import { u as useSequentialId } from "./useSequentialId-aw-jeTgs.mjs";
import { i as injectField } from "./fieldInjection-Bs3TBpgZ.mjs";
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    isOruga: true,
    name: "ODropdownItem",
    configField: "dropdown"
  },
  __name: "DropdownItem",
  props: {
    override: { type: Boolean, default: void 0 },
    value: { default: void 0 },
    label: { default: void 0 },
    disabled: { type: Boolean, default: false },
    clickable: { type: Boolean, default: true },
    hidden: { type: Boolean, default: false },
    tag: { default: () => getDefault("dropdown.itemTag", "div") },
    itemClass: {},
    itemSelectedClass: {},
    itemFocusedClass: {},
    itemClickableClass: {},
    itemDisabledClass: {}
  },
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const itemValue = props.value ?? useId();
    const rootRef = useTemplateRef("rootElement");
    const providedData = computed(() => ({
      ...props,
      $el: rootRef.value,
      value: itemValue,
      selectItem
    }));
    const { parent, item } = useProviderChild({ data: providedData });
    const isClickable = computed(
      () => !parent.value.disabled && !props.disabled && props.clickable
    );
    const isSelected = computed(() => {
      if (!isDefined(parent.value.selected)) return false;
      if (parent.value.multiple && Array.isArray(parent.value.selected))
        return parent.value.selected.some(
          (selected) => isEqual(itemValue, selected)
        );
      return isEqual(itemValue, parent.value.selected);
    });
    const isFocused = computed(
      () => item.value.identifier === parent.value.focsuedIdentifier
    );
    function selectItem(event) {
      if (!isClickable.value) return;
      parent.value.selectItem(item.value, event);
      emits("click", itemValue, event);
    }
    function focusItem() {
      parent.value.focusItem(item.value);
    }
    const rootClasses = defineClasses(
      ["itemClass", "o-dropdown__item"],
      [
        "itemDisabledClass",
        "o-dropdown__item--disabled",
        null,
        computed(() => parent.value.disabled || props.disabled)
      ],
      ["itemSelectedClass", "o-dropdown__item--active", null, isSelected],
      ["itemClickableClass", "o-dropdown__item--clickable", null, isClickable],
      ["itemFocusedClass", "o-dropdown__item--focused", null, isFocused]
    );
    return (_ctx, _cache) => {
      return openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
        id: `${unref(parent).menuId}-${unref(item).identifier}`,
        ref: "rootElement",
        "data-oruga": "dropdown-item",
        "data-id": `dropdown-${unref(item).identifier}`,
        class: normalizeClass(unref(rootClasses)),
        role: unref(parent).selectable ? "option" : "menuitem",
        "aria-selected": unref(parent).selectable ? isSelected.value : void 0,
        "aria-disabled": _ctx.disabled,
        onClick: selectItem,
        onMouseenter: focusItem,
        onKeydown: [
          withKeys(selectItem, ["enter"]),
          withKeys(selectItem, ["space"])
        ]
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(_ctx.label), 1)
          ])
        ]),
        _: 3
      }, 40, ["id", "data-id", "class", "role", "aria-selected", "aria-disabled"]);
    };
  }
});
function maintainScrollVisibility(activeElement, scrollParent) {
  const parent = unrefElement(scrollParent);
  const element = unrefElement(activeElement);
  const { offsetHeight, offsetTop } = element;
  const { offsetHeight: parentOffsetHeight, scrollTop } = parent;
  const isAbove = offsetTop < scrollTop;
  const isBelow = offsetTop + offsetHeight > scrollTop + parentOffsetHeight;
  if (isAbove) {
    parent.scrollTo(0, offsetTop);
  } else if (isBelow) {
    parent.scrollTo(0, offsetTop - parentOffsetHeight + offsetHeight);
  }
}
function useInfiniteScroll(elementRef, onEnd, onStart) {
  if (isClient) useEventListener(elementRef, "scroll", checkScroll);
  function checkScroll() {
    const element = unrefElement(elementRef);
    if (!element) return;
    const trashhold = element.offsetTop;
    if (element.clientHeight !== element.scrollHeight) {
      if (Math.ceil(
        element.scrollTop + element.clientHeight + trashhold
      ) >= element.scrollHeight) {
        onEnd();
      } else if (element.scrollTop <= trashhold) {
        onStart();
      }
    }
  }
  return { checkScroll };
}
const _hoisted_1 = { key: 1 };
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    isOruga: true,
    name: "ODropdown",
    configField: "dropdown"
  },
  __name: "Dropdown",
  props: /* @__PURE__ */ mergeModels({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    multiple: {},
    options: { default: void 0 },
    active: { type: Boolean, default: false },
    label: { default: void 0 },
    disabled: { type: Boolean, default: false },
    inline: { type: Boolean, default: false },
    selectable: { type: Boolean, default: false },
    scrollable: { type: Boolean, default: false },
    checkScroll: { type: Boolean, default: () => getDefault("dropdown.checkScroll", false) },
    maxHeight: { default: () => getDefault("dropdown.maxHeight", 200) },
    position: { default: () => getDefault("dropdown.position", "bottom-left") },
    animation: { default: () => getDefault("dropdown.animation", "fade") },
    expanded: { type: Boolean, default: false },
    menuId: { default: () => useId() },
    menuTag: { default: () => getDefault("dropdown.menuTag", "div") },
    triggerTag: { default: () => getDefault("dropdown.triggerTag", "div") },
    triggers: { default: () => getDefault("dropdown.triggers", ["click"]) },
    delay: { default: void 0 },
    keepOpen: { type: Boolean, default: () => getDefault("dropdown.keepOpen", false) },
    keepFirst: { type: Boolean, default: () => getDefault("dropdown.keepFirst", false) },
    closeOnOutside: { type: Boolean, default: () => getDefault("dropdown.closeOnOutside", true) },
    closeOnScroll: { type: Boolean, default: () => getDefault("dropdown.closeOnScroll", false) },
    selectOnFocus: { type: Boolean, default: () => getDefault("dropdown.selectOnFocus", false) },
    selectOnClose: { type: Boolean, default: () => getDefault("dropdown.selectOnClose", false) },
    mobileModal: { type: Boolean, default: () => getDefault("dropdown.mobileModal", true) },
    desktopModal: { type: Boolean, default: () => getDefault("dropdown.desktopModal", false) },
    mobileBreakpoint: { default: () => getDefault("dropdown.mobileBreakpoint") },
    teleport: { type: [Boolean, String, Object], default: () => getDefault("dropdown.teleport", false) },
    clipScroll: { type: Boolean, default: () => getDefault("dropdown.clipScroll", false) },
    labelledby: {},
    ariaLabel: {},
    rootClass: {},
    mobileClass: {},
    modalClass: {},
    teleportClass: {},
    inlineClass: {},
    disabledClass: {},
    expandedClass: {},
    positionClass: {},
    activeClass: {},
    hoverableClass: {},
    triggerClass: {},
    menuClass: {},
    menuPositionClass: {},
    menuActiveClass: {},
    overlayClass: {},
    scrollClipClass: {},
    scrollKeepClass: {}
  }, {
    "modelValue": { default: void 0 },
    "modelModifiers": {},
    "active": { type: Boolean, ...{ default: false } },
    "activeModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["update:model-value", "update:active", "select", "change", "open", "close", "scroll-start", "scroll-end"], ["update:modelValue", "update:active"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    var _a;
    const props = __props;
    const emits = __emit;
    const triggerRef = ref();
    const menuRef = ref();
    const provideData = computed(() => {
      var _a2;
      return {
        disabled: props.disabled,
        multiple: isTrueish(props.multiple),
        selectable: props.selectable,
        menuId: props.menuId,
        selected: vmodel.value,
        focsuedIdentifier: (_a2 = focusedItem.value) == null ? void 0 : _a2.identifier,
        selectItem,
        focusItem
      };
    });
    const { childItems } = useProviderParent({
      rootRef: menuRef,
      data: provideData
    });
    const { nextSequence } = useSequentialId();
    const groupedOptions = computed(() => {
      const normalizedOptions = normalizeOptions(props.options, nextSequence);
      const groupedOptions2 = toOptionsGroup(normalizedOptions, nextSequence());
      return groupedOptions2;
    });
    const isNotEmpty = computed(() => childItems.value.some(isItemViable));
    const { parentField } = injectField();
    const vmodel = useModel(__props, "modelValue");
    const isActive = useModel(__props, "active");
    const labelId = props.labelledby ?? ((_a = parentField.value) == null ? void 0 : _a.labelId);
    const autoPosition = ref(props.position);
    watch(
      () => props.position,
      (v) => autoPosition.value = v
    );
    const { isMobile } = useMatchMedia(props.mobileBreakpoint);
    const isMobileNative = isClient && isMobileAgent.any();
    const isModal = computed(
      () => !props.inline && (isMobile.value && props.mobileModal || !isMobile.value && props.desktopModal)
    );
    const menuStyle = computed(() => ({
      maxHeight: props.scrollable ? toCssDimension(props.maxHeight) : null,
      overflow: props.scrollable ? "auto" : null
    }));
    const hoverable = computed(() => props.triggers.includes("hover"));
    const toggleScroll = usePreventScrolling(props.clipScroll);
    if (isClient && props.scrollable && props.checkScroll)
      useInfiniteScroll(
        menuRef,
        () => emits("scroll-end"),
        () => emits("scroll-start")
      );
    if (isClient && props.closeOnOutside)
      useClickOutside([menuRef, triggerRef], onClickedOutside, {
        trigger: isActive,
        passive: true
      });
    if (isClient && props.closeOnScroll)
      useEventListener(window, "scroll", onPageScroll, { passive: true });
    watch(
      isActive,
      (value) => {
        if (value) {
          if (!props.inline && props.keepFirst && !focusedItem.value)
            moveFocus(1);
        }
        if (isModal.value) toggleScroll(value);
      },
      { flush: "post" }
    );
    watch(
      childItems,
      () => {
        if (isActive.value && !props.inline && props.keepFirst) {
          focusedItem.value = void 0;
          moveFocus(1);
        }
      },
      { deep: true, flush: "post" }
    );
    function onClickedOutside(event) {
      if (!isActive.value || props.inline) return;
      if (!props.closeOnOutside) return;
      close("outside", event);
    }
    function onPageScroll(event) {
      if (!isActive.value || props.inline) return;
      if (!props.closeOnScroll) return;
      close("scroll", event);
    }
    function onTriggerClick(event) {
      if (isMobileNative && hoverable.value) toggle("click", event);
      if (!props.triggers.includes("click")) return;
      toggle("click", event);
    }
    function onTriggerContextMenu(event) {
      if (!props.triggers.includes("contextmenu")) return;
      event.preventDefault();
      open("contextmenu", event);
    }
    function onTriggerFocus(event) {
      if (!props.triggers.includes("focus")) return;
      open("focus", event);
    }
    function onTriggerHover(event) {
      if (isMobileNative) return;
      if (!props.triggers.includes("hover")) return;
      open("hover", event);
    }
    function onTriggerHoverLeave(event) {
      if (isMobileNative) return;
      if (!props.triggers.includes("hover")) return;
      close("outside", event);
    }
    function toggle(method, event) {
      if (props.disabled) return;
      if (!isActive.value) open(method, event);
      else close(method, event);
    }
    let timer;
    function open(method, event) {
      if (props.disabled) return;
      if (isActive.value) return;
      if (props.delay) {
        timer = setTimeout(() => {
          isActive.value = true;
          emits("open", method, event);
          timer = void 0;
        }, props.delay);
      } else {
        nextTick(() => isActive.value = true);
        emits("open", method, event);
      }
    }
    function close(method, event) {
      var _a2, _b;
      if (!isActive.value) return;
      emits("close", method, event);
      if (props.selectOnClose && ((_b = (_a2 = focusedItem.value) == null ? void 0 : _a2.data) == null ? void 0 : _b.value))
        selectItem(focusedItem.value);
      isActive.value = false;
      focusedItem.value = void 0;
      if (timer) clearTimeout(timer);
    }
    function selectItem(item, event) {
      var _a2;
      const value = item.data.value;
      emits("select", value);
      if (props.selectable) {
        if (isTrueish(props.multiple)) {
          if (vmodel.value && Array.isArray(vmodel.value)) {
            if (!vmodel.value.includes(value)) {
              vmodel.value = [...vmodel.value, value];
            } else {
              vmodel.value = vmodel.value.filter(
                (val) => val !== value
              );
            }
          } else {
            vmodel.value = [value];
          }
          nextTick(() => emits("change", vmodel.value));
        } else {
          if (vmodel.value !== value) {
            vmodel.value = value;
            nextTick(() => emits("change", vmodel.value));
          }
        }
      }
      (_a2 = triggerRef.value) == null ? void 0 : _a2.focus();
      if (props.keepOpen || !isActive.value || !event) return;
      close("content", event);
    }
    const focusedItem = ref();
    function focusItem(value) {
      focusedItem.value = value;
    }
    function moveFocus(delta) {
      var _a2;
      if (!isNotEmpty.value) return;
      const item = getFirstViableItem(((_a2 = focusedItem.value) == null ? void 0 : _a2.index) || 0, delta);
      setFocus(item);
    }
    function setFocus(item) {
      var _a2, _b;
      if (props.selectOnFocus && ((_a2 = item.data) == null ? void 0 : _a2.value))
        selectItem(item, new Event("focus"));
      const dropdownMenu = unrefElement(menuRef);
      const element = unrefElement((_b = item.data) == null ? void 0 : _b.$el);
      if (!dropdownMenu || !element) return;
      focusedItem.value = item;
      maintainScrollVisibility(element, dropdownMenu);
    }
    function onUpPressed(event) {
      if (!isActive.value) return open("keydown", event);
      moveFocus(-1);
    }
    function onDownPressed(event) {
      if (!isActive.value) return open("keydown", event);
      moveFocus(1);
    }
    function onEnter(event) {
      var _a2;
      if (!isActive.value) return;
      if (focusedItem.value) {
        setFocus(focusedItem.value);
        (_a2 = focusedItem.value.data) == null ? void 0 : _a2.selectItem(event);
      }
    }
    function onHomePressed(event) {
      open("keydown", event);
      if (!isNotEmpty.value) return;
      const item = getFirstViableItem(0, 1);
      setFocus(item);
    }
    function onEndPressed(event) {
      open("keydown", event);
      if (!isNotEmpty.value) return;
      const item = getFirstViableItem(childItems.value.length - 1, -1);
      setFocus(item);
    }
    function onEscape(event) {
      close("escape", event);
    }
    function getFirstViableItem(startingIndex, delta) {
      var _a2, _b;
      let newIndex = mod(
        ((_a2 = focusedItem.value) == null ? void 0 : _a2.index) == startingIndex ? startingIndex + delta : startingIndex,
        childItems.value.length
      );
      for (; newIndex !== ((_b = focusedItem.value) == null ? void 0 : _b.index); newIndex = mod(newIndex + delta, childItems.value.length)) {
        if (isItemViable(childItems.value[newIndex])) break;
      }
      return childItems.value[newIndex];
    }
    function isItemViable(item) {
      var _a2, _b, _c;
      return !((_a2 = item.data) == null ? void 0 : _a2.disabled) && !((_b = item.data) == null ? void 0 : _b.hidden) && !!((_c = item.data) == null ? void 0 : _c.clickable);
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-dropdown"],
      [
        "disabledClass",
        "o-dropdown--disabled",
        null,
        computed(() => props.disabled)
      ],
      [
        "expandedClass",
        "o-dropdown--expanded",
        null,
        computed(() => props.expanded)
      ],
      ["inlineClass", "o-dropdown--inline", null, computed(() => props.inline)],
      ["mobileClass", "o-dropdown--mobile", null, isMobile],
      ["modalClass", "o-dropdown--modal", null, isModal],
      ["hoverableClass", "o-dropdown--hoverable", null, hoverable],
      [
        "positionClass",
        "o-dropdown--position-",
        autoPosition,
        computed(() => !!autoPosition.value)
      ],
      [
        "activeClass",
        "o-dropdown--active",
        null,
        computed(() => isActive.value || props.inline)
      ]
    );
    const triggerClasses = defineClasses(["triggerClass", "o-dropdown__trigger"]);
    const teleportClasses = defineClasses([
      "teleportClass",
      "o-dropdown--teleport",
      null,
      computed(() => !!props.teleport)
    ]);
    const overlayClasses = defineClasses(["overlayClass", "o-dropdown__overlay"]);
    const menuClasses = defineClasses(
      ["menuClass", "o-dropdown__menu"],
      [
        "menuPositionClass",
        "o-dropdown__menu--",
        autoPosition,
        computed(() => !!autoPosition.value)
      ],
      [
        "menuActiveClass",
        "o-dropdown__menu--active",
        null,
        computed(() => isActive.value || props.inline)
      ]
    );
    __expose({ $trigger: triggerRef, $content: menuRef, value: vmodel });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        "data-oruga": "dropdown",
        class: normalizeClass(unref(rootClasses)),
        onMouseleave: onTriggerHoverLeave,
        onFocusout: onTriggerHoverLeave
      }, [
        !_ctx.inline ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.triggerTag), {
          key: 0,
          ref_key: "triggerRef",
          ref: triggerRef,
          class: normalizeClass(unref(triggerClasses)),
          role: _ctx.selectable ? "combobox" : void 0,
          tabindex: _ctx.disabled ? -1 : null,
          "aria-haspopup": _ctx.selectable ? "listbox" : "menu",
          "aria-expanded": _ctx.selectable ? isActive.value : void 0,
          "aria-activedescendant": focusedItem.value ? `${_ctx.menuId}-${focusedItem.value.identifier}` : void 0,
          "aria-disabled": _ctx.disabled,
          "aria-controls": _ctx.menuId,
          "aria-labelledby": _ctx.selectable ? unref(labelId) : void 0,
          "aria-label": _ctx.selectable ? _ctx.ariaLabel : void 0,
          onClick: onTriggerClick,
          onContextmenu: onTriggerContextMenu,
          onMouseenter: onTriggerHover,
          onFocusCapture: onTriggerFocus,
          onKeydown: [
            withKeys(onEscape, ["tab"]),
            withKeys(onEscape, ["escape"]),
            withKeys(onEnter, ["enter"]),
            withKeys(onEnter, ["space"]),
            withKeys(withModifiers(onUpPressed, ["prevent"]), ["up"]),
            withKeys(withModifiers(onDownPressed, ["prevent"]), ["down"]),
            withKeys(withModifiers(onHomePressed, ["prevent"]), ["home"]),
            withKeys(withModifiers(onEndPressed, ["prevent"]), ["end"])
          ]
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "trigger", {
              active: isActive.value,
              value: __props.modelValue,
              toggle: onTriggerClick
            }, () => [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ])
          ]),
          _: 3
        }, 40, ["class", "role", "tabindex", "aria-haspopup", "aria-expanded", "aria-activedescendant", "aria-disabled", "aria-controls", "aria-labelledby", "aria-label", "onKeydown"])) : createCommentVNode("", true),
        createVNode(_sfc_main$2, {
          position: autoPosition.value,
          "onUpdate:position": _cache[6] || (_cache[6] = ($event) => autoPosition.value = $event),
          teleport: _ctx.teleport,
          class: normalizeClass([...unref(rootClasses), ...unref(teleportClasses)]),
          trigger: triggerRef.value,
          disabled: !isActive.value,
          "default-position": "bottom",
          "disable-positioning": !isModal.value
        }, {
          default: withCtx(({ setContent }) => [
            isModal.value ? (openBlock(), createBlock(Transition, {
              key: 0,
              name: _ctx.animation
            }, {
              default: withCtx(() => [
                withDirectives(createElementVNode("div", {
                  class: normalizeClass(unref(overlayClasses)),
                  tabindex: "-1",
                  onClick: onClickedOutside
                }, null, 2), [
                  [vShow, isActive.value]
                ])
              ]),
              _: 1
            }, 8, ["name"])) : createCommentVNode("", true),
            createVNode(Transition, { name: _ctx.animation }, {
              default: withCtx(() => [
                withDirectives((openBlock(), createBlock(resolveDynamicComponent(_ctx.menuTag), {
                  id: _ctx.menuId,
                  ref: (el) => menuRef.value = setContent(el),
                  tabindex: _ctx.inline ? 0 : -1,
                  class: normalizeClass(unref(menuClasses)),
                  style: normalizeStyle(menuStyle.value),
                  role: _ctx.selectable ? "listbox" : "menu",
                  "aria-labelledby": unref(labelId),
                  "aria-label": _ctx.ariaLabel,
                  "aria-hidden": !_ctx.inline && (_ctx.disabled || !isActive.value),
                  "aria-multiselectable": _ctx.selectable ? unref(isTrueish)(_ctx.multiple) : void 0,
                  onKeydown: [
                    _cache[0] || (_cache[0] = withKeys(withModifiers(($event) => _ctx.inline && onEnter($event), ["prevent"]), ["enter"])),
                    _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => _ctx.inline && onEnter($event), ["prevent"]), ["space"])),
                    _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => _ctx.inline && onUpPressed($event), ["prevent"]), ["up"])),
                    _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.inline && onDownPressed($event), ["prevent"]), ["down"])),
                    _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.inline && onHomePressed($event), ["prevent"]), ["home"])),
                    _cache[5] || (_cache[5] = withKeys(withModifiers(($event) => _ctx.inline && onEndPressed($event), ["prevent"]), ["end"]))
                  ]
                }, {
                  default: withCtx(() => {
                    var _a2;
                    return [
                      renderSlot(_ctx.$slots, "default", {
                        active: isActive.value,
                        focusedIndex: (_a2 = focusedItem.value) == null ? void 0 : _a2.index,
                        toggle
                      }, () => [
                        renderSlot(_ctx.$slots, "before"),
                        (openBlock(true), createElementBlock(Fragment, null, renderList(groupedOptions.value, (group, groupIndex) => {
                          return openBlock(), createElementBlock(Fragment, null, [
                            group.label ? withDirectives((openBlock(), createBlock(_sfc_main$1, mergeProps({
                              key: 0,
                              ref_for: true
                            }, group.attrs, {
                              key: group.key,
                              value: group.value,
                              hidden: group.hidden,
                              role: "presentation",
                              clickable: false
                            }), {
                              default: withCtx(() => [
                                _ctx.$slots.group ? renderSlot(_ctx.$slots, "group", {
                                  key: 0,
                                  group: group.label,
                                  index: groupIndex
                                }) : (openBlock(), createElementBlock("span", _hoisted_1, toDisplayString(group.label), 1))
                              ]),
                              _: 2
                            }, 1040, ["value", "hidden"])), [
                              [vShow, !group.hidden]
                            ]) : createCommentVNode("", true),
                            (openBlock(true), createElementBlock(Fragment, null, renderList(group.options, (option) => {
                              return withDirectives((openBlock(), createBlock(_sfc_main$1, mergeProps({ ref_for: true }, option.attrs, {
                                key: option.key,
                                value: option.value,
                                hidden: option.hidden
                              }), {
                                default: withCtx(() => [
                                  createTextVNode(toDisplayString(option.label), 1)
                                ]),
                                _: 2
                              }, 1040, ["value", "hidden"])), [
                                [vShow, !option.hidden]
                              ]);
                            }), 128))
                          ], 64);
                        }), 256)),
                        renderSlot(_ctx.$slots, "after")
                      ])
                    ];
                  }),
                  _: 2
                }, 1064, ["id", "tabindex", "class", "style", "role", "aria-labelledby", "aria-label", "aria-hidden", "aria-multiselectable"])), [
                  [vShow, !_ctx.disabled && isActive.value || _ctx.inline]
                ])
              ]),
              _: 2
            }, 1032, ["name"])
          ]),
          _: 3
        }, 8, ["position", "teleport", "class", "trigger", "disabled", "disable-positioning"])
      ], 34);
    };
  }
});
export {
  _sfc_main as _,
  _sfc_main$1 as a
};
//# sourceMappingURL=Dropdown.vue_vue_type_script_setup_true_lang-DvIYVcC_.mjs.map
