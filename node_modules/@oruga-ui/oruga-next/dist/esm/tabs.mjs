/*! Oruga v0.10.5 | MIT License | github.com/oruga-ui/oruga */
import { defineComponent, useId, useSlots, computed, ref, createBlock, createCommentVNode, unref, openBlock, Transition, withCtx, withDirectives, createElementVNode, mergeProps, renderSlot, createElementBlock, resolveDynamicComponent, toHandlers, Fragment, createTextVNode, toDisplayString, vShow, mergeModels, useTemplateRef, toValue, useModel, watch, watchEffect, onMounted, nextTick, normalizeClass, renderList, withKeys, withModifiers } from "vue";
import { g as getDefault, b as registerComponent } from "./config-B-gWlaT6.mjs";
import { d as defineClasses } from "./defineClasses-BApkclKh.mjs";
import { a as useProviderChild, u as useProviderParent } from "./useParentProvider-eQyyjCAy.mjs";
import { _ as _sfc_main$2 } from "./Icon.vue_vue_type_script_setup_true_lang-v4MwBFqk.mjs";
import { O as OSlotComponent } from "./SlotComponent-C4Xmui96.mjs";
import { isDefined, mod } from "./helpers.mjs";
import { n as normalizeOptions } from "./useOptions-rS_XNoke.mjs";
import { u as useSequentialId } from "./useSequentialId-aw-jeTgs.mjs";
const _hoisted_1 = ["id", "data-id", "hidden", "aria-labelledby"];
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    isOruga: true,
    name: "OTabItem",
    configField: "tabs",
    inheritAttrs: false
  },
  __name: "TabItem",
  props: {
    override: { type: Boolean, default: void 0 },
    value: { default: void 0 },
    label: { default: void 0 },
    disabled: { type: Boolean, default: false },
    visible: { type: Boolean, default: true },
    icon: { default: () => getDefault("tabs.icon") },
    iconPack: { default: () => getDefault("tabs.iconPack") },
    tag: { default: () => getDefault("tabs.itemTag", "button") },
    content: { default: void 0 },
    component: { default: void 0 },
    props: { default: void 0 },
    events: { default: void 0 },
    tabClass: {},
    tabActiveClass: {},
    tabPreviousClass: {},
    tabNextClass: {},
    tabDisabledClass: {},
    tabIconClass: {},
    tabLabelClass: {},
    tabPanelClass: {}
  },
  emits: ["activate", "deactivate"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const itemValue = props.value ?? useId();
    const slots = useSlots();
    const providedData = computed(() => ({
      ...props,
      value: itemValue,
      $slots: slots,
      tabClasses: tabClasses.value,
      iconClasses: tabIconClasses.value,
      labelClasses: tabLabelClasses.value,
      isTransitioning: isTransitioning.value,
      activate,
      deactivate
    }));
    const { parent, item } = useProviderChild({
      data: providedData
    });
    const transitionName = ref();
    const isActive = computed(() => item.value.index === parent.value.activeIndex);
    const isTransitioning = ref(false);
    const nextAnimation = computed(() => {
      const idx = parent.value.vertical && parent.value.animation.length === 4 ? 2 : 0;
      return parent.value.animation[idx];
    });
    const prevAnimation = computed(() => {
      const idx = parent.value.vertical && parent.value.animation.length === 4 ? 3 : 1;
      return parent.value.animation[idx];
    });
    function activate(oldIndex) {
      transitionName.value = item.value.index < oldIndex ? nextAnimation.value : prevAnimation.value;
      emits("activate");
    }
    function deactivate(newIndex) {
      transitionName.value = newIndex < item.value.index ? nextAnimation.value : prevAnimation.value;
      emits("deactivate");
    }
    function afterEnter() {
      isTransitioning.value = true;
    }
    function beforeLeave() {
      isTransitioning.value = true;
    }
    const tabClasses = defineClasses(
      ["tabClass", "o-tabs__tab"],
      ["tabActiveClass", "o-tabs__tab--active", null, isActive],
      [
        "tabDisabledClass",
        "o-tabs__tab--disabled",
        null,
        computed(() => props.disabled)
      ],
      [
        "tabPreviousClass",
        "o-tabs__tab--previous",
        null,
        computed(() => {
          var _a;
          return item.value.index < ((_a = parent.value) == null ? void 0 : _a.activeIndex);
        })
      ],
      [
        "tabNextClass",
        "o-tabs__tab--next",
        null,
        computed(() => {
          var _a;
          return item.value.index > ((_a = parent.value) == null ? void 0 : _a.activeIndex);
        })
      ]
    );
    const tabIconClasses = defineClasses(["tabIconClass", "o-tabs__tab-icon"]);
    const tabLabelClasses = defineClasses(["tabLabelClass", "o-tabs__tab-label"]);
    const panelClasses = defineClasses(["tabPanelClass", "o-tabs__panel"]);
    return (_ctx, _cache) => {
      return unref(parent) ? (openBlock(), createBlock(Transition, {
        key: 0,
        css: unref(parent).animated,
        name: transitionName.value,
        appear: unref(parent).animateInitially,
        onAfterEnter: afterEnter,
        onBeforeLeave: beforeLeave
      }, {
        default: withCtx(() => [
          withDirectives(createElementVNode("div", mergeProps(_ctx.$attrs, {
            id: `tabpanel-${unref(item).identifier}`,
            "data-oruga": "tabs-item",
            "data-id": `tabs-${unref(item).identifier}`,
            class: unref(panelClasses),
            role: "tabpanel",
            hidden: !isActive.value,
            "aria-labelledby": `tab-${unref(item).identifier}`,
            "aria-roledescription": "item"
          }), [
            renderSlot(_ctx.$slots, "default", {
              active: isActive.value && _ctx.visible
            }, () => [
              _ctx.component ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.component), mergeProps({ key: 0 }, _ctx.$props.props, toHandlers(_ctx.$props.events || {})), null, 16)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(_ctx.content), 1)
              ], 64))
            ]),
            createCommentVNode("", true)
          ], 16, _hoisted_1), [
            [vShow, isActive.value && _ctx.visible]
          ])
        ]),
        _: 3
      }, 8, ["css", "name", "appear"])) : createCommentVNode("", true);
    };
  }
});
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    isOruga: true,
    name: "OTabs",
    configField: "tabs"
  },
  __name: "Tabs",
  props: /* @__PURE__ */ mergeModels({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    options: { default: void 0 },
    variant: { default: () => getDefault("tabs.variant") },
    size: { default: () => getDefault("tabs.size") },
    vertical: { type: Boolean, default: () => getDefault("tabs.vertical", false) },
    position: { default: void 0 },
    type: { default: () => getDefault("tabs.type", "default") },
    expanded: { type: Boolean, default: false },
    tag: { default: () => getDefault("tabs.tag", "div") },
    activateOnFocus: { type: Boolean, default: false },
    animated: { type: Boolean, default: () => getDefault("tabs.animated", true) },
    animation: { default: () => getDefault("tabs.animation", [
      "slide-next",
      "slide-prev",
      "slide-down",
      "slide-up"
    ]) },
    animateInitially: { type: Boolean, default: () => getDefault("tabs.animateInitially", false) },
    multiline: { type: Boolean, default: false },
    ariaLabel: { default: () => getDefault("tabs.ariaLabel") },
    rootClass: {},
    positionClass: {},
    sizeClass: {},
    typeClass: {},
    expandedClass: {},
    verticalClass: {},
    multilineClass: {},
    listClass: {},
    contentClass: {},
    transitioningClass: {}
  }, {
    "modelValue": { default: void 0 },
    "modelModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["update:model-value", "change"], ["update:modelValue"]),
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const rootRef = useTemplateRef("rootElement");
    const provideData = computed(() => {
      var _a;
      return {
        activeIndex: ((_a = activeItem.value) == null ? void 0 : _a.index) ?? 0,
        type: props.type,
        vertical: props.vertical,
        animated: props.animated,
        animation: props.animation,
        animateInitially: props.animateInitially
      };
    });
    const { childItems } = useProviderParent({
      rootRef,
      data: provideData
    });
    const items = computed(() => {
      if (!childItems.value) return [];
      return childItems.value.map((column) => ({
        index: column.index,
        identifier: column.identifier,
        ...toValue(column.data)
      }));
    });
    const { nextSequence } = useSequentialId();
    const normalizedOptions = computed(
      () => normalizeOptions(props.options, nextSequence)
    );
    const vmodel = useModel(__props, "modelValue");
    watch(
      () => props.modelValue,
      (value) => {
        if (vmodel.value !== value) performAction(value);
      }
    );
    const activeItem = ref();
    watchEffect(() => {
      activeItem.value = isDefined(vmodel.value) ? items.value.find((item) => item.value === vmodel.value) || items.value[0] : items.value[0];
    });
    const isTransitioning = computed(
      () => items.value.some((item) => item.isTransitioning)
    );
    onMounted(() => {
      var _a;
      if (!vmodel.value) vmodel.value = (_a = items.value[0]) == null ? void 0 : _a.value;
    });
    function itemClick(item) {
      if (vmodel.value !== item.value) performAction(item.value);
    }
    function onNext(event, index2) {
      if (props.vertical && event.key == "ArrowDown" || !props.vertical && event.key == "ArrowRight") {
        const newIndex = mod(index2 + 1, items.value.length);
        const item = getFirstViableItem(newIndex, true);
        moveFocus(item);
      }
    }
    function onPrev(event, index2) {
      if (props.vertical && event.key == "ArrowUp" || !props.vertical && event.key == "ArrowLeft") {
        const newIndex = mod(index2 - 1, items.value.length);
        const item = getFirstViableItem(newIndex, false);
        moveFocus(item);
      }
    }
    function onHomePressed() {
      if (items.value.length < 1) return;
      const item = getFirstViableItem(0, true);
      moveFocus(item);
    }
    function onEndPressed() {
      if (items.value.length < 1) return;
      const item = getFirstViableItem(items.value.length - 1, false);
      moveFocus(item);
    }
    function moveFocus(item) {
      var _a;
      if (props.activateOnFocus) {
        itemClick(item);
      } else {
        const el = (_a = rootRef.value) == null ? void 0 : _a.querySelector(
          `#tab-${item.identifier}`
        );
        el == null ? void 0 : el.focus();
      }
    }
    function getFirstViableItem(startingIndex, forward) {
      var _a;
      const direction = forward ? 1 : -1;
      let newIndex = startingIndex;
      for (; newIndex !== ((_a = activeItem.value) == null ? void 0 : _a.index); newIndex = mod(newIndex + direction, items.value.length)) {
        if (items.value[newIndex].visible && !items.value[newIndex].disabled)
          break;
      }
      return items.value[newIndex];
    }
    function performAction(newValue) {
      const oldValue = vmodel.value;
      const oldItem = activeItem.value;
      const newItem = items.value.find((item) => item.value === newValue) || items.value[0];
      if (oldItem && newItem) {
        oldItem.deactivate(newItem.index);
        newItem.activate(oldItem.index);
      }
      nextTick(() => {
        vmodel.value = newValue;
        emits("change", newValue, oldValue);
      });
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-tabs"],
      [
        "positionClass",
        "o-tabs--",
        computed(() => props.position),
        computed(() => !!props.position)
      ],
      [
        "sizeClass",
        "o-tabs--",
        computed(() => props.size),
        computed(() => !!props.size)
      ],
      [
        "typeClass",
        "o-tabs--",
        computed(() => props.type),
        computed(() => !!props.type)
      ],
      ["expandedClass", "o-tabs--expanded", null, computed(() => props.expanded)],
      ["verticalClass", "o-tabs--vertical", null, computed(() => props.vertical)],
      [
        "multilineClass",
        "o-tabs--multiline",
        null,
        computed(() => props.multiline)
      ]
    );
    const tablistClasses = defineClasses(["listClass", "o-tabs__list"]);
    const contentClasses = defineClasses(
      ["contentClass", "o-tabs__content"],
      [
        "transitioningClass",
        "o-tabs__content--transitioning",
        null,
        isTransitioning
      ]
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref: "rootElement",
        "data-oruga": "tabs",
        class: normalizeClass(unref(rootClasses))
      }, [
        (openBlock(), createBlock(resolveDynamicComponent(props.tag), {
          class: normalizeClass(unref(tablistClasses)),
          role: "tablist",
          "aria-label": _ctx.ariaLabel,
          "aria-orientation": _ctx.vertical ? "vertical" : "horizontal"
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "before"),
            (openBlock(true), createElementBlock(Fragment, null, renderList(items.value, (childItem) => {
              var _a, _b, _c;
              return withDirectives((openBlock(), createBlock(unref(OSlotComponent), {
                id: `tab-${childItem.identifier}`,
                key: childItem.identifier,
                component: childItem,
                tag: childItem.tag,
                name: "header",
                class: normalizeClass(childItem.tabClasses),
                role: "tab",
                tabindex: childItem.value === ((_a = activeItem.value) == null ? void 0 : _a.value) ? 0 : -1,
                "aria-current": childItem.value === ((_b = activeItem.value) == null ? void 0 : _b.value) ? "true" : void 0,
                "aria-controls": `tabpanel-${childItem.identifier}`,
                "aria-selected": childItem.value === ((_c = activeItem.value) == null ? void 0 : _c.value),
                onClick: ($event) => itemClick(childItem),
                onKeydown: [
                  withKeys(withModifiers(($event) => itemClick(childItem), ["prevent"]), ["enter"]),
                  withKeys(withModifiers(($event) => itemClick(childItem), ["prevent"]), ["space"]),
                  withKeys(withModifiers(($event) => onPrev($event, childItem.index), ["prevent"]), ["left"]),
                  withKeys(withModifiers(($event) => onNext($event, childItem.index), ["prevent"]), ["right"]),
                  withKeys(withModifiers(($event) => onPrev($event, childItem.index), ["prevent"]), ["up"]),
                  withKeys(withModifiers(($event) => onNext($event, childItem.index), ["prevent"]), ["down"]),
                  withKeys(withModifiers(onHomePressed, ["prevent"]), ["home"]),
                  withKeys(withModifiers(onEndPressed, ["prevent"]), ["end"])
                ]
              }, {
                default: withCtx(() => [
                  childItem.icon ? (openBlock(), createBlock(_sfc_main$2, {
                    key: 0,
                    class: normalizeClass(childItem.iconClasses),
                    icon: childItem.icon,
                    pack: childItem.iconPack,
                    size: _ctx.size
                  }, null, 8, ["class", "icon", "pack", "size"])) : createCommentVNode("", true),
                  createElementVNode("span", {
                    class: normalizeClass(childItem.labelClasses)
                  }, toDisplayString(childItem.label), 3)
                ]),
                _: 2
              }, 1032, ["id", "component", "tag", "class", "tabindex", "aria-current", "aria-controls", "aria-selected", "onClick", "onKeydown"])), [
                [vShow, childItem.visible]
              ]);
            }), 128)),
            renderSlot(_ctx.$slots, "after")
          ]),
          _: 3
        }, 8, ["class", "aria-label", "aria-orientation"])),
        createElementVNode("section", {
          class: normalizeClass(unref(contentClasses))
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(normalizedOptions.value, (option) => {
              return withDirectives((openBlock(), createBlock(_sfc_main$1, mergeProps({ ref_for: true }, option.attrs, {
                key: option.key,
                value: option.value,
                label: option.label
              }), null, 16, ["value", "label"])), [
                [vShow, !option.hidden]
              ]);
            }), 128))
          ])
        ], 2)
      ], 2);
    };
  }
});
const index = {
  install(app) {
    registerComponent(app, _sfc_main);
    registerComponent(app, _sfc_main$1);
  }
};
export {
  _sfc_main$1 as OTabItem,
  _sfc_main as OTabs,
  index as default
};
//# sourceMappingURL=tabs.mjs.map
