/*! Oruga v0.10.5 | MIT License | github.com/oruga-ui/oruga */
import { defineComponent, mergeModels, useModel, watch, useId, ref, computed, createElementBlock, openBlock, normalizeClass, unref, createBlock, createVNode, resolveDynamicComponent, withKeys, withCtx, renderSlot, Transition, withDirectives, createElementVNode, createTextVNode, toDisplayString, vShow, nextTick } from "vue";
import { _ as _sfc_main$1 } from "./PositionWrapper.vue_vue_type_script_setup_true_lang-BWfJ96nN.mjs";
import { i as isClient, g as getDefault } from "./config-B-gWlaT6.mjs";
import { d as defineClasses } from "./defineClasses-BApkclKh.mjs";
import { u as useClickOutside } from "./useClickOutside-C73B6jwZ.mjs";
const _hoisted_1 = ["id"];
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    isOruga: true,
    name: "OTooltip",
    configField: "tooltip"
  },
  __name: "Tooltip",
  props: /* @__PURE__ */ mergeModels({
    override: { type: Boolean, default: void 0 },
    active: { type: Boolean, default: false },
    label: { default: void 0 },
    variant: { default: () => getDefault("tooltip.variant") },
    position: { default: () => getDefault("tooltip.position", "auto") },
    always: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    animation: { default: () => getDefault("tooltip.animation", "fade") },
    multiline: { type: Boolean, default: false },
    triggerTag: { default: () => getDefault("tooltip.triggerTag", "div") },
    triggers: { default: () => getDefault("tooltip.triggers", ["hover", "focus"]) },
    delay: { default: void 0 },
    closeable: { type: [Array, Boolean], default: () => getDefault("tooltip.closeable", ["escape", "outside", "content"]) },
    teleport: { type: [Boolean, String, Object], default: () => getDefault("dropdown.teleport", false) },
    rootClass: {},
    teleportClass: {},
    triggerClass: {},
    contentClass: {},
    positionClass: {},
    variantClass: {},
    multilineClass: {},
    alwaysClass: {},
    arrowClass: {},
    arrowPositionClass: {},
    arrowVariantClass: {}
  }, {
    "active": { type: Boolean, ...{ default: false } },
    "activeModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["update:active", "close", "open"], ["update:active"]),
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const isActive = useModel(__props, "active");
    watch(isActive, (value) => {
      if (value) emits("open");
      else emits("close");
    });
    const tooltipId = useId();
    const timer = ref();
    const autoPosition = ref(props.position);
    watch(
      () => props.position,
      (v) => autoPosition.value = v
    );
    const contentRef = ref();
    const triggerRef = ref();
    const cancelOptions = computed(
      () => typeof props.closeable === "boolean" ? props.closeable ? ["escape", "outside", "content"] : [] : props.closeable
    );
    if (isClient && cancelOptions.value.includes("outside")) {
      useClickOutside([contentRef, triggerRef], onClickedOutside, {
        trigger: isActive,
        passive: true
      });
    }
    function onClickedOutside() {
      if (!isActive.value || props.always) return;
      if (!cancelOptions.value.includes("outside")) return;
      isActive.value = false;
    }
    function onEscape() {
      if (!isActive.value) return;
      if (!cancelOptions.value.includes("escape")) return;
      isActive.value = false;
    }
    function onClick() {
      if (!props.triggers.includes("click")) return;
      nextTick(() => setTimeout(() => open()));
    }
    function onContextMenu(event) {
      if (!props.triggers.includes("contextmenu")) return;
      event.preventDefault();
      open();
    }
    function onFocus() {
      if (!props.triggers.includes("focus")) return;
      open();
    }
    function onHover() {
      if (!props.triggers.includes("hover")) return;
      open();
    }
    function open() {
      if (props.disabled) return;
      if (props.delay) {
        timer.value = setTimeout(() => {
          isActive.value = true;
          timer.value = null;
        }, props.delay);
      } else {
        isActive.value = true;
      }
    }
    function onClose() {
      if (!cancelOptions.value.includes("content")) return;
      isActive.value = !props.closeable;
      if (timer.value && props.closeable) clearTimeout(timer.value);
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-tooltip"],
      [
        "teleportClass",
        "o-tooltip--teleport",
        null,
        computed(() => !!props.teleport)
      ]
    );
    const triggerClasses = defineClasses(["triggerClass", "o-tooltip__trigger"]);
    const contentClasses = defineClasses(
      ["contentClass", "o-tooltip__content"],
      [
        "positionClass",
        "o-tooltip__content--",
        autoPosition,
        computed(() => !!autoPosition.value)
      ],
      [
        "variantClass",
        "o-tooltip__content--",
        computed(() => props.variant),
        computed(() => !!props.variant)
      ],
      [
        "multilineClass",
        "o-tooltip__content--multiline",
        null,
        computed(() => props.multiline)
      ],
      [
        "alwaysClass",
        "o-tooltip__content--always",
        null,
        computed(() => props.always)
      ]
    );
    const arrowClasses = defineClasses(
      ["arrowClass", "o-tooltip__arrow"],
      [
        "arrowPositionClass",
        "o-tooltip__arrow--",
        autoPosition,
        computed(() => !!autoPosition.value)
      ],
      [
        "arrowVariantClass",
        "o-tooltip__arrow--",
        computed(() => props.variant),
        computed(() => !!props.variant)
      ]
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        "data-oruga": "tooltip",
        class: normalizeClass(unref(rootClasses))
      }, [
        (openBlock(), createBlock(resolveDynamicComponent(_ctx.triggerTag), {
          ref_key: "triggerRef",
          ref: triggerRef,
          class: normalizeClass(unref(triggerClasses)),
          "aria-haspopup": "true",
          "aria-describedby": unref(tooltipId),
          onKeydown: withKeys(onEscape, ["escape"]),
          onClick,
          onContextmenu: onContextMenu,
          onMouseenter: onHover,
          onFocusCapture: onFocus,
          onBlurCapture: onClose,
          onMouseleave: onClose
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default", { active: isActive.value })
          ]),
          _: 3
        }, 40, ["class", "aria-describedby"])),
        createVNode(_sfc_main$1, {
          position: autoPosition.value,
          "onUpdate:position": _cache[0] || (_cache[0] = ($event) => autoPosition.value = $event),
          teleport: _ctx.teleport,
          class: normalizeClass(unref(rootClasses)),
          trigger: triggerRef.value,
          "default-position": "top",
          disabled: !isActive.value
        }, {
          default: withCtx(({ setContent }) => [
            createVNode(Transition, { name: _ctx.animation }, {
              default: withCtx(() => [
                withDirectives(createElementVNode("div", {
                  id: unref(tooltipId),
                  ref: (el) => contentRef.value = setContent(el),
                  class: normalizeClass(unref(contentClasses)),
                  role: "tooltip"
                }, [
                  createElementVNode("span", {
                    class: normalizeClass(unref(arrowClasses))
                  }, null, 2),
                  renderSlot(_ctx.$slots, "content", {}, () => [
                    createTextVNode(toDisplayString(_ctx.label), 1)
                  ])
                ], 10, _hoisted_1), [
                  [vShow, isActive.value || _ctx.always && !_ctx.disabled]
                ])
              ]),
              _: 2
            }, 1032, ["name"])
          ]),
          _: 3
        }, 8, ["position", "teleport", "class", "trigger", "disabled"])
      ], 2);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=Tooltip.vue_vue_type_script_setup_true_lang-DPWl0fMm.mjs.map
