/*! Oruga v0.10.5 | MIT License | github.com/oruga-ui/oruga */
import { computed, defineComponent, ref, watch, nextTick, effectScope, onUnmounted, createElementBlock, openBlock, normalizeClass, unref, createCommentVNode, withKeys, withModifiers, normalizeStyle, createElementVNode, toDisplayString, Fragment, renderList, mergeModels, useModel, createBlock, createTextVNode, useTemplateRef, createSlots, withCtx, renderSlot, createVNode, mergeProps } from "vue";
import { _ as _sfc_main$5 } from "./Button.vue_vue_type_script_setup_true_lang-DpmQl4e3.mjs";
import { _ as _sfc_main$6 } from "./Select.vue_vue_type_script_setup_true_lang-C8hU8ZRT.mjs";
import { m as matchWithGroups, f as firstWeekOffset, w as weeksInYear, a as weekBuilder, g as getMonthNames, b as getWeekdayNames, _ as _sfc_main$4 } from "./utils-DHWVdkws.mjs";
import { d as defineClasses, g as getActiveClasses } from "./defineClasses-BApkclKh.mjs";
import { isTrueish, isDefined, isDate, pad } from "./helpers.mjs";
import { g as getDefault } from "./config-B-gWlaT6.mjs";
import { u as useMatchMedia } from "./useMatchMedia-DbB9F3o7.mjs";
function useDatepickerMixins(props) {
  function isDateSelectable(date, month) {
    const validity = [];
    if (props.minDate) validity.push(date >= props.minDate);
    if (props.maxDate) validity.push(date <= props.maxDate);
    if (props.nearbyMonthDays && !props.nearbySelectableMonthDays)
      validity.push(date.getMonth() === month);
    if (props.selectableDates) {
      if (typeof props.selectableDates === "function") {
        if (props.selectableDates(date)) return true;
        else validity.push(false);
      } else {
        for (let i = 0; i < props.selectableDates.length; i++) {
          const enabledDate = props.selectableDates[i];
          if (date.getDate() === enabledDate.getDate() && date.getFullYear() === enabledDate.getFullYear() && date.getMonth() === enabledDate.getMonth())
            return true;
          else validity.push(false);
        }
      }
    }
    if (props.unselectableDates) {
      if (typeof props.unselectableDates === "function") {
        validity.push(!props.unselectableDates(date));
      } else {
        for (let i = 0; i < props.unselectableDates.length; i++) {
          const disabledDate = props.unselectableDates[i];
          validity.push(
            date.getDate() !== disabledDate.getDate() || date.getFullYear() !== disabledDate.getFullYear() || date.getMonth() !== disabledDate.getMonth()
          );
        }
      }
    }
    if (props.unselectableDaysOfWeek) {
      for (let i = 0; i < props.unselectableDaysOfWeek.length; i++) {
        const dayOfWeek = props.unselectableDaysOfWeek[i];
        validity.push(date.getDay() !== dayOfWeek);
      }
    }
    return validity.indexOf(false) < 0;
  }
  const isTypeMonth = computed(() => props.type === "month");
  const localeOptions = computed(
    () => new Intl.DateTimeFormat(props.locale, {
      year: "numeric",
      month: "numeric"
    }).resolvedOptions()
  );
  const dtf = computed(
    () => new Intl.DateTimeFormat(
      props.locale
      /*, { timeZone: 'UTC' }*/
    )
  );
  const dtfMonth = computed(
    () => new Intl.DateTimeFormat(props.locale, {
      year: localeOptions.value.year || "numeric",
      month: localeOptions.value.month || "2-digit"
      // timeZone: 'UTC'
    })
  );
  const sampleTime = computed(() => {
    const d = dateCreator();
    d.setHours(10);
    d.setSeconds(0);
    d.setMinutes(0);
    d.setMilliseconds(0);
    return d;
  });
  function dateCreator() {
    return typeof props.creator === "function" ? props.creator() : /* @__PURE__ */ new Date();
  }
  function dateFormatter(date) {
    if (typeof props.formatter === "function") return props.formatter(date);
    if (!date) return "";
    const targetDates = Array.isArray(date) ? date : [date];
    if (!targetDates.length) return "";
    const dates = targetDates.map((date2) => {
      const d = new Date(
        date2.getFullYear(),
        date2.getMonth(),
        date2.getDate(),
        12
      );
      return !isTypeMonth.value ? dtf.value.format(d) : dtfMonth.value.format(d);
    });
    return !isTrueish(props.multiple) && !isTrueish(props.range) ? dates.join(" - ") : dates.join(", ");
  }
  function dateParser(date) {
    if (typeof props.parser === "function") return props.parser(date);
    if (!date) return void 0;
    const isArray = isTrueish(props.multiple) || isTrueish(props.range);
    const targetDates = !isArray ? [date] : date.split(", ");
    const dates = targetDates.map((date2) => {
      if (dtf.value.formatToParts && typeof dtf.value.formatToParts === "function") {
        const formatRegex = (isTypeMonth.value ? dtfMonth.value : dtf.value).formatToParts(sampleTime.value).map((part) => {
          if (part.type === "literal") return part.value;
          return `((?!=<${part.type}>)\\d+)`;
        }).join("");
        const dateGroups = matchWithGroups(formatRegex, date2);
        if (dateGroups.year && dateGroups.year.length === 4 && dateGroups.month && dateGroups.month <= 12) {
          if (isTypeMonth.value)
            return new Date(dateGroups.year, dateGroups.month - 1);
          else if (dateGroups.day && dateGroups.day <= 31) {
            return new Date(
              dateGroups.year,
              dateGroups.month - 1,
              dateGroups.day,
              12
            );
          }
        }
      }
      if (!isTypeMonth.value) return new Date(Date.parse(date2));
      const s = date2.split("/");
      const year = s[0].length === 4 ? s[0] : s[1];
      const month = s[0].length === 2 ? s[0] : s[1];
      if (year && month) {
        return new Date(
          parseInt(year, 10),
          parseInt(month, 10) - 1,
          1,
          0,
          0,
          0,
          0
        );
      }
    });
    return isArray ? dates : dates[0];
  }
  return {
    dtf,
    isDateSelectable,
    dateCreator,
    dateParser,
    dateFormatter
  };
}
const _hoisted_1$1 = ["tabindex"];
const _hoisted_2 = ["tabindex", "onClick", "onMouseenter", "onFocus", "onKeydown"];
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ODatepickerTableRow",
    configField: "datepicker"
  },
  __name: "DatepickerTableRow",
  props: {
    day: { type: Number, required: true },
    week: { type: Array, required: true },
    month: { type: Number, required: true },
    selectedDate: {
      type: [Date, Array],
      default: void 0
    },
    events: { type: Array, default: void 0 },
    hoveredDateRange: { type: Array, required: true },
    pickerProps: {
      type: Object,
      required: true
    }
  },
  emits: ["select", "hover-enddate", "change-focus", "week-number-click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { isDateSelectable, dateCreator } = useDatepickerMixins(
      props.pickerProps
    );
    const hasEvents = computed(() => {
      var _a;
      return !!((_a = props.events) == null ? void 0 : _a.length);
    });
    const dayRefs = ref(/* @__PURE__ */ new Map());
    function setDayRef(date, el) {
      const refKey = `day-${date.getMonth()}-${date.getDate()}`;
      if (el) dayRefs.value.set(refKey, el);
    }
    watch(
      () => props.day,
      (day) => {
        if (props.week.map((d) => d.getDate()).includes(day))
          nextTick(() => {
            const refKey = `day-${props.month}-${day}`;
            const ref2 = dayRefs.value.get(refKey);
            if (ref2) ref2.focus();
          });
      }
    );
    watch(
      () => props.month,
      // clear day refs on month change
      () => dayRefs.value = /* @__PURE__ */ new Map()
    );
    function clickWeekNumber(week) {
      if (props.pickerProps.weekNumberClickable) emits("week-number-click", week);
    }
    function getDayOfYear(input) {
      return Math.round(
        (input.getTime() - new Date(input.getFullYear(), 0, 1).getTime()) / 864e5
      ) + 1;
    }
    function getWeekNumber(mom) {
      const dow = props.pickerProps.firstDayOfWeek;
      const doy = props.pickerProps.rulesForFirstWeek;
      const weekOffset = firstWeekOffset(mom.getFullYear(), dow, doy);
      const week = Math.floor((getDayOfYear(mom) - weekOffset - 1) / 7) + 1;
      let resWeek;
      let resYear;
      if (week < 1) {
        resYear = mom.getFullYear() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
      } else if (week > weeksInYear(mom.getFullYear(), dow, doy)) {
        resWeek = week - weeksInYear(mom.getFullYear(), dow, doy);
        resYear = mom.getFullYear() + 1;
      } else {
        resYear = mom.getFullYear();
        resWeek = week;
      }
      return resWeek;
    }
    function eventsDateMatch(day) {
      var _a;
      if (!((_a = props.events) == null ? void 0 : _a.length)) return [];
      return props.events.filter((event) => event.date.getDay() === day.getDay());
    }
    function onKeydown(event, weekDay) {
      let preventDefault = true;
      switch (event.key) {
        case "Tab": {
          preventDefault = false;
          break;
        }
        case " ":
        case "Space":
        case "Spacebar":
        case "Enter": {
          selectDate(weekDay);
          break;
        }
        case "ArrowLeft":
        case "Left": {
          changeFocus(weekDay, -1);
          break;
        }
        case "ArrowRight":
        case "Right": {
          changeFocus(weekDay, 1);
          break;
        }
        case "ArrowUp":
        case "Up": {
          changeFocus(weekDay, -7);
          break;
        }
        case "ArrowDown":
        case "Down": {
          changeFocus(weekDay, 7);
          break;
        }
      }
      if (preventDefault) event.preventDefault();
    }
    function selectDate(date) {
      if (props.pickerProps.disabled || props.pickerProps.readonly) return;
      if (isDateSelectable(date, props.month)) emits("select", date);
    }
    function changeFocus(day, inc) {
      const nextDay = new Date(day.getTime());
      nextDay.setDate(day.getDate() + inc);
      while (props.pickerProps.minDate && nextDay < props.pickerProps.minDate || props.pickerProps.maxDate && nextDay > props.pickerProps.maxDate || !isDateSelectable(nextDay, nextDay.getMonth())) {
        nextDay.setDate(nextDay.getDate() - Math.sign(inc));
      }
      setRangeHoverEndDate(nextDay);
      emits("change-focus", nextDay);
    }
    function setRangeHoverEndDate(day) {
      if (isTrueish(props.pickerProps.range)) emits("hover-enddate", day);
    }
    function dateMatch(dateOne, dateTwo, multiple = false) {
      if (!dateOne || !dateTwo || multiple) return false;
      if (Array.isArray(dateTwo))
        return dateTwo.some(
          (date) => dateOne.getDate() === date.getDate() && dateOne.getFullYear() === date.getFullYear() && dateOne.getMonth() === date.getMonth()
        );
      return dateOne.getDate() === dateTwo.getDate() && dateOne.getFullYear() === dateTwo.getFullYear() && dateOne.getMonth() === dateTwo.getMonth();
    }
    function dateWithin(dateOne, dates, multiple = false) {
      if (!Array.isArray(dates) || multiple) return false;
      return dateOne > dates[0] && dateOne < dates[1];
    }
    const scope = effectScope();
    onUnmounted(() => scope.stop());
    function cellClasses(day) {
      const classes = defineClasses(
        [
          "tableCellSelectedClass",
          "o-datepicker__table__cell--selected",
          null,
          dateMatch(day, props.selectedDate) || dateWithin(
            day,
            props.selectedDate,
            isTrueish(props.pickerProps.multiple)
          )
        ],
        [
          "tableCellFirstSelectedClass",
          "o-datepicker__table__cell--first-selected",
          null,
          dateMatch(
            day,
            Array.isArray(props.selectedDate) ? props.selectedDate[0] : void 0,
            isTrueish(props.pickerProps.multiple)
          )
        ],
        [
          "tableCellWithinSelectedClass",
          "o-datepicker__table__cell--within-selected",
          null,
          dateWithin(
            day,
            props.selectedDate,
            isTrueish(props.pickerProps.multiple)
          )
        ],
        [
          "tableCellLastSelectedClass",
          "o-datepicker__table__cell--last-selected",
          null,
          dateMatch(
            day,
            Array.isArray(props.selectedDate) ? props.selectedDate[1] : void 0,
            isTrueish(props.pickerProps.multiple)
          )
        ],
        [
          "tableCellFirstHoveredClass",
          "o-datepicker__table__cell--first-hovered",
          null,
          dateMatch(
            day,
            Array.isArray(props.hoveredDateRange) ? props.hoveredDateRange[0] : void 0
          )
        ],
        [
          "tableCellWithinHoveredClass",
          "o-datepicker__table__cell--within-hovered",
          null,
          dateWithin(day, props.hoveredDateRange)
        ],
        [
          "tableCellLastHoveredClass",
          "o-datepicker__table__cell--last-hovered",
          null,
          dateMatch(
            day,
            Array.isArray(props.hoveredDateRange) ? props.hoveredDateRange[1] : void 0
          )
        ],
        [
          "tableCellTodayClass",
          "o-datepicker__table__cell--today",
          null,
          dateMatch(day, dateCreator())
        ],
        [
          "tableCellSelectableClass",
          "o-datepicker__table__cell--selectable",
          null,
          isDateSelectable(day, props.month) && !props.pickerProps.disabled && !props.pickerProps.readonly
        ],
        [
          "tableCellUnselectableClass",
          "o-datepicker__table__cell--unselectable",
          null,
          !isDateSelectable(day, props.month) || props.pickerProps.disabled
        ],
        [
          "tableCellInvisibleClass",
          "o-datepicker__table__cell--invisible",
          null,
          !props.pickerProps.nearbyMonthDays && day.getMonth() !== props.month
        ],
        [
          "tableCellNearbyClass",
          "o-datepicker__table__cell--nearby",
          null,
          props.pickerProps.nearbySelectableMonthDays && day.getMonth() !== props.month
        ],
        // pass effect scope for rectivity binding
        { scope }
      );
      return [
        ...tableCellClasses.value,
        ...cellEventsClass.value,
        ...classes.value
      ];
    }
    function eventClasses(event) {
      const classes = defineClasses(
        ["tableEventClass", "o-datepicker__table__event"],
        [
          "tableEventVariantClass",
          "o-datepicker__table__event--",
          event.type,
          !!event.type
        ],
        [
          "tableEventIndicatorClass",
          "o-datepicker__table__event--",
          props.pickerProps.indicators,
          !!props.pickerProps.indicators
        ],
        // pass effect scope for rectivity binding
        { scope }
      );
      return classes.value;
    }
    const tableRowClasses = defineClasses(
      ["tableRowClass", "o-datepicker__table__row"],
      // passing the picker props will add reactivity to property changes
      { props: props.pickerProps }
    );
    const tableCellClasses = defineClasses(
      ["tableCellClass", "o-datepicker__table__cell"],
      // passing the picker props will add reactivity to property changes
      { props: props.pickerProps }
    );
    const tableEventsClasses = defineClasses(
      ["tableEventsClass", "o-datepicker__table__events"],
      // passing the picker props will add reactivity to property changes
      { props: props.pickerProps }
    );
    const cellEventsClass = defineClasses(
      [
        "tableCellEventsClass",
        "o-datepicker__table__cell--events",
        null,
        hasEvents
      ],
      // passing the picker props will add reactivity to property changes
      { props: props.pickerProps }
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(tableRowClasses))
      }, [
        __props.pickerProps.showWeekNumber ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(unref(tableCellClasses)),
          style: normalizeStyle({
            cursor: __props.pickerProps.weekNumberClickable ? "pointer" : "auto"
          }),
          tabindex: __props.pickerProps.weekNumberClickable ? 0 : void 0,
          role: "button",
          onClick: _cache[0] || (_cache[0] = withModifiers(($event) => clickWeekNumber(getWeekNumber(__props.week[6])), ["prevent"])),
          onKeydown: _cache[1] || (_cache[1] = withKeys(withModifiers(($event) => clickWeekNumber(getWeekNumber(__props.week[6])), ["prevent"]), ["enter"]))
        }, [
          createElementVNode("span", null, toDisplayString(getWeekNumber(__props.week[6])), 1)
        ], 46, _hoisted_1$1)) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(__props.week, (weekDay, idx) => {
          return openBlock(), createElementBlock(Fragment, { key: idx }, [
            !__props.pickerProps.disabled && !__props.pickerProps.readonly && unref(isDateSelectable)(weekDay, __props.month) ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref_for: true,
              ref: (el) => setDayRef(weekDay, el),
              class: normalizeClass(cellClasses(weekDay)),
              role: "button",
              tabindex: __props.day === weekDay.getDate() && __props.month === weekDay.getMonth() ? void 0 : 0,
              onClick: withModifiers(($event) => selectDate(weekDay), ["prevent"]),
              onMouseenter: ($event) => setRangeHoverEndDate(weekDay),
              onFocus: ($event) => setRangeHoverEndDate(weekDay),
              onKeydown: withKeys(withModifiers(($event) => onKeydown($event, weekDay), ["prevent"]), ["enter"])
            }, [
              createElementVNode("span", null, toDisplayString(weekDay.getDate()), 1),
              eventsDateMatch(weekDay).length ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(tableEventsClasses))
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(eventsDateMatch(weekDay), (event, index) => {
                  return openBlock(), createElementBlock("div", {
                    key: index,
                    class: normalizeClass(eventClasses(event))
                  }, null, 2);
                }), 128))
              ], 2)) : createCommentVNode("", true)
            ], 42, _hoisted_2)) : (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(cellClasses(weekDay))
            }, [
              createElementVNode("span", null, toDisplayString(weekDay.getDate()), 1)
            ], 2))
          ], 64);
        }), 128))
      ], 2);
    };
  }
});
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ODatepickerTable",
    configField: "datepicker"
  },
  __name: "DatepickerTable",
  props: /* @__PURE__ */ mergeModels({
    modelValue: {
      type: [Date, Array],
      default: void 0
    },
    focusedDate: { type: Object, required: true },
    dayNames: { type: Array, required: true },
    monthNames: { type: Array, required: true },
    pickerProps: {
      type: Object,
      required: true
    }
  }, {
    "focusedDate": {
      required: true
    },
    "focusedDateModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["update:model-value", "update:focusedDate", "range-start", "range-end", "week-number-click"], ["update:focusedDate"]),
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { isDateSelectable } = useDatepickerMixins(props.pickerProps);
    const focusedDateModel = useModel(__props, "focusedDate");
    const selectedBeginDate = ref();
    const selectedEndDate = ref();
    const hoveredEndDate = ref();
    const visibleDayNames = computed(() => {
      const visibleDayNames2 = [];
      let index = props.pickerProps.firstDayOfWeek || 0;
      while (visibleDayNames2.length < props.dayNames.length) {
        const currentDayName = props.dayNames[index % props.dayNames.length];
        visibleDayNames2.push(currentDayName);
        index++;
      }
      if (props.pickerProps.showWeekNumber) visibleDayNames2.unshift("");
      return visibleDayNames2;
    });
    const eventsInThisMonth = computed(() => {
      if (!props.pickerProps.events) return [];
      return props.pickerProps.events.map(
        (event) => !event.date && event instanceof Date ? { date: event } : event
      ).filter(
        (event) => event.date.getMonth() === focusedDateModel.value.month && event.date.getFullYear() === focusedDateModel.value.year
      );
    });
    const weeksInThisMonth = computed(() => {
      validateFocusedDay();
      const month = focusedDateModel.value.month;
      const year = focusedDateModel.value.year;
      const weeksInThisMonth2 = [];
      let startingDay = 1;
      while (weeksInThisMonth2.length < 6) {
        const newWeek = weekBuilder(
          startingDay,
          month,
          year,
          props.pickerProps.firstDayOfWeek || 0
        );
        weeksInThisMonth2.push(newWeek);
        startingDay += 7;
      }
      return weeksInThisMonth2;
    });
    function eventsInThisWeek(week) {
      if (!props.pickerProps.events) return [];
      return eventsInThisMonth.value.filter((event) => {
        const stripped = new Date(event.date);
        stripped.setHours(0, 0, 0, 0);
        const timed = stripped.getTime();
        return week.some((weekDate) => weekDate.getTime() === timed);
      });
    }
    const hoveredDateRange = computed(() => {
      if (!isTrueish(props.pickerProps.range) || selectedEndDate.value) return [];
      return ((hoveredEndDate.value || 0) < (selectedBeginDate.value || 0) ? [hoveredEndDate.value, selectedBeginDate.value] : [selectedBeginDate.value, hoveredEndDate.value]).filter(isDefined);
    });
    function validateFocusedDay() {
      const currentDate = new Date(
        focusedDateModel.value.year,
        focusedDateModel.value.month,
        focusedDateModel.value.day
      );
      if (isDateSelectable(currentDate, focusedDateModel.value.month)) return;
      let day = 0;
      const monthDays = new Date(
        focusedDateModel.value.year,
        focusedDateModel.value.month + 1,
        0
      ).getDate();
      let firstFocusable;
      while (!firstFocusable && ++day < monthDays) {
        const date = new Date(
          focusedDateModel.value.year,
          focusedDateModel.value.month,
          day
        );
        if (isDateSelectable(date, focusedDateModel.value.month)) {
          firstFocusable = currentDate;
          focusedDateModel.value = {
            day: date.getDate(),
            month: date.getMonth(),
            year: date.getFullYear()
          };
        }
      }
    }
    function onSelectedDate(date) {
      if (props.pickerProps.disabled) return;
      else if (isTrueish(props.pickerProps.range)) handleSelectRangeDate(date);
      else if (isTrueish(props.pickerProps.multiple))
        handleSelectMultipleDates(date);
      else emits("update:model-value", date);
    }
    function handleSelectRangeDate(date) {
      if (selectedBeginDate.value && selectedEndDate.value) {
        selectedBeginDate.value = date;
        selectedEndDate.value = void 0;
        emits("range-start", date);
      } else if (selectedBeginDate.value && !selectedEndDate.value) {
        if (selectedBeginDate.value > date) {
          selectedEndDate.value = selectedBeginDate.value;
          selectedBeginDate.value = date;
        } else {
          selectedEndDate.value = date;
        }
        emits("range-end", date);
        emits("update:model-value", [
          selectedBeginDate.value,
          selectedEndDate.value
        ]);
      } else {
        selectedBeginDate.value = date;
        emits("range-start", date);
      }
    }
    function handleSelectMultipleDates(date) {
      let multipleSelectedDates = Array.isArray(props.modelValue) ? props.modelValue : [];
      const multipleSelect = multipleSelectedDates.filter(
        (selectedDate) => selectedDate.getDate() === date.getDate() && selectedDate.getFullYear() === date.getFullYear() && selectedDate.getMonth() === date.getMonth()
      );
      if (multipleSelect.length) {
        multipleSelectedDates = multipleSelectedDates.filter(
          (selectedDate) => selectedDate.getDate() !== date.getDate() || selectedDate.getFullYear() !== date.getFullYear() || selectedDate.getMonth() !== date.getMonth()
        );
      } else {
        multipleSelectedDates = [...multipleSelectedDates, date];
      }
      emits("update:model-value", multipleSelectedDates);
    }
    function onRangeHoverEndDate(date) {
      hoveredEndDate.value = date;
    }
    function onChangeFocus(date) {
      focusedDateModel.value = {
        day: date.getDate(),
        month: date.getMonth(),
        year: date.getFullYear()
      };
    }
    const tableClasses = defineClasses(
      ["tableClass", "o-datepicker__table"],
      // passing the picker props will add reactivity to property changes
      { props: props.pickerProps }
    );
    const tableHeadClasses = defineClasses(
      ["tableHeadClass", "o-datepicker__table__head"],
      // passing the picker props will add reactivity to property changes
      { props: props.pickerProps }
    );
    const tableCellClasses = defineClasses(
      ["tableCellClass", "o-datepicker__table__cell"],
      // passing the picker props will add reactivity to property changes
      { props: props.pickerProps }
    );
    const tableHeadCellClasses = defineClasses(
      ["tableHeadCellClass", "o-datepicker__table__head-cell"],
      // passing the picker props will add reactivity to property changes
      { props: props.pickerProps }
    );
    const tableBodyClasses = defineClasses(
      ["tableBodyClass", "o-datepicker__table__body"],
      // passing the picker props will add reactivity to property changes
      { props: props.pickerProps }
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("section", {
        class: normalizeClass(unref(tableClasses))
      }, [
        createElementVNode("header", {
          class: normalizeClass(unref(tableHeadClasses))
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(visibleDayNames.value, (day, index) => {
            return openBlock(), createElementBlock("div", {
              key: index,
              class: normalizeClass([...unref(tableCellClasses), ...unref(tableHeadCellClasses)])
            }, [
              createElementVNode("span", null, toDisplayString(day), 1)
            ], 2);
          }), 128))
        ], 2),
        createElementVNode("div", {
          class: normalizeClass(unref(tableBodyClasses))
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(weeksInThisMonth.value, (week, index) => {
            return openBlock(), createBlock(_sfc_main$3, {
              key: index,
              "selected-date": __props.modelValue,
              day: focusedDateModel.value.day,
              week,
              month: focusedDateModel.value.month,
              events: eventsInThisWeek(week),
              "hovered-date-range": hoveredDateRange.value,
              "picker-props": props.pickerProps,
              onSelect: onSelectedDate,
              onHoverEnddate: onRangeHoverEndDate,
              onChangeFocus,
              onWeekNumberClick: _cache[0] || (_cache[0] = ($event) => _ctx.$emit("week-number-click", $event))
            }, null, 8, ["selected-date", "day", "week", "month", "events", "hovered-date-range", "picker-props"]);
          }), 128))
        ], 2)
      ], 2);
    };
  }
});
const _hoisted_1 = ["tabindex", "onClick", "onMouseenter", "onFocus", "onKeydown"];
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  ...{
    name: "ODatepickerMonth",
    configField: "datepicker",
    inheritAttrs: false
  },
  __name: "DatepickerMonth",
  props: {
    modelValue: {
      type: [Date, Array],
      default: void 0
    },
    monthNames: { type: Array, required: true },
    focusedDate: { type: Object, required: true },
    pickerProps: {
      type: Object,
      required: true
    }
  },
  emits: ["update:model-value", "update:focusedDate", "range-start", "range-end"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { dateCreator } = useDatepickerMixins(props.pickerProps);
    const selectedBeginDate = ref();
    const selectedEndDate = ref();
    const hoveredEndDate = ref();
    const hasEvents = computed(() => {
      var _a;
      return !!((_a = props.pickerProps.events) == null ? void 0 : _a.length);
    });
    const monthRefs = ref(/* @__PURE__ */ new Map());
    function setMonthRef(date, el) {
      const refKey = `month-${date.getMonth()}`;
      if (el) monthRefs.value.set(refKey, el);
    }
    watch(
      () => props.focusedDate.month,
      (month) => {
        const refKey = `month-${month}`;
        nextTick(() => {
          const ref2 = monthRefs.value.get(refKey);
          if ((ref2 == null ? void 0 : ref2.length) > 0 && ref2[0]) {
            ref2[0].focus();
          }
        });
      }
    );
    const eventsInThisYear = computed(() => {
      if (!props.pickerProps.events) return [];
      return props.pickerProps.events.map((event) => {
        if (!event.date && event instanceof Date) event = { date: event };
        if (!event.type) event.type = "is-primary";
        return event;
      }).filter((event) => event.date.getFullYear() === props.focusedDate.year);
    });
    const monthDates = computed(() => {
      const year = props.focusedDate.year;
      const months = [];
      for (let i = 0; i < 12; i++) {
        const d = new Date(year, i, 1);
        d.setHours(0, 0, 0, 0);
        months.push(d);
      }
      return months;
    });
    const hoveredDateRange = computed(() => {
      if (!isTrueish(props.pickerProps.range) || !selectedEndDate.value)
        return [];
      return (hoveredEndDate.value && selectedBeginDate.value && hoveredEndDate.value < selectedBeginDate.value ? [hoveredEndDate.value, selectedBeginDate.value] : [selectedBeginDate.value, hoveredEndDate.value]).filter(isDefined);
    });
    function eventsDateMatch(day) {
      if (!eventsInThisYear.value.length) return [];
      return eventsInThisYear.value.filter(
        (event) => event.date.getMonth() === day.getMonth()
      );
    }
    function isDateSelectable(date) {
      const validity = [];
      if (props.pickerProps.minDate)
        validity.push(date >= props.pickerProps.minDate);
      if (props.pickerProps.maxDate)
        validity.push(date <= props.pickerProps.maxDate);
      validity.push(date.getFullYear() === props.focusedDate.year);
      if (props.pickerProps.selectableDates) {
        if (typeof props.pickerProps.selectableDates === "function") {
          if (props.pickerProps.selectableDates(date)) return true;
          else validity.push(false);
        } else {
          for (let i = 0; i < props.pickerProps.selectableDates.length; i++) {
            const enabledDate = props.pickerProps.selectableDates[i];
            if (date.getFullYear() === enabledDate.getFullYear() && date.getMonth() === enabledDate.getMonth())
              return true;
            else validity.push(false);
          }
        }
      }
      if (props.pickerProps.unselectableDates) {
        if (typeof props.pickerProps.unselectableDates === "function") {
          validity.push(!props.pickerProps.unselectableDates(date));
        } else {
          for (let i = 0; i < props.pickerProps.unselectableDates.length; i++) {
            const disabledDate = props.pickerProps.unselectableDates[i];
            validity.push(
              date.getFullYear() !== disabledDate.getFullYear() || date.getMonth() !== disabledDate.getMonth()
            );
          }
        }
      }
      if (props.pickerProps.unselectableDaysOfWeek) {
        for (let i = 0; i < props.pickerProps.unselectableDaysOfWeek.length; i++) {
          const dayOfWeek = props.pickerProps.unselectableDaysOfWeek[i];
          validity.push(date.getDay() !== dayOfWeek);
        }
      }
      return validity.indexOf(false) < 0;
    }
    function onKeydown(event, weekDay) {
      let preventDefault = true;
      switch (event.key) {
        case "Tab": {
          preventDefault = false;
          break;
        }
        case " ":
        case "Space":
        case "Spacebar":
        case "Enter": {
          selectDate(weekDay);
          break;
        }
        case "ArrowLeft":
        case "Left": {
          changeFocus(weekDay, -1);
          break;
        }
        case "ArrowRight":
        case "Right": {
          changeFocus(weekDay, 1);
          break;
        }
        case "ArrowUp":
        case "Up": {
          changeFocus(weekDay, -7);
          break;
        }
        case "ArrowDown":
        case "Down": {
          changeFocus(weekDay, 7);
          break;
        }
      }
      if (preventDefault) event.preventDefault();
    }
    function selectDate(date) {
      if (props.pickerProps.disabled || props.pickerProps.readonly) return;
      if (!isDateSelectable(date)) return;
      if (isTrueish(props.pickerProps.range)) handleSelectRangeDate(date);
      else if (isTrueish(props.pickerProps.multiple))
        handleSelectMultipleDates(date);
      else emits("update:model-value", date);
    }
    function handleSelectRangeDate(date) {
      if (selectedBeginDate.value && selectedEndDate.value) {
        selectedBeginDate.value = date;
        selectedEndDate.value = void 0;
        emits("range-start", date);
      } else if (selectedBeginDate.value && !selectedEndDate.value) {
        if (selectedBeginDate.value > date) {
          selectedEndDate.value = selectedBeginDate.value;
          selectedBeginDate.value = date;
        } else {
          selectedEndDate.value = date;
        }
        emits("range-end", date);
        emits("update:model-value", [
          selectedBeginDate.value,
          selectedEndDate.value
        ]);
      } else {
        selectedBeginDate.value = date;
        emits("range-start", date);
      }
    }
    const multipleSelectedDates = computed(
      () => isTrueish(props.pickerProps.multiple) && props.modelValue ? props.modelValue : []
    );
    function handleSelectMultipleDates(date) {
      if (!Array.isArray(props.modelValue)) return;
      let multipleSelectedDates2 = props.modelValue;
      const multipleSelect = multipleSelectedDates2.filter(
        (selectedDate) => selectedDate.getDate() === date.getDate() && selectedDate.getFullYear() === date.getFullYear() && selectedDate.getMonth() === date.getMonth()
      );
      if (multipleSelect.length) {
        multipleSelectedDates2 = multipleSelectedDates2.filter(
          (selectedDate) => selectedDate.getDate() !== date.getDate() || selectedDate.getFullYear() !== date.getFullYear() || selectedDate.getMonth() !== date.getMonth()
        );
      } else {
        multipleSelectedDates2.push(date);
      }
      emits("update:model-value", multipleSelectedDates2);
    }
    function changeFocus(month, inc) {
      month.setMonth(month.getMonth() + inc);
      const focused = {
        day: month.getDate(),
        month: month.getMonth(),
        year: month.getFullYear()
      };
      emits("update:focusedDate", focused);
    }
    function onRangeHoverEndDate(day) {
      if (isTrueish(props.pickerProps.range)) hoveredEndDate.value = day;
    }
    function dateMatch(dateOne, dateTwo, multiple = false) {
      if (!dateOne || !dateTwo || multiple) return false;
      if (Array.isArray(dateTwo))
        return dateTwo.some(
          (date) => dateOne.getFullYear() === date.getFullYear() && dateOne.getMonth() === date.getMonth()
        );
      return dateOne.getFullYear() === dateTwo.getFullYear() && dateOne.getMonth() === dateTwo.getMonth();
    }
    function dateWithin(dateOne, dates, multiple = false) {
      if (!Array.isArray(dates) || multiple) return false;
      return dateOne > dates[0] && dateOne < dates[1];
    }
    function dateMultipleSelected(dateOne, dates, multiple = false) {
      if (!Array.isArray(dates) || !multiple) return false;
      return dates.some(
        (date) => dateOne.getDate() === date.getDate() && dateOne.getFullYear() === date.getFullYear() && dateOne.getMonth() === date.getMonth()
      );
    }
    const monthClasses = defineClasses(
      ["monthClass", "o-datepicker__month"],
      // passing the picker props will add reactivity to property changes
      { props: props.pickerProps }
    );
    const monthTableClasses = defineClasses(
      ["monthTableClass", "o-datepicker__month__table"],
      // passing the picker props will add reactivity to property changes
      { props: props.pickerProps }
    );
    const monthCellClasses = defineClasses(
      ["monthCellClass", "o-datepicker__month__cell"],
      [
        "monthCellEventsClass",
        "o-datepicker__month__cell--events",
        null,
        hasEvents
      ],
      // passing the picker props will add reactivity to property changes
      { props: props.pickerProps }
    );
    const scope = effectScope();
    onUnmounted(() => scope.stop());
    function cellClasses(day) {
      const classes = defineClasses(
        [
          "monthCellSelectedClass",
          "o-datepicker__month__cell--selected",
          null,
          dateMatch(
            day,
            props.modelValue,
            isTrueish(props.pickerProps.multiple)
          ) || dateWithin(
            day,
            props.modelValue,
            isTrueish(props.pickerProps.multiple)
          ) || dateMultipleSelected(
            day,
            multipleSelectedDates.value,
            isTrueish(props.pickerProps.multiple)
          )
        ],
        [
          "monthCellFirstSelectedClass",
          "o-datepicker__month__cell--first-selected",
          null,
          dateMatch(
            day,
            Array.isArray(props.modelValue) && props.modelValue[0],
            isTrueish(props.pickerProps.multiple)
          )
        ],
        [
          "monthCellWithinSelectedClass",
          "o-datepicker__month__cell--within-selected",
          null,
          dateWithin(
            day,
            props.modelValue,
            isTrueish(props.pickerProps.multiple)
          )
        ],
        [
          "monthCellLastSelectedClass",
          "o-datepicker__month__cell--last-selected",
          null,
          dateMatch(
            day,
            Array.isArray(props.modelValue) && props.modelValue[1],
            isTrueish(props.pickerProps.multiple)
          )
        ],
        [
          "monthCellWithinHoveredRangeClass",
          "o-datepicker__month__cell--within-hovered-range",
          null,
          hoveredDateRange.value && hoveredDateRange.value.length === 2 && (dateMatch(day, hoveredDateRange.value) || dateWithin(day, hoveredDateRange.value))
        ],
        [
          "monthCellFirstHoveredClass",
          "o-datepicker__month__cell--first-hovered",
          null,
          dateMatch(
            day,
            Array.isArray(hoveredDateRange.value) && hoveredDateRange.value[0]
          )
        ],
        [
          "monthCellWithinHoveredClass",
          "o-datepicker__month__cell--within-hovered",
          null,
          dateWithin(day, hoveredDateRange.value)
        ],
        [
          "monthCellLastHoveredClass",
          "o-datepicker__month__cell--last-hovered",
          null,
          dateMatch(
            day,
            Array.isArray(hoveredDateRange.value) && hoveredDateRange.value[1]
          )
        ],
        [
          "monthCellTodayClass",
          "o-datepicker__month__cell--today",
          null,
          dateMatch(day, dateCreator())
        ],
        [
          "monthCellSelectableclass",
          "o-datepicker__month__cell--selectable",
          null,
          isDateSelectable(day) && !props.pickerProps.disabled && !props.pickerProps.readonly
        ],
        [
          "monthCellUnselectableClass",
          "o-datepicker__month__cell--unselectable",
          null,
          !isDateSelectable(day) || props.pickerProps.disabled
        ],
        // pass effect scope for rectivity binding
        { scope }
      );
      return [...monthCellClasses.value, ...classes.value];
    }
    const monthEventsClasses = defineClasses(
      ["monthEventsClass", "o-datepicker__month__events"],
      // passing the picker props will add reactivity to property changes
      { props: props.pickerProps }
    );
    function eventClasses(event) {
      const classes = defineClasses(
        ["monthEventClass", "o-datepicker__month__event"],
        [
          "monthEventTypeClass",
          "o-datepicker__month__event--",
          event.type,
          !!event.type
        ],
        [
          "monthEventIndicatorClass",
          "o-datepicker__month__event--",
          props.pickerProps.indicators,
          !!props.pickerProps.indicators
        ],
        // pass effect scope for rectivity binding
        { scope }
      );
      return classes.value;
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("section", {
        class: normalizeClass(unref(monthClasses))
      }, [
        createElementVNode("div", {
          class: normalizeClass(unref(monthTableClasses))
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(monthDates.value, (date, idx) => {
            return openBlock(), createElementBlock(Fragment, { key: idx }, [
              !__props.pickerProps.disabled && !__props.pickerProps.readonly && isDateSelectable(date) ? (openBlock(), createElementBlock("div", {
                key: 0,
                ref_for: true,
                ref: (el) => setMonthRef(date, el),
                class: normalizeClass(cellClasses(date)),
                role: "button",
                tabindex: __props.focusedDate.month === date.getMonth() ? void 0 : 0,
                onClick: withModifiers(($event) => selectDate(date), ["prevent"]),
                onMouseenter: ($event) => onRangeHoverEndDate(date),
                onFocus: ($event) => onRangeHoverEndDate(date),
                onKeydown: withModifiers(($event) => onKeydown($event, date), ["prevent"])
              }, [
                createTextVNode(toDisplayString(__props.monthNames[date.getMonth()]) + " ", 1),
                eventsDateMatch(date).length ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(monthEventsClasses))
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(eventsDateMatch(date), (event, index) => {
                    return openBlock(), createElementBlock("div", {
                      key: index,
                      class: normalizeClass(eventClasses(event))
                    }, null, 2);
                  }), 128))
                ], 2)) : createCommentVNode("", true)
              ], 42, _hoisted_1)) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(cellClasses(date))
              }, [
                createTextVNode(toDisplayString(__props.monthNames[date.getMonth()]) + " ", 1),
                eventsDateMatch(date).length ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(unref(monthEventsClasses))
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(eventsDateMatch(date), (event, index) => {
                    return openBlock(), createElementBlock("div", {
                      key: index,
                      class: normalizeClass(eventClasses(event))
                    }, null, 2);
                  }), 128))
                ], 2)) : createCommentVNode("", true)
              ], 2))
            ], 64);
          }), 128))
        ], 2)
      ], 2);
    };
  }
});
const _sfc_main = /* @__PURE__ */ defineComponent({
  ...{
    isOruga: true,
    name: "ODatepicker",
    configField: "datepicker"
  },
  __name: "Datepicker",
  props: /* @__PURE__ */ mergeModels({
    override: { type: Boolean, default: void 0 },
    modelValue: { default: void 0 },
    range: {},
    multiple: {},
    active: { type: Boolean, default: false },
    type: { default: "date" },
    dayNames: { default: () => getDefault("datepicker.dayNames") },
    monthNames: { default: () => getDefault("datepicker.monthNames") },
    size: { default: () => getDefault("datepicker.size") },
    focusedDate: { default: void 0 },
    events: { default: void 0 },
    indicators: { default: "dots" },
    minDate: { default: void 0 },
    maxDate: { default: void 0 },
    expanded: { type: Boolean, default: false },
    rounded: { type: Boolean, default: false },
    inline: { type: Boolean, default: false },
    placeholder: { default: void 0 },
    readonly: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    openOnFocus: { type: Boolean, default: () => getDefault("datepicker.openOnFocus", true) },
    closeOnClick: { type: Boolean, default: () => getDefault("datepicker.closeOnClick", true) },
    locale: { default: () => getDefault("locale") },
    formatter: { type: Function, default: getDefault("datepicker.formatter") },
    parser: { type: Function, default: getDefault("datepicker.parser") },
    creator: { type: Function, default: getDefault("datepicker.creator") },
    selectableDates: { type: [Array, Function], default: void 0 },
    unselectableDates: { type: [Array, Function], default: void 0 },
    unselectableDaysOfWeek: { default: () => getDefault("datepicker.unselectableDaysOfWeek") },
    nearbyMonthDays: { type: Boolean, default: () => getDefault("datepicker.nearbyMonthDays", true) },
    nearbySelectableMonthDays: { type: Boolean, default: () => getDefault("datepicker.nearbySelectableMonthDays", false) },
    showWeekNumber: { type: Boolean, default: () => getDefault("datepicker.showWeekNumber", false) },
    weekNumberClickable: { type: Boolean, default: () => getDefault("datepicker.weekNumberClickable", false) },
    firstDayOfWeek: { default: () => getDefault("datepicker.firstDayOfWeek", 0) },
    rulesForFirstWeek: { default: 4 },
    yearsRange: { default: () => getDefault("datepicker.yearsRange", [-100, 10]) },
    position: { default: void 0 },
    iconPack: { default: () => getDefault("datepicker.iconPack") },
    icon: { default: () => getDefault("datepicker.icon") },
    iconRight: { default: () => getDefault("datepicker.iconRight") },
    iconRightClickable: { type: Boolean, default: false },
    iconPrev: { default: () => getDefault("datepicker.iconPrev", "chevron-left") },
    iconNext: { default: () => getDefault("datepicker.iconNext", "chevron-right") },
    mobileModal: { type: Boolean, default: () => getDefault("datepicker.mobileModal", true) },
    desktopModal: { type: Boolean, default: () => getDefault("datepicker.desktopModal", false) },
    mobileNative: { type: Boolean, default: () => getDefault("datepicker.mobileNative", false) },
    mobileBreakpoint: { default: () => getDefault("datepicker.mobileBreakpoint") },
    teleport: { type: [Boolean, String, Object], default: () => getDefault("datepicker.teleport", false) },
    useHtml5Validation: { type: Boolean, default: () => getDefault("useHtml5Validation", true) },
    customValidity: { type: [String, Function], default: "" },
    ariaNextLabel: { default: () => getDefault("datepicker.ariaNextLabel", "Next Page") },
    ariaPreviousLabel: { default: () => getDefault("datepicker.ariaNextLabel", "Previous Page") },
    ariaSelectMonthLabel: { default: () => getDefault("datepicker.ariaSelectMonthLabel", "Select Month") },
    ariaSelectYearLabel: { default: () => getDefault("datepicker.ariaSelectYearLabel", "Select Year") },
    rootClass: {},
    mobileClass: {},
    sizeClass: {},
    expandedClass: {},
    boxClass: {},
    headerClass: {},
    prevButtonClass: {},
    nextButtonClass: {},
    listsClass: {},
    footerClass: {},
    tableClass: {},
    tableHeadClass: {},
    tableHeadCellClass: {},
    tableBodyClass: {},
    tableRowClass: {},
    tableCellClass: {},
    tableCellInvisibleClass: {},
    tableCellSelectedClass: {},
    tableCellFirstSelectedClass: {},
    tableCellWithinSelectedClass: {},
    tableCellLastSelectedClass: {},
    tableCellFirstHoveredClass: {},
    tableCellWithinHoveredClass: {},
    tableCellLastHoveredClass: {},
    tableCellTodayClass: {},
    tableCellSelectableClass: {},
    tableCellUnselectableClass: {},
    tableCellNearbyClass: {},
    tableCellEventsClass: {},
    tableEventsClass: {},
    tableEventClass: {},
    tableEventVariantClass: {},
    tableEventIndicatorClass: {},
    monthClass: {},
    monthTableClass: {},
    monthCellClass: {},
    monthCellSelectedClass: {},
    monthCellFirstSelectedClass: {},
    monthCellWithinSelectedClass: {},
    monthCellLastSelectedClass: {},
    monthCellWithinHoveredRangeClass: {},
    monthCellFirstHoveredClass: {},
    monthCellWithinHoveredClass: {},
    monthCellLastHoveredClass: {},
    monthCellTodayClass: {},
    monthCellSelectableClass: {},
    monthCellUnselectableClass: {},
    monthCellEventsClass: {},
    monthEventsClass: {},
    monthEventClass: {},
    monthEventVariantClass: {},
    monthEventIndicatorClass: {},
    dropdownClass: {},
    inputClass: {},
    inputClasses: { default: () => getDefault("datepicker.inputClasses") },
    dropdownClasses: { default: () => getDefault("datepicker.dropdownClasses") },
    selectClasses: { default: () => getDefault("datepicker.selectClasses") }
  }, {
    "modelValue": { default: void 0 },
    "modelModifiers": {},
    "active": { type: Boolean, ...{ default: false } },
    "activeModifiers": {}
  }),
  emits: /* @__PURE__ */ mergeModels(["update:model-value", "update:active", "range-start", "range-end", "change-month", "change-year", "focus", "blur", "invalid", "icon-click", "icon-right-click"], ["update:modelValue", "update:active"]),
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const { dtf, dateCreator, dateFormatter, dateParser } = useDatepickerMixins(props);
    const { isMobile } = useMatchMedia(props.mobileBreakpoint);
    const pickerRef = useTemplateRef("pickerComponent");
    const vmodel = useModel(__props, "modelValue");
    const isActive = useModel(__props, "active");
    const isTypeMonth = computed(() => props.type === "month");
    watch(
      () => props.modelValue,
      (value) => {
        const isArray = Array.isArray(value);
        const currentDate = isArray ? value.length ? value[value.length - 1] : dateCreator() : value ? value : dateCreator();
        if (!isArray || isArray && Array.isArray(vmodel.value) && value.length > vmodel.value.length)
          focusedDateData.value = {
            day: currentDate.getDate(),
            month: currentDate.getMonth(),
            year: currentDate.getFullYear()
          };
      }
    );
    watch(
      () => props.focusedDate,
      (value) => {
        if (value) {
          focusedDateData.value = {
            day: value.getDate(),
            month: value.getMonth(),
            year: value.getFullYear()
          };
        }
      }
    );
    const _initialDate = (Array.isArray(props.modelValue) ? props.modelValue[0] : props.modelValue) || props.focusedDate || dateCreator();
    if (!props.modelValue && props.maxDate && props.maxDate.getFullYear() < _initialDate.getFullYear()) {
      _initialDate.setFullYear(props.maxDate.getFullYear());
    }
    const focusedDateData = ref({
      day: _initialDate.getDate(),
      month: _initialDate.getMonth(),
      year: _initialDate.getFullYear()
    });
    watch(
      () => focusedDateData.value.month,
      (value) => emits("change-month", value)
    );
    watch(
      () => focusedDateData.value.year,
      (value) => emits("change-year", value)
    );
    const computedMonthNames = computed(
      () => Array.isArray(props.monthNames) ? props.monthNames : getMonthNames(props.locale)
    );
    const listOfMonths = computed(() => {
      let minMonth = 0;
      let maxMonth = 12;
      if (props.minDate && focusedDateData.value.year === props.minDate.getFullYear()) {
        minMonth = props.minDate.getMonth();
      }
      if (props.maxDate && focusedDateData.value.year === props.maxDate.getFullYear()) {
        maxMonth = props.maxDate.getMonth();
      }
      return computedMonthNames.value.map((name, index) => ({
        label: name,
        value: index,
        attrs: { disabled: index < minMonth || index > maxMonth }
      }));
    });
    const computedDayNames = computed(
      () => Array.isArray(props.dayNames) ? props.dayNames : getWeekdayNames(props.locale)
    );
    const listOfYears = computed(() => {
      let latestYear = _initialDate.getFullYear() + props.yearsRange[1];
      if (props.maxDate && props.maxDate.getFullYear() < latestYear) {
        latestYear = Math.max(
          props.maxDate.getFullYear(),
          focusedDateData.value.year
        );
      }
      let earliestYear = _initialDate.getFullYear() + props.yearsRange[0];
      if (props.minDate && props.minDate.getFullYear() > earliestYear) {
        earliestYear = Math.min(
          props.minDate.getFullYear(),
          focusedDateData.value.year
        );
      }
      return Array.from(
        { length: latestYear - earliestYear + 1 || 1 },
        (value, index) => earliestYear + index
      ).reverse().map((year) => ({
        label: String(year),
        value: year
      }));
    });
    const showPrev = computed(() => {
      if (!props.minDate) return true;
      if (isTypeMonth.value)
        return focusedDateData.value.year > props.minDate.getFullYear();
      const dateToCheck = new Date(
        focusedDateData.value.year,
        focusedDateData.value.month
      );
      const date = new Date(
        props.minDate.getFullYear(),
        props.minDate.getMonth()
      );
      return dateToCheck > date;
    });
    function prev() {
      if (props.disabled) return;
      if (isTypeMonth.value) {
        focusedDateData.value.year -= 1;
      } else {
        if (focusedDateData.value.month > 0) {
          focusedDateData.value.month -= 1;
        } else {
          focusedDateData.value.month = 11;
          focusedDateData.value.year -= 1;
        }
      }
    }
    const showNext = computed(() => {
      if (!props.maxDate) return true;
      if (isTypeMonth.value)
        return focusedDateData.value.year < props.maxDate.getFullYear();
      const dateToCheck = new Date(
        focusedDateData.value.year,
        focusedDateData.value.month
      );
      const date = new Date(
        props.maxDate.getFullYear(),
        props.maxDate.getMonth()
      );
      return dateToCheck < date;
    });
    function next() {
      if (props.disabled) return;
      if (isTypeMonth.value) {
        focusedDateData.value.year += 1;
      } else {
        if (focusedDateData.value.month < 11) {
          focusedDateData.value.month += 1;
        } else {
          focusedDateData.value.month = 0;
          focusedDateData.value.year += 1;
        }
      }
    }
    function format(value, isNative) {
      if (isNative) return formatNative(value);
      const date = Array.isArray(value) ? [...value] : value;
      return dateFormatter(date);
    }
    function formatNative(value) {
      if (Array.isArray(value)) value = value[0];
      if (!value) return "";
      const date = new Date(value);
      if (!isDate(date)) return "";
      if (isTypeMonth.value) {
        const year = date.getFullYear();
        const month = date.getMonth() + 1;
        return year + "-" + pad(month);
      } else {
        const year = date.getFullYear();
        const month = date.getMonth() + 1;
        const day = date.getDate();
        return year + "-" + pad(month) + "-" + pad(day);
      }
    }
    function parse(value, isNative) {
      if (isNative) return parseNative(value);
      const date = dateParser(value);
      const isValid = isDate(date) || Array.isArray(date) && date.length === 2 && isDate(date[0]) && isDate(date[1]);
      return isValid ? date : void 0;
    }
    function parseNative(value) {
      const s = value ? value.split("-") : [];
      if (s.length !== 3) return void 0;
      const year = parseInt(s[0], 10);
      const month = parseInt(s[1]) - 1;
      const day = parseInt(s[2]);
      return new Date(year, month, day);
    }
    function prevDate() {
      if (props.disabled) return;
      if (isTypeMonth.value) {
        focusedDateData.value.year -= 1;
      } else {
        const date = new Date(
          focusedDateData.value.year,
          focusedDateData.value.month,
          focusedDateData.value.day
        );
        date.setDate(date.getDate() - 1);
        focusedDateData.value.day = date.getDate();
        focusedDateData.value.month = date.getMonth();
        focusedDateData.value.year = date.getFullYear();
      }
    }
    function nextDate() {
      if (props.disabled) return;
      if (isTypeMonth.value) {
        focusedDateData.value.year += 1;
      } else {
        const date = new Date(
          focusedDateData.value.year,
          focusedDateData.value.month,
          focusedDateData.value.day
        );
        date.setDate(date.getDate() + 1);
        focusedDateData.value.day = date.getDate();
        focusedDateData.value.month = date.getMonth();
        focusedDateData.value.year = date.getFullYear();
      }
    }
    const rootClasses = defineClasses(
      ["rootClass", "o-datepicker"],
      [
        "sizeClass",
        "o-datepicker--",
        computed(() => props.size),
        computed(() => !!props.size)
      ],
      ["mobileClass", "o-datepicker--mobile", null, isMobile],
      [
        "expandedClass",
        "o-datepicker--expanded",
        null,
        computed(() => props.expanded)
      ]
    );
    const boxClasses = defineClasses(["boxClass", "o-datepicker__box"]);
    const boxClassBind = computed(() => getActiveClasses(boxClasses));
    const headerClasses = defineClasses(["headerClass", "o-datepicker__header"]);
    const prevButtonClasses = defineClasses([
      "prevButtonClass",
      "o-datepicker__header__previous"
    ]);
    const nextButtonClasses = defineClasses([
      "nextButtonClass",
      "o-datepicker__header__next"
    ]);
    const listsClasses = defineClasses([
      "listsClass",
      "o-datepicker__header__list"
    ]);
    const footerClasses = defineClasses(["footerClass", "o-datepicker__footer"]);
    const pickerDropdownClasses = defineClasses([
      "dropdownClass",
      "o-datepicker__dropdown"
    ]);
    __expose({ focus: () => {
      var _a;
      return (_a = pickerRef.value) == null ? void 0 : _a.focus();
    }, value: vmodel });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$4, {
        ref: "pickerComponent",
        active: isActive.value,
        "onUpdate:active": _cache[12] || (_cache[12] = ($event) => isActive.value = $event),
        value: vmodel.value,
        "onUpdate:value": _cache[13] || (_cache[13] = ($event) => vmodel.value = $event),
        "data-oruga": "datepicker",
        "picker-props": props,
        formatter: format,
        parser: parse,
        type: !isTypeMonth.value ? "date" : "month",
        max: _ctx.maxDate,
        min: _ctx.minDate,
        "stay-open": props.multiple,
        "root-classes": unref(rootClasses),
        "dropdown-classes": unref(pickerDropdownClasses),
        "box-class": boxClassBind.value,
        dtf: unref(dtf),
        onFocus: _cache[14] || (_cache[14] = ($event) => _ctx.$emit("focus", $event)),
        onBlur: _cache[15] || (_cache[15] = ($event) => _ctx.$emit("blur", $event)),
        onInvalid: _cache[16] || (_cache[16] = ($event) => _ctx.$emit("invalid", $event)),
        onLeft: prevDate,
        onRight: nextDate,
        onIconClick: _cache[17] || (_cache[17] = ($event) => _ctx.$emit("icon-click", $event)),
        onIconRightClick: _cache[18] || (_cache[18] = ($event) => _ctx.$emit("icon-right-click", $event))
      }, createSlots({
        default: withCtx(() => [
          createElementVNode("header", {
            class: normalizeClass(unref(headerClasses))
          }, [
            renderSlot(_ctx.$slots, "header", {}, () => [
              !_ctx.disabled ? (openBlock(), createBlock(_sfc_main$5, {
                key: 0,
                class: normalizeClass(unref(prevButtonClasses)),
                disabled: !showPrev.value,
                "icon-pack": _ctx.iconPack,
                "icon-left": _ctx.iconPrev,
                size: _ctx.size,
                "aria-label": _ctx.ariaPreviousLabel,
                onClick: withModifiers(prev, ["prevent"]),
                onKeydown: [
                  withKeys(withModifiers(prev, ["prevent"]), ["enter"]),
                  withKeys(withModifiers(prev, ["prevent"]), ["space"])
                ]
              }, null, 8, ["class", "disabled", "icon-pack", "icon-left", "size", "aria-label", "onKeydown"])) : createCommentVNode("", true),
              !_ctx.disabled ? (openBlock(), createBlock(_sfc_main$5, {
                key: 1,
                class: normalizeClass(unref(nextButtonClasses)),
                disabled: !showNext.value,
                "icon-pack": _ctx.iconPack,
                "icon-left": _ctx.iconNext,
                size: _ctx.size,
                "aria-label": _ctx.ariaNextLabel,
                onClick: withModifiers(next, ["prevent"]),
                onKeydown: [
                  withKeys(withModifiers(next, ["prevent"]), ["enter"]),
                  withKeys(withModifiers(next, ["prevent"]), ["space"])
                ]
              }, null, 8, ["class", "disabled", "icon-pack", "icon-left", "size", "aria-label", "onKeydown"])) : createCommentVNode("", true),
              createElementVNode("div", {
                class: normalizeClass(unref(listsClasses))
              }, [
                !isTypeMonth.value ? (openBlock(), createBlock(_sfc_main$6, mergeProps({ key: 0 }, _ctx.selectClasses, {
                  modelValue: focusedDateData.value.month,
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => focusedDateData.value.month = $event),
                  disabled: _ctx.disabled,
                  size: _ctx.size,
                  options: listOfMonths.value,
                  "aria-label": _ctx.ariaSelectMonthLabel,
                  "use-html5-validation": false,
                  onKeydown: [
                    withKeys(withModifiers(prev, ["stop", "prevent"]), ["left"]),
                    withKeys(withModifiers(next, ["stop", "prevent"]), ["right"])
                  ]
                }), null, 16, ["modelValue", "disabled", "size", "options", "aria-label", "onKeydown"])) : createCommentVNode("", true),
                createVNode(_sfc_main$6, mergeProps(_ctx.selectClasses, {
                  modelValue: focusedDateData.value.year,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => focusedDateData.value.year = $event),
                  disabled: _ctx.disabled,
                  size: _ctx.size,
                  options: listOfYears.value,
                  "aria-label": _ctx.ariaSelectYearLabel,
                  "use-html5-validation": false,
                  onKeydown: [
                    withKeys(withModifiers(prev, ["stop", "prevent"]), ["left"]),
                    withKeys(withModifiers(next, ["stop", "prevent"]), ["right"]),
                    _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => focusedDateData.value.year += 1, ["stop", "prevent"]), ["up"])),
                    _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => focusedDateData.value.year -= 1, ["stop", "prevent"]), ["down"]))
                  ]
                }), null, 16, ["modelValue", "disabled", "size", "options", "aria-label", "onKeydown"])
              ], 2)
            ])
          ], 2),
          renderSlot(_ctx.$slots, "body", {}, () => [
            isTypeMonth.value ? (openBlock(), createBlock(_sfc_main$1, {
              key: 0,
              modelValue: vmodel.value,
              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => vmodel.value = $event),
              "focused-date": focusedDateData.value,
              "onUpdate:focusedDate": _cache[5] || (_cache[5] = ($event) => focusedDateData.value = $event),
              "month-names": computedMonthNames.value,
              "picker-props": props,
              onRangeStart: _cache[6] || (_cache[6] = (date) => _ctx.$emit("range-start", date)),
              onRangeEnd: _cache[7] || (_cache[7] = (date) => _ctx.$emit("range-end", date))
            }, null, 8, ["modelValue", "focused-date", "month-names"])) : (openBlock(), createBlock(_sfc_main$2, {
              key: 1,
              modelValue: vmodel.value,
              "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => vmodel.value = $event),
              "focused-date": focusedDateData.value,
              "onUpdate:focusedDate": _cache[9] || (_cache[9] = ($event) => focusedDateData.value = $event),
              "day-names": computedDayNames.value,
              "month-names": computedMonthNames.value,
              "picker-props": props,
              onRangeStart: _cache[10] || (_cache[10] = (date) => _ctx.$emit("range-start", date)),
              onRangeEnd: _cache[11] || (_cache[11] = (date) => _ctx.$emit("range-end", date))
            }, null, 8, ["modelValue", "focused-date", "day-names", "month-names"]))
          ]),
          _ctx.$slots.footer ? (openBlock(), createElementBlock("footer", {
            key: 0,
            class: normalizeClass(unref(footerClasses))
          }, [
            renderSlot(_ctx.$slots, "footer")
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 2
      }, [
        _ctx.$slots.trigger ? {
          name: "trigger",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "trigger")
          ]),
          key: "0"
        } : void 0
      ]), 1032, ["active", "value", "type", "max", "min", "stay-open", "root-classes", "dropdown-classes", "box-class", "dtf"]);
    };
  }
});
export {
  _sfc_main as _
};
//# sourceMappingURL=Datepicker.vue_vue_type_script_setup_true_lang-CnYF-Zir.mjs.map
